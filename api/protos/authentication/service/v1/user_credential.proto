syntax = "proto3";

package authentication.service.v1;

import "gnostic/openapi/v3/annotations.proto";

import "google/protobuf/empty.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";

import "redact/v3/redact.proto";

import "pagination/v1/pagination.proto";

// User credential service
service UserCredentialService {
  // Query list
  rpc List (pagination.PagingRequest) returns (ListUserCredentialResponse) {}

  // Query
  rpc Get (GetUserCredentialRequest) returns (UserCredential) {}
  rpc GetByIdentifier (GetUserCredentialByIdentifierRequest) returns (UserCredential) {}

  // Create
  rpc Create (CreateUserCredentialRequest) returns (google.protobuf.Empty) {}

  // Update
  rpc Update (UpdateUserCredentialRequest) returns (google.protobuf.Empty) {}

  // Delete
  rpc Delete (DeleteUserCredentialRequest) returns (google.protobuf.Empty) {}


  // Verify credential
  rpc VerifyCredential (VerifyCredentialRequest) returns (VerifyCredentialResponse) {}

  // Change credential
  rpc ChangeCredential (ChangeCredentialRequest) returns (google.protobuf.Empty) {}

  // Reset credential
  rpc ResetCredential (ResetCredentialRequest) returns (google.protobuf.Empty) {}
}

// User credential
message UserCredential {
  // Identity type
  enum IdentityType {
    USERNAME = 0; // Username
    USERID = 1; // User ID
    EMAIL = 2; // Email address
    PHONE = 3; // Phone number

    // Common external/third-party identity types
    SOCIAL_OAUTH = 100;    // Social platform OAuth authentication
    ENTERPRISE_SSO = 200;  // Enterprise single sign-on (SAML/OIDC/AD)
    IDENTITY_API_KEY = 300;         // API key (used for service-to-service authentication, etc.)
    DEVICE_ID = 400;       // Device identifier

    // Extensible/custom
    IDENTITY_CUSTOM = 1000;
    IDENTITY_RESERVED_FOR_FUTURE = 10000;
  }

  // Credential type
  enum CredentialType {
    TYPE_UNSPECIFIED = 0;

    // Password types
    PASSWORD_HASH = 1;

    // API / Static keys
    API_KEY = 10;
    API_SECRET = 11;

    // Access/refresh tokens
    ACCESS_TOKEN = 20;
    REFRESH_TOKEN = 21;
    JWT = 22;

    // OAuth / Social
    OAUTH_TOKEN = 30;
    OAUTH_AUTHORIZATION_CODE = 31;
    OAUTH_CLIENT_CREDENTIALS = 32;

    // OTP / One-time password and MFA
    OTP = 40;
    TOTP = 41;
    SMS_OTP = 42;
    EMAIL_OTP = 43;

    // Device / Hardware / Software tokens
    HARDWARE_TOKEN = 50;
    SOFTWARE_TOKEN = 51;
    SECURITY_KEY = 52;

    // Biometric
    BIOMETRIC = 60;
    BIOMETRIC_TOKEN = 61;

    // SSO / Assertions
    SSO_TOKEN = 70;
    SAML_ASSERTION = 71;
    OPENID_CONNECT_ID_TOKEN = 72;

    // Temporary / Session types
    SESSION_COOKIE = 80;
    TEMPORARY_CREDENTIAL = 81;

    // Other / Custom
    CUSTOM = 200;
    RESERVED_FOR_FUTURE = 1000;
  }

  // User credential status
  enum Status {
    DISABLED = 0; // Credential is disabled, user cannot authenticate with this credential (e.g., account frozen).
    ENABLED = 1; // Credential is valid, user can normally use this credential to login or register.
    EXPIRED = 2; // Credential has expired (e.g., temporary credential timeout).
    UNVERIFIED = 3; // Credential is unverified (user must complete verification flow before it takes effect).
    REMOVED = 4; // Credential has been removed (logical deletion, not physical, audit records retained).
    BLOCKED = 5; // Credential is locked (usually triggered by security mechanism due to multiple failed attempts).
    TEMPORARY = 6; // Temporary credential (only valid within specific time period).
  }

  uint32 id = 1; // Primary key ID

  optional uint32 user_id = 2 [
    json_name = "userId",
    (gnostic.openapi.v3.property) = {description: "User ID associated with the main table"}
  ];  // User ID associated with the main table
  optional uint32 tenant_id = 3 [
    json_name = "tenantId",
    (gnostic.openapi.v3.property) = {description: "Tenant ID"}
  ]; // Tenant ID

  optional IdentityType identity_type = 10 [
    json_name = "identityType",
    (gnostic.openapi.v3.property) = {description: "Authentication method type, such as username+password, email+password, phone+verification code, third-party platform authentication, etc."}
  ]; // Authentication method type
  optional string identifier = 11 [
    json_name = "identifier",
    (gnostic.openapi.v3.property) = {description: "Identity unique identifier, if password login then username; if email login then email address; if phone login then phone number; if third-party platform login then the unique ID from that platform (e.g., WeChat OpenID)"}
  ]; // Identity unique identifier

  optional CredentialType credential_type = 20 [
    json_name = "credentialType",
    (gnostic.openapi.v3.property) = {description: "Credential type, such as encrypted password, access token, refresh token, etc."}
  ]; // Credential type
  optional string credential = 21 [
    (redact.v3.value).string = "",
    json_name = "credential",
    (gnostic.openapi.v3.property) = {description: "Credential, if password login then password hash; if email login then email verification code; if phone login then phone verification code; if third-party platform login then the access_token from that platform"}
  ]; // Credential

  optional bool is_primary = 30 [
    json_name = "isPrimary",
    (gnostic.openapi.v3.property) = { description: "Whether primary authentication method, if user has both email and phone bound, email can be designated as the primary authentication method." }
  ]; // Whether primary authentication method

  optional Status status = 31 [
    json_name = "status",
    (gnostic.openapi.v3.property) = { description: "Credential status" }
  ]; // Credential status

  optional string extra_info = 32 [
    json_name = "extraInfo",
    (gnostic.openapi.v3.property) = { description: "Extra information, if third-party platform authentication, can record user information from the third-party platform." }
  ]; // Extra information

  optional string provider = 33 [
    json_name = "provider",
    (gnostic.openapi.v3.property) = { description: "Third-party platform identifier (e.g., google, wechat)" }
  ];   // Third-party platform identifier (e.g., `google`, `wechat`), used when identity_type is SOCIAL_OAUTH/ENTERPRISE_SSO

  optional string provider_account_id = 34 [
    json_name = "providerAccountId",
    (gnostic.openapi.v3.property) = { description: "Third-party platform account unique ID" }
  ]; // Third-party platform account unique ID (e.g., OpenID / unionid / sub)

  optional uint32 created_by = 100 [json_name = "createdBy", (gnostic.openapi.v3.property) = {description: "Creator ID"}]; // Creator ID
  optional uint32 updated_by = 101 [json_name = "updatedBy", (gnostic.openapi.v3.property) = {description: "Updater ID"}]; // Updater ID

  optional google.protobuf.Timestamp created_at = 200 [json_name = "createdAt", (gnostic.openapi.v3.property) = {description: "Created time"}];// Created time
  optional google.protobuf.Timestamp updated_at = 201 [json_name = "updatedAt", (gnostic.openapi.v3.property) = {description: "Updated time"}];// Updated time
  optional google.protobuf.Timestamp deleted_at = 202 [json_name = "deletedAt", (gnostic.openapi.v3.property) = {description: "Deleted time"}];// Deleted time
}

// Query list - Response
message ListUserCredentialResponse {
  repeated UserCredential items = 1;
  uint64 total = 2;
}

// Update - Request
message UpdateUserCredentialRequest {
  uint32 id = 1;

  UserCredential data = 2;

  google.protobuf.FieldMask update_mask = 3 [
    (gnostic.openapi.v3.property) = {
      description: "List of fields to update",
      example: {yaml : "id,realname,username"}
    },
    json_name = "updateMask"
  ]; // List of fields to update

  optional bool allow_missing = 4 [
    (gnostic.openapi.v3.property) = {description: "If set to true, when the resource does not exist it will be created (inserted), and in this case the `updateMask` field will be ignored."},
    json_name = "allowMissing"
  ]; // If set to true, when the resource does not exist it will be created (inserted), and in this case the `updateMask` field will be ignored.
}

// Create - Request
message CreateUserCredentialRequest {
  UserCredential data = 1;
}

// Delete - Request
message DeleteUserCredentialRequest {
  uint32 id = 1;
}

// Query - Request
message GetUserCredentialRequest {
  oneof query_by {
    uint32 id = 1 [
      (gnostic.openapi.v3.property) = {description: "ID", read_only: true},
      json_name = "id"
    ]; // ID
  }

  optional google.protobuf.FieldMask view_mask = 100 [
    json_name = "viewMask",
    (gnostic.openapi.v3.property) = {
      description: "View field filter, used to control returned fields"
    }
  ]; // View field filter, used to control returned fields
}

// Query - Request
message GetUserCredentialByIdentifierRequest {
  UserCredential.IdentityType identity_type = 1 [
    json_name = "identityType", (gnostic.openapi.v3.property) = {description: "Identity type"}
  ]; // Identity type

  string identifier = 2 [
    json_name = "identifier", (gnostic.openapi.v3.property) = {description: "Identity unique identifier"}
  ]; // Identity unique identifier
}

// Verify credential - Request
message VerifyCredentialRequest {
  UserCredential.IdentityType identity_type = 1 [
    json_name = "identityType", (gnostic.openapi.v3.property) = {description: "Identity type"}
  ]; // Identity type

  string identifier = 2 [
    json_name = "identifier", (gnostic.openapi.v3.property) = {description: "Identity unique identifier"}
  ]; // Identity unique identifier

  string credential = 3 [
    (redact.v3.value).string = "",
    json_name = "credential", (gnostic.openapi.v3.property) = {description: "Credential"}
  ]; // Credential

  bool need_decrypt = 4 [
    json_name = "needDecrypt", (gnostic.openapi.v3.property) = {description: "Whether decryption is needed"}
  ]; // Whether decryption is needed
}
// Verify credential - Response
message VerifyCredentialResponse {
  bool success = 1;
}

// Change credential - Request
message ChangeCredentialRequest {
  UserCredential.IdentityType identity_type = 1 [
    json_name = "identityType", (gnostic.openapi.v3.property) = {description: "Identity type"}
  ]; // Identity type

  string identifier = 2 [
    json_name = "identifier", (gnostic.openapi.v3.property) = {description: "Identity unique identifier"}
  ]; // Identity unique identifier

  string old_credential = 3 [
    (redact.v3.value).string = "",
    json_name = "oldCredential", (gnostic.openapi.v3.property) = {description: "Old credential"}
  ]; // Old credential

  string new_credential = 4 [
    (redact.v3.value).string = "",
    json_name = "newCredential", (gnostic.openapi.v3.property) = {description: "New credential"}
  ]; // New credential

  bool need_decrypt = 5 [
    json_name = "needDecrypt", (gnostic.openapi.v3.property) = {description: "Whether decryption is needed"}
  ]; // Whether decryption is needed
}

// Reset credential - Request
message ResetCredentialRequest {
  UserCredential.IdentityType identity_type = 1 [
    json_name = "identityType", (gnostic.openapi.v3.property) = {description: "Identity type"}
  ]; // Identity type

  string identifier = 2 [
    json_name = "identifier", (gnostic.openapi.v3.property) = {description: "Identity unique identifier"}
  ]; // Identity unique identifier

  string new_credential = 3 [
    (redact.v3.value).string = "",
    json_name = "newCredential", (gnostic.openapi.v3.property) = {description: "New credential"}
  ]; // New credential

  bool need_decrypt = 4 [
    json_name = "needDecrypt", (gnostic.openapi.v3.property) = {description: "Whether decryption is needed"}
  ]; // Whether decryption is needed
}
