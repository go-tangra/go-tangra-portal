// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             (unknown)
// source: admin/service/v1/i_mfa.proto

package adminpb

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	v1 "github.com/go-tangra/go-tangra-portal/api/gen/go/authentication/service/v1"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationMFAServiceConfirmEnrollMethod = "/admin.service.v1.MFAService/ConfirmEnrollMethod"
const OperationMFAServiceDisableMFA = "/admin.service.v1.MFAService/DisableMFA"
const OperationMFAServiceGenerateBackupCodes = "/admin.service.v1.MFAService/GenerateBackupCodes"
const OperationMFAServiceGetMFAStatus = "/admin.service.v1.MFAService/GetMFAStatus"
const OperationMFAServiceListBackupCodes = "/admin.service.v1.MFAService/ListBackupCodes"
const OperationMFAServiceListEnrolledMethods = "/admin.service.v1.MFAService/ListEnrolledMethods"
const OperationMFAServiceRevokeMFADevice = "/admin.service.v1.MFAService/RevokeMFADevice"
const OperationMFAServiceStartEnrollMethod = "/admin.service.v1.MFAService/StartEnrollMethod"
const OperationMFAServiceStartMFAChallenge = "/admin.service.v1.MFAService/StartMFAChallenge"
const OperationMFAServiceVerifyMFAChallenge = "/admin.service.v1.MFAService/VerifyMFAChallenge"

type MFAServiceHTTPServer interface {
	// ConfirmEnrollMethod Confirm MFA enrollment with verification code
	ConfirmEnrollMethod(context.Context, *v1.ConfirmEnrollMethodRequest) (*v1.ConfirmEnrollMethodResponse, error)
	// DisableMFA Disable MFA for current user
	DisableMFA(context.Context, *v1.DisableMFARequest) (*emptypb.Empty, error)
	// GenerateBackupCodes Generate new backup codes
	GenerateBackupCodes(context.Context, *v1.GenerateBackupCodesRequest) (*v1.GenerateBackupCodesResponse, error)
	// GetMFAStatus Get current user's MFA status
	GetMFAStatus(context.Context, *v1.GetMFAStatusRequest) (*v1.GetMFAStatusResponse, error)
	// ListBackupCodes List backup code metadata (remaining count)
	ListBackupCodes(context.Context, *v1.ListBackupCodesRequest) (*v1.ListBackupCodesResponse, error)
	// ListEnrolledMethods List enrolled MFA methods
	ListEnrolledMethods(context.Context, *v1.ListEnrolledMethodsRequest) (*v1.ListEnrolledMethodsResponse, error)
	// RevokeMFADevice Revoke a specific MFA device/credential
	RevokeMFADevice(context.Context, *v1.RevokeMFADeviceRequest) (*emptypb.Empty, error)
	// StartEnrollMethod Start enrolling an MFA method
	StartEnrollMethod(context.Context, *v1.StartEnrollMethodRequest) (*v1.StartEnrollMethodResponse, error)
	// StartMFAChallenge Start MFA challenge during login (after password verified, before MFA verified)
	StartMFAChallenge(context.Context, *v1.StartMFAChallengeRequest) (*v1.StartMFAChallengeResponse, error)
	// VerifyMFAChallenge Verify MFA challenge during login - returns JWT tokens on success
	VerifyMFAChallenge(context.Context, *v1.VerifyMFAChallengeRequest) (*v1.VerifyMFAChallengeResponse, error)
}

func RegisterMFAServiceHTTPServer(s *http.Server, srv MFAServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/admin/v1/mfa/challenge", _MFAService_StartMFAChallenge0_HTTP_Handler(srv))
	r.POST("/admin/v1/mfa/verify", _MFAService_VerifyMFAChallenge0_HTTP_Handler(srv))
	r.GET("/admin/v1/me/mfa/status", _MFAService_GetMFAStatus0_HTTP_Handler(srv))
	r.GET("/admin/v1/me/mfa/methods", _MFAService_ListEnrolledMethods0_HTTP_Handler(srv))
	r.POST("/admin/v1/me/mfa/enroll", _MFAService_StartEnrollMethod0_HTTP_Handler(srv))
	r.POST("/admin/v1/me/mfa/enroll/confirm", _MFAService_ConfirmEnrollMethod0_HTTP_Handler(srv))
	r.POST("/admin/v1/me/mfa/disable", _MFAService_DisableMFA0_HTTP_Handler(srv))
	r.POST("/admin/v1/me/mfa/backup-codes", _MFAService_GenerateBackupCodes0_HTTP_Handler(srv))
	r.GET("/admin/v1/me/mfa/backup-codes", _MFAService_ListBackupCodes0_HTTP_Handler(srv))
	r.DELETE("/admin/v1/me/mfa/devices/{credential_id}", _MFAService_RevokeMFADevice0_HTTP_Handler(srv))
}

func _MFAService_StartMFAChallenge0_HTTP_Handler(srv MFAServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.StartMFAChallengeRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMFAServiceStartMFAChallenge)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.StartMFAChallenge(ctx, req.(*v1.StartMFAChallengeRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.StartMFAChallengeResponse)
		return ctx.Result(200, reply)
	}
}

func _MFAService_VerifyMFAChallenge0_HTTP_Handler(srv MFAServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.VerifyMFAChallengeRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMFAServiceVerifyMFAChallenge)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.VerifyMFAChallenge(ctx, req.(*v1.VerifyMFAChallengeRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.VerifyMFAChallengeResponse)
		return ctx.Result(200, reply)
	}
}

func _MFAService_GetMFAStatus0_HTTP_Handler(srv MFAServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.GetMFAStatusRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMFAServiceGetMFAStatus)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetMFAStatus(ctx, req.(*v1.GetMFAStatusRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.GetMFAStatusResponse)
		return ctx.Result(200, reply)
	}
}

func _MFAService_ListEnrolledMethods0_HTTP_Handler(srv MFAServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.ListEnrolledMethodsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMFAServiceListEnrolledMethods)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListEnrolledMethods(ctx, req.(*v1.ListEnrolledMethodsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.ListEnrolledMethodsResponse)
		return ctx.Result(200, reply)
	}
}

func _MFAService_StartEnrollMethod0_HTTP_Handler(srv MFAServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.StartEnrollMethodRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMFAServiceStartEnrollMethod)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.StartEnrollMethod(ctx, req.(*v1.StartEnrollMethodRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.StartEnrollMethodResponse)
		return ctx.Result(200, reply)
	}
}

func _MFAService_ConfirmEnrollMethod0_HTTP_Handler(srv MFAServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.ConfirmEnrollMethodRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMFAServiceConfirmEnrollMethod)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ConfirmEnrollMethod(ctx, req.(*v1.ConfirmEnrollMethodRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.ConfirmEnrollMethodResponse)
		return ctx.Result(200, reply)
	}
}

func _MFAService_DisableMFA0_HTTP_Handler(srv MFAServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.DisableMFARequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMFAServiceDisableMFA)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DisableMFA(ctx, req.(*v1.DisableMFARequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _MFAService_GenerateBackupCodes0_HTTP_Handler(srv MFAServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.GenerateBackupCodesRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMFAServiceGenerateBackupCodes)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GenerateBackupCodes(ctx, req.(*v1.GenerateBackupCodesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.GenerateBackupCodesResponse)
		return ctx.Result(200, reply)
	}
}

func _MFAService_ListBackupCodes0_HTTP_Handler(srv MFAServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.ListBackupCodesRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMFAServiceListBackupCodes)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListBackupCodes(ctx, req.(*v1.ListBackupCodesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.ListBackupCodesResponse)
		return ctx.Result(200, reply)
	}
}

func _MFAService_RevokeMFADevice0_HTTP_Handler(srv MFAServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.RevokeMFADeviceRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMFAServiceRevokeMFADevice)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RevokeMFADevice(ctx, req.(*v1.RevokeMFADeviceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

type MFAServiceHTTPClient interface {
	// ConfirmEnrollMethod Confirm MFA enrollment with verification code
	ConfirmEnrollMethod(ctx context.Context, req *v1.ConfirmEnrollMethodRequest, opts ...http.CallOption) (rsp *v1.ConfirmEnrollMethodResponse, err error)
	// DisableMFA Disable MFA for current user
	DisableMFA(ctx context.Context, req *v1.DisableMFARequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	// GenerateBackupCodes Generate new backup codes
	GenerateBackupCodes(ctx context.Context, req *v1.GenerateBackupCodesRequest, opts ...http.CallOption) (rsp *v1.GenerateBackupCodesResponse, err error)
	// GetMFAStatus Get current user's MFA status
	GetMFAStatus(ctx context.Context, req *v1.GetMFAStatusRequest, opts ...http.CallOption) (rsp *v1.GetMFAStatusResponse, err error)
	// ListBackupCodes List backup code metadata (remaining count)
	ListBackupCodes(ctx context.Context, req *v1.ListBackupCodesRequest, opts ...http.CallOption) (rsp *v1.ListBackupCodesResponse, err error)
	// ListEnrolledMethods List enrolled MFA methods
	ListEnrolledMethods(ctx context.Context, req *v1.ListEnrolledMethodsRequest, opts ...http.CallOption) (rsp *v1.ListEnrolledMethodsResponse, err error)
	// RevokeMFADevice Revoke a specific MFA device/credential
	RevokeMFADevice(ctx context.Context, req *v1.RevokeMFADeviceRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	// StartEnrollMethod Start enrolling an MFA method
	StartEnrollMethod(ctx context.Context, req *v1.StartEnrollMethodRequest, opts ...http.CallOption) (rsp *v1.StartEnrollMethodResponse, err error)
	// StartMFAChallenge Start MFA challenge during login (after password verified, before MFA verified)
	StartMFAChallenge(ctx context.Context, req *v1.StartMFAChallengeRequest, opts ...http.CallOption) (rsp *v1.StartMFAChallengeResponse, err error)
	// VerifyMFAChallenge Verify MFA challenge during login - returns JWT tokens on success
	VerifyMFAChallenge(ctx context.Context, req *v1.VerifyMFAChallengeRequest, opts ...http.CallOption) (rsp *v1.VerifyMFAChallengeResponse, err error)
}

type MFAServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewMFAServiceHTTPClient(client *http.Client) MFAServiceHTTPClient {
	return &MFAServiceHTTPClientImpl{client}
}

// ConfirmEnrollMethod Confirm MFA enrollment with verification code
func (c *MFAServiceHTTPClientImpl) ConfirmEnrollMethod(ctx context.Context, in *v1.ConfirmEnrollMethodRequest, opts ...http.CallOption) (*v1.ConfirmEnrollMethodResponse, error) {
	var out v1.ConfirmEnrollMethodResponse
	pattern := "/admin/v1/me/mfa/enroll/confirm"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationMFAServiceConfirmEnrollMethod))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// DisableMFA Disable MFA for current user
func (c *MFAServiceHTTPClientImpl) DisableMFA(ctx context.Context, in *v1.DisableMFARequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/admin/v1/me/mfa/disable"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationMFAServiceDisableMFA))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GenerateBackupCodes Generate new backup codes
func (c *MFAServiceHTTPClientImpl) GenerateBackupCodes(ctx context.Context, in *v1.GenerateBackupCodesRequest, opts ...http.CallOption) (*v1.GenerateBackupCodesResponse, error) {
	var out v1.GenerateBackupCodesResponse
	pattern := "/admin/v1/me/mfa/backup-codes"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationMFAServiceGenerateBackupCodes))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetMFAStatus Get current user's MFA status
func (c *MFAServiceHTTPClientImpl) GetMFAStatus(ctx context.Context, in *v1.GetMFAStatusRequest, opts ...http.CallOption) (*v1.GetMFAStatusResponse, error) {
	var out v1.GetMFAStatusResponse
	pattern := "/admin/v1/me/mfa/status"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationMFAServiceGetMFAStatus))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListBackupCodes List backup code metadata (remaining count)
func (c *MFAServiceHTTPClientImpl) ListBackupCodes(ctx context.Context, in *v1.ListBackupCodesRequest, opts ...http.CallOption) (*v1.ListBackupCodesResponse, error) {
	var out v1.ListBackupCodesResponse
	pattern := "/admin/v1/me/mfa/backup-codes"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationMFAServiceListBackupCodes))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListEnrolledMethods List enrolled MFA methods
func (c *MFAServiceHTTPClientImpl) ListEnrolledMethods(ctx context.Context, in *v1.ListEnrolledMethodsRequest, opts ...http.CallOption) (*v1.ListEnrolledMethodsResponse, error) {
	var out v1.ListEnrolledMethodsResponse
	pattern := "/admin/v1/me/mfa/methods"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationMFAServiceListEnrolledMethods))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// RevokeMFADevice Revoke a specific MFA device/credential
func (c *MFAServiceHTTPClientImpl) RevokeMFADevice(ctx context.Context, in *v1.RevokeMFADeviceRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/admin/v1/me/mfa/devices/{credential_id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationMFAServiceRevokeMFADevice))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// StartEnrollMethod Start enrolling an MFA method
func (c *MFAServiceHTTPClientImpl) StartEnrollMethod(ctx context.Context, in *v1.StartEnrollMethodRequest, opts ...http.CallOption) (*v1.StartEnrollMethodResponse, error) {
	var out v1.StartEnrollMethodResponse
	pattern := "/admin/v1/me/mfa/enroll"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationMFAServiceStartEnrollMethod))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// StartMFAChallenge Start MFA challenge during login (after password verified, before MFA verified)
func (c *MFAServiceHTTPClientImpl) StartMFAChallenge(ctx context.Context, in *v1.StartMFAChallengeRequest, opts ...http.CallOption) (*v1.StartMFAChallengeResponse, error) {
	var out v1.StartMFAChallengeResponse
	pattern := "/admin/v1/mfa/challenge"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationMFAServiceStartMFAChallenge))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// VerifyMFAChallenge Verify MFA challenge during login - returns JWT tokens on success
func (c *MFAServiceHTTPClientImpl) VerifyMFAChallenge(ctx context.Context, in *v1.VerifyMFAChallengeRequest, opts ...http.CallOption) (*v1.VerifyMFAChallengeResponse, error) {
	var out v1.VerifyMFAChallengeResponse
	pattern := "/admin/v1/mfa/verify"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationMFAServiceVerifyMFAChallenge))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
