// Code generated by protoc-gen-redact. DO NOT EDIT.
// source: admin/service/v1/i_mfa.proto

package adminpb

import (
	context "context"
	authenticationpb "github.com/go-tangra/go-tangra-portal/api/gen/go/authentication/service/v1"
	redact "github.com/menta2k/protoc-gen-redact/v3/redact/v3"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ grpc.Server
	_ context.Context
	_ redact.Redactor
	_ codes.Code
	_ status.Status
	_ emptypb.Empty
	_ authenticationpb.GetMFAStatusRequest
)

// RegisterRedactedMFAServiceServer wraps the MFAServiceServer with the redacted server and registers the service in GRPC
func RegisterRedactedMFAServiceServer(s grpc.ServiceRegistrar, srv MFAServiceServer, bypass redact.Bypass) {
	RegisterMFAServiceServer(s, RedactedMFAServiceServer(srv, bypass))
}

func RedactedMFAServiceServer(srv MFAServiceServer, bypass redact.Bypass) MFAServiceServer {
	if bypass == nil {
		bypass = redact.Falsy
	}
	return &redactedMFAServiceServer{srv: srv, bypass: bypass}
}

type redactedMFAServiceServer struct {
	UnsafeMFAServiceServer
	srv    MFAServiceServer
	bypass redact.Bypass
}

// StartMFAChallenge is the redacted wrapper for the actual MFAServiceServer.StartMFAChallenge method
// Unary RPC
func (s *redactedMFAServiceServer) StartMFAChallenge(ctx context.Context, in *authenticationpb.StartMFAChallengeRequest) (*authenticationpb.StartMFAChallengeResponse, error) {
	res, err := s.srv.StartMFAChallenge(ctx, in)
	if !s.bypass.CheckInternal(ctx) {
		// Apply redaction to the response
		redact.Apply(res)
	}
	return res, err
}

// VerifyMFAChallenge is the redacted wrapper for the actual MFAServiceServer.VerifyMFAChallenge method
// Unary RPC
func (s *redactedMFAServiceServer) VerifyMFAChallenge(ctx context.Context, in *authenticationpb.VerifyMFAChallengeRequest) (*authenticationpb.VerifyMFAChallengeResponse, error) {
	res, err := s.srv.VerifyMFAChallenge(ctx, in)
	if !s.bypass.CheckInternal(ctx) {
		// Apply redaction to the response
		redact.Apply(res)
	}
	return res, err
}

// GetMFAStatus is the redacted wrapper for the actual MFAServiceServer.GetMFAStatus method
// Unary RPC
func (s *redactedMFAServiceServer) GetMFAStatus(ctx context.Context, in *authenticationpb.GetMFAStatusRequest) (*authenticationpb.GetMFAStatusResponse, error) {
	res, err := s.srv.GetMFAStatus(ctx, in)
	if !s.bypass.CheckInternal(ctx) {
		// Apply redaction to the response
		redact.Apply(res)
	}
	return res, err
}

// ListEnrolledMethods is the redacted wrapper for the actual MFAServiceServer.ListEnrolledMethods method
// Unary RPC
func (s *redactedMFAServiceServer) ListEnrolledMethods(ctx context.Context, in *authenticationpb.ListEnrolledMethodsRequest) (*authenticationpb.ListEnrolledMethodsResponse, error) {
	res, err := s.srv.ListEnrolledMethods(ctx, in)
	if !s.bypass.CheckInternal(ctx) {
		// Apply redaction to the response
		redact.Apply(res)
	}
	return res, err
}

// StartEnrollMethod is the redacted wrapper for the actual MFAServiceServer.StartEnrollMethod method
// Unary RPC
func (s *redactedMFAServiceServer) StartEnrollMethod(ctx context.Context, in *authenticationpb.StartEnrollMethodRequest) (*authenticationpb.StartEnrollMethodResponse, error) {
	res, err := s.srv.StartEnrollMethod(ctx, in)
	if !s.bypass.CheckInternal(ctx) {
		// Apply redaction to the response
		redact.Apply(res)
	}
	return res, err
}

// ConfirmEnrollMethod is the redacted wrapper for the actual MFAServiceServer.ConfirmEnrollMethod method
// Unary RPC
func (s *redactedMFAServiceServer) ConfirmEnrollMethod(ctx context.Context, in *authenticationpb.ConfirmEnrollMethodRequest) (*authenticationpb.ConfirmEnrollMethodResponse, error) {
	res, err := s.srv.ConfirmEnrollMethod(ctx, in)
	if !s.bypass.CheckInternal(ctx) {
		// Apply redaction to the response
		redact.Apply(res)
	}
	return res, err
}

// DisableMFA is the redacted wrapper for the actual MFAServiceServer.DisableMFA method
// Unary RPC
func (s *redactedMFAServiceServer) DisableMFA(ctx context.Context, in *authenticationpb.DisableMFARequest) (*emptypb.Empty, error) {
	res, err := s.srv.DisableMFA(ctx, in)
	if !s.bypass.CheckInternal(ctx) {
		// Apply redaction to the response
		redact.Apply(res)
	}
	return res, err
}

// GenerateBackupCodes is the redacted wrapper for the actual MFAServiceServer.GenerateBackupCodes method
// Unary RPC
func (s *redactedMFAServiceServer) GenerateBackupCodes(ctx context.Context, in *authenticationpb.GenerateBackupCodesRequest) (*authenticationpb.GenerateBackupCodesResponse, error) {
	res, err := s.srv.GenerateBackupCodes(ctx, in)
	if !s.bypass.CheckInternal(ctx) {
		// Apply redaction to the response
		redact.Apply(res)
	}
	return res, err
}

// ListBackupCodes is the redacted wrapper for the actual MFAServiceServer.ListBackupCodes method
// Unary RPC
func (s *redactedMFAServiceServer) ListBackupCodes(ctx context.Context, in *authenticationpb.ListBackupCodesRequest) (*authenticationpb.ListBackupCodesResponse, error) {
	res, err := s.srv.ListBackupCodes(ctx, in)
	if !s.bypass.CheckInternal(ctx) {
		// Apply redaction to the response
		redact.Apply(res)
	}
	return res, err
}

// RevokeMFADevice is the redacted wrapper for the actual MFAServiceServer.RevokeMFADevice method
// Unary RPC
func (s *redactedMFAServiceServer) RevokeMFADevice(ctx context.Context, in *authenticationpb.RevokeMFADeviceRequest) (*emptypb.Empty, error) {
	res, err := s.srv.RevokeMFADevice(ctx, in)
	if !s.bypass.CheckInternal(ctx) {
		// Apply redaction to the response
		redact.Apply(res)
	}
	return res, err
}
