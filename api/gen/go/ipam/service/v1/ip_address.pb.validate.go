// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: ipam/service/v1/ip_address.proto

package ipampb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on IpAddress with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IpAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IpAddress with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IpAddressMultiError, or nil
// if none found.
func (m *IpAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *IpAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.Address != nil {
		// no validation rules for Address
	}

	if m.SubnetId != nil {
		// no validation rules for SubnetId
	}

	if m.Hostname != nil {
		// no validation rules for Hostname
	}

	if m.MacAddress != nil {
		// no validation rules for MacAddress
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.DeviceId != nil {
		// no validation rules for DeviceId
	}

	if m.InterfaceName != nil {
		// no validation rules for InterfaceName
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.AddressType != nil {
		// no validation rules for AddressType
	}

	if m.IsPrimary != nil {
		// no validation rules for IsPrimary
	}

	if m.PtrRecord != nil {
		// no validation rules for PtrRecord
	}

	if m.DnsName != nil {
		// no validation rules for DnsName
	}

	if m.Owner != nil {
		// no validation rules for Owner
	}

	if m.LastSeen != nil {

		if all {
			switch v := interface{}(m.GetLastSeen()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IpAddressValidationError{
						field:  "LastSeen",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IpAddressValidationError{
						field:  "LastSeen",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLastSeen()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IpAddressValidationError{
					field:  "LastSeen",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.LeaseExpiry != nil {

		if all {
			switch v := interface{}(m.GetLeaseExpiry()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IpAddressValidationError{
						field:  "LeaseExpiry",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IpAddressValidationError{
						field:  "LeaseExpiry",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLeaseExpiry()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IpAddressValidationError{
					field:  "LeaseExpiry",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.HasReverseDns != nil {
		// no validation rules for HasReverseDns
	}

	if m.Tags != nil {
		// no validation rules for Tags
	}

	if m.Metadata != nil {
		// no validation rules for Metadata
	}

	if m.Note != nil {
		// no validation rules for Note
	}

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IpAddressValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IpAddressValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IpAddressValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IpAddressValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IpAddressValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IpAddressValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CreatedBy != nil {
		// no validation rules for CreatedBy
	}

	if m.UpdatedBy != nil {
		// no validation rules for UpdatedBy
	}

	if len(errors) > 0 {
		return IpAddressMultiError(errors)
	}

	return nil
}

// IpAddressMultiError is an error wrapping multiple validation errors returned
// by IpAddress.ValidateAll() if the designated constraints aren't met.
type IpAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IpAddressMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IpAddressMultiError) AllErrors() []error { return m }

// IpAddressValidationError is the validation error returned by
// IpAddress.Validate if the designated constraints aren't met.
type IpAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IpAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IpAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IpAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IpAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IpAddressValidationError) ErrorName() string { return "IpAddressValidationError" }

// Error satisfies the builtin error interface
func (e IpAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIpAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IpAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IpAddressValidationError{}

// Validate checks the field values on CreateIpAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateIpAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateIpAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateIpAddressRequestMultiError, or nil if none found.
func (m *CreateIpAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateIpAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.Address != nil {
		// no validation rules for Address
	}

	if m.SubnetId != nil {
		// no validation rules for SubnetId
	}

	if m.Hostname != nil {
		// no validation rules for Hostname
	}

	if m.MacAddress != nil {
		// no validation rules for MacAddress
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.DeviceId != nil {
		// no validation rules for DeviceId
	}

	if m.InterfaceName != nil {
		// no validation rules for InterfaceName
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.AddressType != nil {
		// no validation rules for AddressType
	}

	if m.IsPrimary != nil {
		// no validation rules for IsPrimary
	}

	if m.PtrRecord != nil {
		// no validation rules for PtrRecord
	}

	if m.DnsName != nil {
		// no validation rules for DnsName
	}

	if m.Owner != nil {
		// no validation rules for Owner
	}

	if m.Tags != nil {
		// no validation rules for Tags
	}

	if m.Metadata != nil {
		// no validation rules for Metadata
	}

	if m.Note != nil {
		// no validation rules for Note
	}

	if len(errors) > 0 {
		return CreateIpAddressRequestMultiError(errors)
	}

	return nil
}

// CreateIpAddressRequestMultiError is an error wrapping multiple validation
// errors returned by CreateIpAddressRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateIpAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateIpAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateIpAddressRequestMultiError) AllErrors() []error { return m }

// CreateIpAddressRequestValidationError is the validation error returned by
// CreateIpAddressRequest.Validate if the designated constraints aren't met.
type CreateIpAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateIpAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateIpAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateIpAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateIpAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateIpAddressRequestValidationError) ErrorName() string {
	return "CreateIpAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateIpAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateIpAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateIpAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateIpAddressRequestValidationError{}

// Validate checks the field values on CreateIpAddressResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateIpAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateIpAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateIpAddressResponseMultiError, or nil if none found.
func (m *CreateIpAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateIpAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIpAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateIpAddressResponseValidationError{
					field:  "IpAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateIpAddressResponseValidationError{
					field:  "IpAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIpAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateIpAddressResponseValidationError{
				field:  "IpAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateIpAddressResponseMultiError(errors)
	}

	return nil
}

// CreateIpAddressResponseMultiError is an error wrapping multiple validation
// errors returned by CreateIpAddressResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateIpAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateIpAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateIpAddressResponseMultiError) AllErrors() []error { return m }

// CreateIpAddressResponseValidationError is the validation error returned by
// CreateIpAddressResponse.Validate if the designated constraints aren't met.
type CreateIpAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateIpAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateIpAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateIpAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateIpAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateIpAddressResponseValidationError) ErrorName() string {
	return "CreateIpAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateIpAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateIpAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateIpAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateIpAddressResponseValidationError{}

// Validate checks the field values on GetIpAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIpAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIpAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIpAddressRequestMultiError, or nil if none found.
func (m *GetIpAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIpAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetIpAddressRequestMultiError(errors)
	}

	return nil
}

// GetIpAddressRequestMultiError is an error wrapping multiple validation
// errors returned by GetIpAddressRequest.ValidateAll() if the designated
// constraints aren't met.
type GetIpAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIpAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIpAddressRequestMultiError) AllErrors() []error { return m }

// GetIpAddressRequestValidationError is the validation error returned by
// GetIpAddressRequest.Validate if the designated constraints aren't met.
type GetIpAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIpAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIpAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIpAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIpAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIpAddressRequestValidationError) ErrorName() string {
	return "GetIpAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetIpAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIpAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIpAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIpAddressRequestValidationError{}

// Validate checks the field values on GetIpAddressResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIpAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIpAddressResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIpAddressResponseMultiError, or nil if none found.
func (m *GetIpAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIpAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIpAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIpAddressResponseValidationError{
					field:  "IpAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIpAddressResponseValidationError{
					field:  "IpAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIpAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIpAddressResponseValidationError{
				field:  "IpAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetIpAddressResponseMultiError(errors)
	}

	return nil
}

// GetIpAddressResponseMultiError is an error wrapping multiple validation
// errors returned by GetIpAddressResponse.ValidateAll() if the designated
// constraints aren't met.
type GetIpAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIpAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIpAddressResponseMultiError) AllErrors() []error { return m }

// GetIpAddressResponseValidationError is the validation error returned by
// GetIpAddressResponse.Validate if the designated constraints aren't met.
type GetIpAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIpAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIpAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIpAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIpAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIpAddressResponseValidationError) ErrorName() string {
	return "GetIpAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetIpAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIpAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIpAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIpAddressResponseValidationError{}

// Validate checks the field values on ListIpAddressesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListIpAddressesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListIpAddressesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListIpAddressesRequestMultiError, or nil if none found.
func (m *ListIpAddressesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListIpAddressesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.NoPaging != nil {
		// no validation rules for NoPaging
	}

	if m.Query != nil {
		// no validation rules for Query
	}

	if m.FieldMask != nil {
		// no validation rules for FieldMask
	}

	if m.SubnetId != nil {
		// no validation rules for SubnetId
	}

	if m.DeviceId != nil {
		// no validation rules for DeviceId
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.AddressType != nil {
		// no validation rules for AddressType
	}

	if m.AddressPrefix != nil {
		// no validation rules for AddressPrefix
	}

	if m.HostnamePattern != nil {
		// no validation rules for HostnamePattern
	}

	if len(errors) > 0 {
		return ListIpAddressesRequestMultiError(errors)
	}

	return nil
}

// ListIpAddressesRequestMultiError is an error wrapping multiple validation
// errors returned by ListIpAddressesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListIpAddressesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListIpAddressesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListIpAddressesRequestMultiError) AllErrors() []error { return m }

// ListIpAddressesRequestValidationError is the validation error returned by
// ListIpAddressesRequest.Validate if the designated constraints aren't met.
type ListIpAddressesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListIpAddressesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListIpAddressesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListIpAddressesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListIpAddressesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListIpAddressesRequestValidationError) ErrorName() string {
	return "ListIpAddressesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListIpAddressesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListIpAddressesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListIpAddressesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListIpAddressesRequestValidationError{}

// Validate checks the field values on ListIpAddressesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListIpAddressesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListIpAddressesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListIpAddressesResponseMultiError, or nil if none found.
func (m *ListIpAddressesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListIpAddressesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListIpAddressesResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListIpAddressesResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListIpAddressesResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListIpAddressesResponseMultiError(errors)
	}

	return nil
}

// ListIpAddressesResponseMultiError is an error wrapping multiple validation
// errors returned by ListIpAddressesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListIpAddressesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListIpAddressesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListIpAddressesResponseMultiError) AllErrors() []error { return m }

// ListIpAddressesResponseValidationError is the validation error returned by
// ListIpAddressesResponse.Validate if the designated constraints aren't met.
type ListIpAddressesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListIpAddressesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListIpAddressesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListIpAddressesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListIpAddressesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListIpAddressesResponseValidationError) ErrorName() string {
	return "ListIpAddressesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListIpAddressesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListIpAddressesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListIpAddressesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListIpAddressesResponseValidationError{}

// Validate checks the field values on UpdateIpAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateIpAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIpAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateIpAddressRequestMultiError, or nil if none found.
func (m *UpdateIpAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIpAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetUpdateMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateIpAddressRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateIpAddressRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateIpAddressRequestValidationError{
				field:  "UpdateMask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Data != nil {

		if all {
			switch v := interface{}(m.GetData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateIpAddressRequestValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateIpAddressRequestValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateIpAddressRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateIpAddressRequestMultiError(errors)
	}

	return nil
}

// UpdateIpAddressRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateIpAddressRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateIpAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIpAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIpAddressRequestMultiError) AllErrors() []error { return m }

// UpdateIpAddressRequestValidationError is the validation error returned by
// UpdateIpAddressRequest.Validate if the designated constraints aren't met.
type UpdateIpAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIpAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIpAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIpAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIpAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIpAddressRequestValidationError) ErrorName() string {
	return "UpdateIpAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateIpAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIpAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIpAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIpAddressRequestValidationError{}

// Validate checks the field values on UpdateIpAddressResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateIpAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIpAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateIpAddressResponseMultiError, or nil if none found.
func (m *UpdateIpAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIpAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIpAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateIpAddressResponseValidationError{
					field:  "IpAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateIpAddressResponseValidationError{
					field:  "IpAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIpAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateIpAddressResponseValidationError{
				field:  "IpAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateIpAddressResponseMultiError(errors)
	}

	return nil
}

// UpdateIpAddressResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateIpAddressResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateIpAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIpAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIpAddressResponseMultiError) AllErrors() []error { return m }

// UpdateIpAddressResponseValidationError is the validation error returned by
// UpdateIpAddressResponse.Validate if the designated constraints aren't met.
type UpdateIpAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIpAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIpAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIpAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIpAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIpAddressResponseValidationError) ErrorName() string {
	return "UpdateIpAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateIpAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIpAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIpAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIpAddressResponseValidationError{}

// Validate checks the field values on DeleteIpAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteIpAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteIpAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteIpAddressRequestMultiError, or nil if none found.
func (m *DeleteIpAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteIpAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteIpAddressRequestMultiError(errors)
	}

	return nil
}

// DeleteIpAddressRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteIpAddressRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteIpAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteIpAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteIpAddressRequestMultiError) AllErrors() []error { return m }

// DeleteIpAddressRequestValidationError is the validation error returned by
// DeleteIpAddressRequest.Validate if the designated constraints aren't met.
type DeleteIpAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteIpAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteIpAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteIpAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteIpAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteIpAddressRequestValidationError) ErrorName() string {
	return "DeleteIpAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteIpAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteIpAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteIpAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteIpAddressRequestValidationError{}

// Validate checks the field values on AllocateNextAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AllocateNextAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AllocateNextAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AllocateNextAddressRequestMultiError, or nil if none found.
func (m *AllocateNextAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AllocateNextAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubnetId

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.Hostname != nil {
		// no validation rules for Hostname
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.DeviceId != nil {
		// no validation rules for DeviceId
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.Owner != nil {
		// no validation rules for Owner
	}

	if m.StartFrom != nil {
		// no validation rules for StartFrom
	}

	if len(errors) > 0 {
		return AllocateNextAddressRequestMultiError(errors)
	}

	return nil
}

// AllocateNextAddressRequestMultiError is an error wrapping multiple
// validation errors returned by AllocateNextAddressRequest.ValidateAll() if
// the designated constraints aren't met.
type AllocateNextAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AllocateNextAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AllocateNextAddressRequestMultiError) AllErrors() []error { return m }

// AllocateNextAddressRequestValidationError is the validation error returned
// by AllocateNextAddressRequest.Validate if the designated constraints aren't met.
type AllocateNextAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AllocateNextAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AllocateNextAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AllocateNextAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AllocateNextAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AllocateNextAddressRequestValidationError) ErrorName() string {
	return "AllocateNextAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AllocateNextAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAllocateNextAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AllocateNextAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AllocateNextAddressRequestValidationError{}

// Validate checks the field values on AllocateNextAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AllocateNextAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AllocateNextAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AllocateNextAddressResponseMultiError, or nil if none found.
func (m *AllocateNextAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AllocateNextAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIpAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AllocateNextAddressResponseValidationError{
					field:  "IpAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AllocateNextAddressResponseValidationError{
					field:  "IpAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIpAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AllocateNextAddressResponseValidationError{
				field:  "IpAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AllocateNextAddressResponseMultiError(errors)
	}

	return nil
}

// AllocateNextAddressResponseMultiError is an error wrapping multiple
// validation errors returned by AllocateNextAddressResponse.ValidateAll() if
// the designated constraints aren't met.
type AllocateNextAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AllocateNextAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AllocateNextAddressResponseMultiError) AllErrors() []error { return m }

// AllocateNextAddressResponseValidationError is the validation error returned
// by AllocateNextAddressResponse.Validate if the designated constraints
// aren't met.
type AllocateNextAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AllocateNextAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AllocateNextAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AllocateNextAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AllocateNextAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AllocateNextAddressResponseValidationError) ErrorName() string {
	return "AllocateNextAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AllocateNextAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAllocateNextAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AllocateNextAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AllocateNextAddressResponseValidationError{}

// Validate checks the field values on BulkAllocateAddressesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkAllocateAddressesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkAllocateAddressesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BulkAllocateAddressesRequestMultiError, or nil if none found.
func (m *BulkAllocateAddressesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkAllocateAddressesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubnetId

	// no validation rules for Count

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.HostnamePrefix != nil {
		// no validation rules for HostnamePrefix
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if len(errors) > 0 {
		return BulkAllocateAddressesRequestMultiError(errors)
	}

	return nil
}

// BulkAllocateAddressesRequestMultiError is an error wrapping multiple
// validation errors returned by BulkAllocateAddressesRequest.ValidateAll() if
// the designated constraints aren't met.
type BulkAllocateAddressesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkAllocateAddressesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkAllocateAddressesRequestMultiError) AllErrors() []error { return m }

// BulkAllocateAddressesRequestValidationError is the validation error returned
// by BulkAllocateAddressesRequest.Validate if the designated constraints
// aren't met.
type BulkAllocateAddressesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkAllocateAddressesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkAllocateAddressesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkAllocateAddressesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkAllocateAddressesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkAllocateAddressesRequestValidationError) ErrorName() string {
	return "BulkAllocateAddressesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BulkAllocateAddressesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkAllocateAddressesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkAllocateAddressesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkAllocateAddressesRequestValidationError{}

// Validate checks the field values on BulkAllocateAddressesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkAllocateAddressesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkAllocateAddressesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BulkAllocateAddressesResponseMultiError, or nil if none found.
func (m *BulkAllocateAddressesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkAllocateAddressesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetIpAddresses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BulkAllocateAddressesResponseValidationError{
						field:  fmt.Sprintf("IpAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BulkAllocateAddressesResponseValidationError{
						field:  fmt.Sprintf("IpAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BulkAllocateAddressesResponseValidationError{
					field:  fmt.Sprintf("IpAddresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BulkAllocateAddressesResponseMultiError(errors)
	}

	return nil
}

// BulkAllocateAddressesResponseMultiError is an error wrapping multiple
// validation errors returned by BulkAllocateAddressesResponse.ValidateAll()
// if the designated constraints aren't met.
type BulkAllocateAddressesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkAllocateAddressesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkAllocateAddressesResponseMultiError) AllErrors() []error { return m }

// BulkAllocateAddressesResponseValidationError is the validation error
// returned by BulkAllocateAddressesResponse.Validate if the designated
// constraints aren't met.
type BulkAllocateAddressesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkAllocateAddressesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkAllocateAddressesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkAllocateAddressesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkAllocateAddressesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkAllocateAddressesResponseValidationError) ErrorName() string {
	return "BulkAllocateAddressesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BulkAllocateAddressesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkAllocateAddressesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkAllocateAddressesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkAllocateAddressesResponseValidationError{}

// Validate checks the field values on FindAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FindAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FindAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FindAddressRequestMultiError, or nil if none found.
func (m *FindAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FindAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if len(errors) > 0 {
		return FindAddressRequestMultiError(errors)
	}

	return nil
}

// FindAddressRequestMultiError is an error wrapping multiple validation errors
// returned by FindAddressRequest.ValidateAll() if the designated constraints
// aren't met.
type FindAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FindAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FindAddressRequestMultiError) AllErrors() []error { return m }

// FindAddressRequestValidationError is the validation error returned by
// FindAddressRequest.Validate if the designated constraints aren't met.
type FindAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FindAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FindAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FindAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FindAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FindAddressRequestValidationError) ErrorName() string {
	return "FindAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FindAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFindAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FindAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FindAddressRequestValidationError{}

// Validate checks the field values on FindAddressResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FindAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FindAddressResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FindAddressResponseMultiError, or nil if none found.
func (m *FindAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FindAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIpAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FindAddressResponseValidationError{
					field:  "IpAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FindAddressResponseValidationError{
					field:  "IpAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIpAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FindAddressResponseValidationError{
				field:  "IpAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FindAddressResponseMultiError(errors)
	}

	return nil
}

// FindAddressResponseMultiError is an error wrapping multiple validation
// errors returned by FindAddressResponse.ValidateAll() if the designated
// constraints aren't met.
type FindAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FindAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FindAddressResponseMultiError) AllErrors() []error { return m }

// FindAddressResponseValidationError is the validation error returned by
// FindAddressResponse.Validate if the designated constraints aren't met.
type FindAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FindAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FindAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FindAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FindAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FindAddressResponseValidationError) ErrorName() string {
	return "FindAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FindAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFindAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FindAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FindAddressResponseValidationError{}

// Validate checks the field values on PingAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PingAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PingAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PingAddressRequestMultiError, or nil if none found.
func (m *PingAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PingAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return PingAddressRequestMultiError(errors)
	}

	return nil
}

// PingAddressRequestMultiError is an error wrapping multiple validation errors
// returned by PingAddressRequest.ValidateAll() if the designated constraints
// aren't met.
type PingAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PingAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PingAddressRequestMultiError) AllErrors() []error { return m }

// PingAddressRequestValidationError is the validation error returned by
// PingAddressRequest.Validate if the designated constraints aren't met.
type PingAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PingAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PingAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PingAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PingAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PingAddressRequestValidationError) ErrorName() string {
	return "PingAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PingAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPingAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PingAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PingAddressRequestValidationError{}

// Validate checks the field values on PingAddressResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PingAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PingAddressResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PingAddressResponseMultiError, or nil if none found.
func (m *PingAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PingAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Reachable

	if m.LatencyMs != nil {
		// no validation rules for LatencyMs
	}

	if m.CheckedAt != nil {

		if all {
			switch v := interface{}(m.GetCheckedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PingAddressResponseValidationError{
						field:  "CheckedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PingAddressResponseValidationError{
						field:  "CheckedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCheckedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PingAddressResponseValidationError{
					field:  "CheckedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PingAddressResponseMultiError(errors)
	}

	return nil
}

// PingAddressResponseMultiError is an error wrapping multiple validation
// errors returned by PingAddressResponse.ValidateAll() if the designated
// constraints aren't met.
type PingAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PingAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PingAddressResponseMultiError) AllErrors() []error { return m }

// PingAddressResponseValidationError is the validation error returned by
// PingAddressResponse.Validate if the designated constraints aren't met.
type PingAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PingAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PingAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PingAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PingAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PingAddressResponseValidationError) ErrorName() string {
	return "PingAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PingAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPingAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PingAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PingAddressResponseValidationError{}
