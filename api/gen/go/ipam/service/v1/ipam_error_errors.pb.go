// Code generated by protoc-gen-go-errors. DO NOT EDIT.

package ipampb

import (
	fmt "fmt"
	errors "github.com/go-kratos/kratos/v2/errors"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
const _ = errors.SupportPackageIsVersion1

// 400
func IsBadRequest(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_BAD_REQUEST.String() && e.Code == 400
}

// 400
func ErrorBadRequest(format string, args ...interface{}) *errors.Error {
	return errors.New(400, IpamErrorReason_BAD_REQUEST.String(), fmt.Sprintf(format, args...))
}

// Invalid CIDR format
func IsSubnetCidrInvalid(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_SUBNET_CIDR_INVALID.String() && e.Code == 400
}

// Invalid CIDR format
func ErrorSubnetCidrInvalid(format string, args ...interface{}) *errors.Error {
	return errors.New(400, IpamErrorReason_SUBNET_CIDR_INVALID.String(), fmt.Sprintf(format, args...))
}

// Invalid IP address
func IsAddressInvalid(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_ADDRESS_INVALID.String() && e.Code == 400
}

// Invalid IP address
func ErrorAddressInvalid(format string, args ...interface{}) *errors.Error {
	return errors.New(400, IpamErrorReason_ADDRESS_INVALID.String(), fmt.Sprintf(format, args...))
}

// IP address not in subnet range
func IsAddressNotInSubnet(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_ADDRESS_NOT_IN_SUBNET.String() && e.Code == 400
}

// IP address not in subnet range
func ErrorAddressNotInSubnet(format string, args ...interface{}) *errors.Error {
	return errors.New(400, IpamErrorReason_ADDRESS_NOT_IN_SUBNET.String(), fmt.Sprintf(format, args...))
}

// Invalid VLAN ID (must be 1-4094)
func IsVlanIdInvalid(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_VLAN_ID_INVALID.String() && e.Code == 400
}

// Invalid VLAN ID (must be 1-4094)
func ErrorVlanIdInvalid(format string, args ...interface{}) *errors.Error {
	return errors.New(400, IpamErrorReason_VLAN_ID_INVALID.String(), fmt.Sprintf(format, args...))
}

// Validation failed
func IsValidationFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_VALIDATION_FAILED.String() && e.Code == 400
}

// Validation failed
func ErrorValidationFailed(format string, args ...interface{}) *errors.Error {
	return errors.New(400, IpamErrorReason_VALIDATION_FAILED.String(), fmt.Sprintf(format, args...))
}

// 404
func IsNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_NOT_FOUND.String() && e.Code == 404
}

// 404
func ErrorNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, IpamErrorReason_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

// Subnet not found
func IsSubnetNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_SUBNET_NOT_FOUND.String() && e.Code == 404
}

// Subnet not found
func ErrorSubnetNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, IpamErrorReason_SUBNET_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

// IP address not found
func IsAddressNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_ADDRESS_NOT_FOUND.String() && e.Code == 404
}

// IP address not found
func ErrorAddressNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, IpamErrorReason_ADDRESS_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

// VLAN not found
func IsVlanNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_VLAN_NOT_FOUND.String() && e.Code == 404
}

// VLAN not found
func ErrorVlanNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, IpamErrorReason_VLAN_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

// Device not found
func IsDeviceNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_DEVICE_NOT_FOUND.String() && e.Code == 404
}

// Device not found
func ErrorDeviceNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, IpamErrorReason_DEVICE_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

// Location not found
func IsLocationNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_LOCATION_NOT_FOUND.String() && e.Code == 404
}

// Location not found
func ErrorLocationNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, IpamErrorReason_LOCATION_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

// Scan job not found
func IsScanJobNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_SCAN_JOB_NOT_FOUND.String() && e.Code == 404
}

// Scan job not found
func ErrorScanJobNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, IpamErrorReason_SCAN_JOB_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

// IP group not found
func IsIpGroupNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_IP_GROUP_NOT_FOUND.String() && e.Code == 404
}

// IP group not found
func ErrorIpGroupNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, IpamErrorReason_IP_GROUP_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

// IP group member not found
func IsIpGroupMemberNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_IP_GROUP_MEMBER_NOT_FOUND.String() && e.Code == 404
}

// IP group member not found
func ErrorIpGroupMemberNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, IpamErrorReason_IP_GROUP_MEMBER_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

// Host group not found
func IsHostGroupNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_HOST_GROUP_NOT_FOUND.String() && e.Code == 404
}

// Host group not found
func ErrorHostGroupNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, IpamErrorReason_HOST_GROUP_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

// Host group member not found
func IsHostGroupMemberNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_HOST_GROUP_MEMBER_NOT_FOUND.String() && e.Code == 404
}

// Host group member not found
func ErrorHostGroupMemberNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, IpamErrorReason_HOST_GROUP_MEMBER_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

// 409
func IsConflict(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_CONFLICT.String() && e.Code == 409
}

// 409
func ErrorConflict(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_CONFLICT.String(), fmt.Sprintf(format, args...))
}

// Subnet already exists
func IsSubnetAlreadyExists(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_SUBNET_ALREADY_EXISTS.String() && e.Code == 409
}

// Subnet already exists
func ErrorSubnetAlreadyExists(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_SUBNET_ALREADY_EXISTS.String(), fmt.Sprintf(format, args...))
}

// Subnet CIDR overlaps with existing subnet
func IsSubnetCidrOverlap(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_SUBNET_CIDR_OVERLAP.String() && e.Code == 409
}

// Subnet CIDR overlaps with existing subnet
func ErrorSubnetCidrOverlap(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_SUBNET_CIDR_OVERLAP.String(), fmt.Sprintf(format, args...))
}

// Subnet has allocated addresses
func IsSubnetHasAddresses(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_SUBNET_HAS_ADDRESSES.String() && e.Code == 409
}

// Subnet has allocated addresses
func ErrorSubnetHasAddresses(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_SUBNET_HAS_ADDRESSES.String(), fmt.Sprintf(format, args...))
}

// IP address already exists
func IsAddressAlreadyExists(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_ADDRESS_ALREADY_EXISTS.String() && e.Code == 409
}

// IP address already exists
func ErrorAddressAlreadyExists(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_ADDRESS_ALREADY_EXISTS.String(), fmt.Sprintf(format, args...))
}

// IP address already allocated
func IsAddressAlreadyAllocated(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_ADDRESS_ALREADY_ALLOCATED.String() && e.Code == 409
}

// IP address already allocated
func ErrorAddressAlreadyAllocated(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_ADDRESS_ALREADY_ALLOCATED.String(), fmt.Sprintf(format, args...))
}

// VLAN already exists
func IsVlanAlreadyExists(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_VLAN_ALREADY_EXISTS.String() && e.Code == 409
}

// VLAN already exists
func ErrorVlanAlreadyExists(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_VLAN_ALREADY_EXISTS.String(), fmt.Sprintf(format, args...))
}

// VLAN has associated subnets
func IsVlanHasSubnets(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_VLAN_HAS_SUBNETS.String() && e.Code == 409
}

// VLAN has associated subnets
func ErrorVlanHasSubnets(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_VLAN_HAS_SUBNETS.String(), fmt.Sprintf(format, args...))
}

// Device already exists
func IsDeviceAlreadyExists(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_DEVICE_ALREADY_EXISTS.String() && e.Code == 409
}

// Device already exists
func ErrorDeviceAlreadyExists(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_DEVICE_ALREADY_EXISTS.String(), fmt.Sprintf(format, args...))
}

// Device has allocated addresses
func IsDeviceHasAddresses(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_DEVICE_HAS_ADDRESSES.String() && e.Code == 409
}

// Device has allocated addresses
func ErrorDeviceHasAddresses(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_DEVICE_HAS_ADDRESSES.String(), fmt.Sprintf(format, args...))
}

// Location already exists
func IsLocationAlreadyExists(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_LOCATION_ALREADY_EXISTS.String() && e.Code == 409
}

// Location already exists
func ErrorLocationAlreadyExists(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_LOCATION_ALREADY_EXISTS.String(), fmt.Sprintf(format, args...))
}

// Location has child locations or subnets
func IsLocationHasChildren(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_LOCATION_HAS_CHILDREN.String() && e.Code == 409
}

// Location has child locations or subnets
func ErrorLocationHasChildren(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_LOCATION_HAS_CHILDREN.String(), fmt.Sprintf(format, args...))
}

// Scan already in progress for subnet
func IsScanAlreadyInProgress(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_SCAN_ALREADY_IN_PROGRESS.String() && e.Code == 409
}

// Scan already in progress for subnet
func ErrorScanAlreadyInProgress(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_SCAN_ALREADY_IN_PROGRESS.String(), fmt.Sprintf(format, args...))
}

// Subnet too large for scanning (max 1024 addresses)
func IsSubnetTooLarge(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_SUBNET_TOO_LARGE.String() && e.Code == 400
}

// Subnet too large for scanning (max 1024 addresses)
func ErrorSubnetTooLarge(format string, args ...interface{}) *errors.Error {
	return errors.New(400, IpamErrorReason_SUBNET_TOO_LARGE.String(), fmt.Sprintf(format, args...))
}

// IPv6 subnets not supported for scanning
func IsIpv6NotSupported(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_IPV6_NOT_SUPPORTED.String() && e.Code == 400
}

// IPv6 subnets not supported for scanning
func ErrorIpv6NotSupported(format string, args ...interface{}) *errors.Error {
	return errors.New(400, IpamErrorReason_IPV6_NOT_SUPPORTED.String(), fmt.Sprintf(format, args...))
}

// IP group already exists
func IsIpGroupAlreadyExists(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_IP_GROUP_ALREADY_EXISTS.String() && e.Code == 409
}

// IP group already exists
func ErrorIpGroupAlreadyExists(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_IP_GROUP_ALREADY_EXISTS.String(), fmt.Sprintf(format, args...))
}

// IP group member already exists
func IsIpGroupMemberDuplicate(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_IP_GROUP_MEMBER_DUPLICATE.String() && e.Code == 409
}

// IP group member already exists
func ErrorIpGroupMemberDuplicate(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_IP_GROUP_MEMBER_DUPLICATE.String(), fmt.Sprintf(format, args...))
}

// IP group member value is invalid
func IsIpGroupMemberInvalid(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_IP_GROUP_MEMBER_INVALID.String() && e.Code == 400
}

// IP group member value is invalid
func ErrorIpGroupMemberInvalid(format string, args ...interface{}) *errors.Error {
	return errors.New(400, IpamErrorReason_IP_GROUP_MEMBER_INVALID.String(), fmt.Sprintf(format, args...))
}

// Host group already exists
func IsHostGroupAlreadyExists(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_HOST_GROUP_ALREADY_EXISTS.String() && e.Code == 409
}

// Host group already exists
func ErrorHostGroupAlreadyExists(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_HOST_GROUP_ALREADY_EXISTS.String(), fmt.Sprintf(format, args...))
}

// Host group member already exists
func IsHostGroupMemberDuplicate(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_HOST_GROUP_MEMBER_DUPLICATE.String() && e.Code == 409
}

// Host group member already exists
func ErrorHostGroupMemberDuplicate(format string, args ...interface{}) *errors.Error {
	return errors.New(409, IpamErrorReason_HOST_GROUP_MEMBER_DUPLICATE.String(), fmt.Sprintf(format, args...))
}

// 500
func IsInternalServerError(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_INTERNAL_SERVER_ERROR.String() && e.Code == 500
}

// 500
func ErrorInternalServerError(format string, args ...interface{}) *errors.Error {
	return errors.New(500, IpamErrorReason_INTERNAL_SERVER_ERROR.String(), fmt.Sprintf(format, args...))
}

// 503
func IsServiceUnavailable(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_SERVICE_UNAVAILABLE.String() && e.Code == 503
}

// 503
func ErrorServiceUnavailable(format string, args ...interface{}) *errors.Error {
	return errors.New(503, IpamErrorReason_SERVICE_UNAVAILABLE.String(), fmt.Sprintf(format, args...))
}

// 507
func IsNoAvailableAddresses(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == IpamErrorReason_NO_AVAILABLE_ADDRESSES.String() && e.Code == 507
}

// 507
func ErrorNoAvailableAddresses(format string, args ...interface{}) *errors.Error {
	return errors.New(507, IpamErrorReason_NO_AVAILABLE_ADDRESSES.String(), fmt.Sprintf(format, args...))
}
