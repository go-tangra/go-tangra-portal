// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             (unknown)
// source: ipam/service/v1/ip_group.proto

package ipampb

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationIpGroupServiceAddIpGroupMember = "/ipam.service.v1.IpGroupService/AddIpGroupMember"
const OperationIpGroupServiceCheckIpInGroup = "/ipam.service.v1.IpGroupService/CheckIpInGroup"
const OperationIpGroupServiceCreateIpGroup = "/ipam.service.v1.IpGroupService/CreateIpGroup"
const OperationIpGroupServiceDeleteIpGroup = "/ipam.service.v1.IpGroupService/DeleteIpGroup"
const OperationIpGroupServiceGetIpGroup = "/ipam.service.v1.IpGroupService/GetIpGroup"
const OperationIpGroupServiceListIpGroupMembers = "/ipam.service.v1.IpGroupService/ListIpGroupMembers"
const OperationIpGroupServiceListIpGroups = "/ipam.service.v1.IpGroupService/ListIpGroups"
const OperationIpGroupServiceRemoveIpGroupMember = "/ipam.service.v1.IpGroupService/RemoveIpGroupMember"
const OperationIpGroupServiceUpdateIpGroup = "/ipam.service.v1.IpGroupService/UpdateIpGroup"
const OperationIpGroupServiceUpdateIpGroupMember = "/ipam.service.v1.IpGroupService/UpdateIpGroupMember"

type IpGroupServiceHTTPServer interface {
	// AddIpGroupMember Add a member to an IP group
	AddIpGroupMember(context.Context, *AddIpGroupMemberRequest) (*AddIpGroupMemberResponse, error)
	// CheckIpInGroup Check if an IP address is contained in any group
	CheckIpInGroup(context.Context, *CheckIpInGroupRequest) (*CheckIpInGroupResponse, error)
	// CreateIpGroup Create a new IP group
	CreateIpGroup(context.Context, *CreateIpGroupRequest) (*CreateIpGroupResponse, error)
	// DeleteIpGroup Delete an IP group
	DeleteIpGroup(context.Context, *DeleteIpGroupRequest) (*emptypb.Empty, error)
	// GetIpGroup Get an IP group by ID
	GetIpGroup(context.Context, *GetIpGroupRequest) (*GetIpGroupResponse, error)
	// ListIpGroupMembers List members of an IP group
	ListIpGroupMembers(context.Context, *ListIpGroupMembersRequest) (*ListIpGroupMembersResponse, error)
	// ListIpGroups List IP groups with filtering
	ListIpGroups(context.Context, *ListIpGroupsRequest) (*ListIpGroupsResponse, error)
	// RemoveIpGroupMember Remove a member from an IP group
	RemoveIpGroupMember(context.Context, *RemoveIpGroupMemberRequest) (*emptypb.Empty, error)
	// UpdateIpGroup Update an IP group
	UpdateIpGroup(context.Context, *UpdateIpGroupRequest) (*UpdateIpGroupResponse, error)
	// UpdateIpGroupMember Update a member in an IP group
	UpdateIpGroupMember(context.Context, *UpdateIpGroupMemberRequest) (*UpdateIpGroupMemberResponse, error)
}

func RegisterIpGroupServiceHTTPServer(s *http.Server, srv IpGroupServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/ip-groups", _IpGroupService_CreateIpGroup0_HTTP_Handler(srv))
	r.GET("/v1/ip-groups/{id}", _IpGroupService_GetIpGroup0_HTTP_Handler(srv))
	r.GET("/v1/ip-groups", _IpGroupService_ListIpGroups0_HTTP_Handler(srv))
	r.PUT("/v1/ip-groups/{id}", _IpGroupService_UpdateIpGroup0_HTTP_Handler(srv))
	r.DELETE("/v1/ip-groups/{id}", _IpGroupService_DeleteIpGroup0_HTTP_Handler(srv))
	r.POST("/v1/ip-groups/{ip_group_id}/members", _IpGroupService_AddIpGroupMember0_HTTP_Handler(srv))
	r.DELETE("/v1/ip-groups/{ip_group_id}/members/{member_id}", _IpGroupService_RemoveIpGroupMember0_HTTP_Handler(srv))
	r.GET("/v1/ip-groups/{ip_group_id}/members", _IpGroupService_ListIpGroupMembers0_HTTP_Handler(srv))
	r.PUT("/v1/ip-groups/{ip_group_id}/members/{member_id}", _IpGroupService_UpdateIpGroupMember0_HTTP_Handler(srv))
	r.GET("/v1/ip-groups/check", _IpGroupService_CheckIpInGroup0_HTTP_Handler(srv))
}

func _IpGroupService_CreateIpGroup0_HTTP_Handler(srv IpGroupServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateIpGroupRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpGroupServiceCreateIpGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateIpGroup(ctx, req.(*CreateIpGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateIpGroupResponse)
		return ctx.Result(200, reply)
	}
}

func _IpGroupService_GetIpGroup0_HTTP_Handler(srv IpGroupServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetIpGroupRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpGroupServiceGetIpGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetIpGroup(ctx, req.(*GetIpGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetIpGroupResponse)
		return ctx.Result(200, reply)
	}
}

func _IpGroupService_ListIpGroups0_HTTP_Handler(srv IpGroupServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListIpGroupsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpGroupServiceListIpGroups)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListIpGroups(ctx, req.(*ListIpGroupsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListIpGroupsResponse)
		return ctx.Result(200, reply)
	}
}

func _IpGroupService_UpdateIpGroup0_HTTP_Handler(srv IpGroupServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateIpGroupRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpGroupServiceUpdateIpGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateIpGroup(ctx, req.(*UpdateIpGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateIpGroupResponse)
		return ctx.Result(200, reply)
	}
}

func _IpGroupService_DeleteIpGroup0_HTTP_Handler(srv IpGroupServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteIpGroupRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpGroupServiceDeleteIpGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteIpGroup(ctx, req.(*DeleteIpGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _IpGroupService_AddIpGroupMember0_HTTP_Handler(srv IpGroupServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AddIpGroupMemberRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpGroupServiceAddIpGroupMember)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AddIpGroupMember(ctx, req.(*AddIpGroupMemberRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AddIpGroupMemberResponse)
		return ctx.Result(200, reply)
	}
}

func _IpGroupService_RemoveIpGroupMember0_HTTP_Handler(srv IpGroupServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RemoveIpGroupMemberRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpGroupServiceRemoveIpGroupMember)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RemoveIpGroupMember(ctx, req.(*RemoveIpGroupMemberRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _IpGroupService_ListIpGroupMembers0_HTTP_Handler(srv IpGroupServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListIpGroupMembersRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpGroupServiceListIpGroupMembers)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListIpGroupMembers(ctx, req.(*ListIpGroupMembersRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListIpGroupMembersResponse)
		return ctx.Result(200, reply)
	}
}

func _IpGroupService_UpdateIpGroupMember0_HTTP_Handler(srv IpGroupServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateIpGroupMemberRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpGroupServiceUpdateIpGroupMember)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateIpGroupMember(ctx, req.(*UpdateIpGroupMemberRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateIpGroupMemberResponse)
		return ctx.Result(200, reply)
	}
}

func _IpGroupService_CheckIpInGroup0_HTTP_Handler(srv IpGroupServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CheckIpInGroupRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpGroupServiceCheckIpInGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CheckIpInGroup(ctx, req.(*CheckIpInGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CheckIpInGroupResponse)
		return ctx.Result(200, reply)
	}
}

type IpGroupServiceHTTPClient interface {
	// AddIpGroupMember Add a member to an IP group
	AddIpGroupMember(ctx context.Context, req *AddIpGroupMemberRequest, opts ...http.CallOption) (rsp *AddIpGroupMemberResponse, err error)
	// CheckIpInGroup Check if an IP address is contained in any group
	CheckIpInGroup(ctx context.Context, req *CheckIpInGroupRequest, opts ...http.CallOption) (rsp *CheckIpInGroupResponse, err error)
	// CreateIpGroup Create a new IP group
	CreateIpGroup(ctx context.Context, req *CreateIpGroupRequest, opts ...http.CallOption) (rsp *CreateIpGroupResponse, err error)
	// DeleteIpGroup Delete an IP group
	DeleteIpGroup(ctx context.Context, req *DeleteIpGroupRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	// GetIpGroup Get an IP group by ID
	GetIpGroup(ctx context.Context, req *GetIpGroupRequest, opts ...http.CallOption) (rsp *GetIpGroupResponse, err error)
	// ListIpGroupMembers List members of an IP group
	ListIpGroupMembers(ctx context.Context, req *ListIpGroupMembersRequest, opts ...http.CallOption) (rsp *ListIpGroupMembersResponse, err error)
	// ListIpGroups List IP groups with filtering
	ListIpGroups(ctx context.Context, req *ListIpGroupsRequest, opts ...http.CallOption) (rsp *ListIpGroupsResponse, err error)
	// RemoveIpGroupMember Remove a member from an IP group
	RemoveIpGroupMember(ctx context.Context, req *RemoveIpGroupMemberRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	// UpdateIpGroup Update an IP group
	UpdateIpGroup(ctx context.Context, req *UpdateIpGroupRequest, opts ...http.CallOption) (rsp *UpdateIpGroupResponse, err error)
	// UpdateIpGroupMember Update a member in an IP group
	UpdateIpGroupMember(ctx context.Context, req *UpdateIpGroupMemberRequest, opts ...http.CallOption) (rsp *UpdateIpGroupMemberResponse, err error)
}

type IpGroupServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewIpGroupServiceHTTPClient(client *http.Client) IpGroupServiceHTTPClient {
	return &IpGroupServiceHTTPClientImpl{client}
}

// AddIpGroupMember Add a member to an IP group
func (c *IpGroupServiceHTTPClientImpl) AddIpGroupMember(ctx context.Context, in *AddIpGroupMemberRequest, opts ...http.CallOption) (*AddIpGroupMemberResponse, error) {
	var out AddIpGroupMemberResponse
	pattern := "/v1/ip-groups/{ip_group_id}/members"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationIpGroupServiceAddIpGroupMember))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// CheckIpInGroup Check if an IP address is contained in any group
func (c *IpGroupServiceHTTPClientImpl) CheckIpInGroup(ctx context.Context, in *CheckIpInGroupRequest, opts ...http.CallOption) (*CheckIpInGroupResponse, error) {
	var out CheckIpInGroupResponse
	pattern := "/v1/ip-groups/check"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationIpGroupServiceCheckIpInGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// CreateIpGroup Create a new IP group
func (c *IpGroupServiceHTTPClientImpl) CreateIpGroup(ctx context.Context, in *CreateIpGroupRequest, opts ...http.CallOption) (*CreateIpGroupResponse, error) {
	var out CreateIpGroupResponse
	pattern := "/v1/ip-groups"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationIpGroupServiceCreateIpGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// DeleteIpGroup Delete an IP group
func (c *IpGroupServiceHTTPClientImpl) DeleteIpGroup(ctx context.Context, in *DeleteIpGroupRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/v1/ip-groups/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationIpGroupServiceDeleteIpGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetIpGroup Get an IP group by ID
func (c *IpGroupServiceHTTPClientImpl) GetIpGroup(ctx context.Context, in *GetIpGroupRequest, opts ...http.CallOption) (*GetIpGroupResponse, error) {
	var out GetIpGroupResponse
	pattern := "/v1/ip-groups/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationIpGroupServiceGetIpGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListIpGroupMembers List members of an IP group
func (c *IpGroupServiceHTTPClientImpl) ListIpGroupMembers(ctx context.Context, in *ListIpGroupMembersRequest, opts ...http.CallOption) (*ListIpGroupMembersResponse, error) {
	var out ListIpGroupMembersResponse
	pattern := "/v1/ip-groups/{ip_group_id}/members"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationIpGroupServiceListIpGroupMembers))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListIpGroups List IP groups with filtering
func (c *IpGroupServiceHTTPClientImpl) ListIpGroups(ctx context.Context, in *ListIpGroupsRequest, opts ...http.CallOption) (*ListIpGroupsResponse, error) {
	var out ListIpGroupsResponse
	pattern := "/v1/ip-groups"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationIpGroupServiceListIpGroups))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// RemoveIpGroupMember Remove a member from an IP group
func (c *IpGroupServiceHTTPClientImpl) RemoveIpGroupMember(ctx context.Context, in *RemoveIpGroupMemberRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/v1/ip-groups/{ip_group_id}/members/{member_id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationIpGroupServiceRemoveIpGroupMember))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// UpdateIpGroup Update an IP group
func (c *IpGroupServiceHTTPClientImpl) UpdateIpGroup(ctx context.Context, in *UpdateIpGroupRequest, opts ...http.CallOption) (*UpdateIpGroupResponse, error) {
	var out UpdateIpGroupResponse
	pattern := "/v1/ip-groups/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationIpGroupServiceUpdateIpGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// UpdateIpGroupMember Update a member in an IP group
func (c *IpGroupServiceHTTPClientImpl) UpdateIpGroupMember(ctx context.Context, in *UpdateIpGroupMemberRequest, opts ...http.CallOption) (*UpdateIpGroupMemberResponse, error) {
	var out UpdateIpGroupMemberResponse
	pattern := "/v1/ip-groups/{ip_group_id}/members/{member_id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationIpGroupServiceUpdateIpGroupMember))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
