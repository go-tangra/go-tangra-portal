// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             (unknown)
// source: ipam/service/v1/vlan.proto

package ipampb

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationVlanServiceCreateVlan = "/ipam.service.v1.VlanService/CreateVlan"
const OperationVlanServiceDeleteVlan = "/ipam.service.v1.VlanService/DeleteVlan"
const OperationVlanServiceGetVlan = "/ipam.service.v1.VlanService/GetVlan"
const OperationVlanServiceGetVlanSubnets = "/ipam.service.v1.VlanService/GetVlanSubnets"
const OperationVlanServiceListVlans = "/ipam.service.v1.VlanService/ListVlans"
const OperationVlanServiceUpdateVlan = "/ipam.service.v1.VlanService/UpdateVlan"

type VlanServiceHTTPServer interface {
	// CreateVlan Create a new VLAN
	CreateVlan(context.Context, *CreateVlanRequest) (*CreateVlanResponse, error)
	// DeleteVlan Delete a VLAN
	DeleteVlan(context.Context, *DeleteVlanRequest) (*emptypb.Empty, error)
	// GetVlan Get a VLAN by ID
	GetVlan(context.Context, *GetVlanRequest) (*GetVlanResponse, error)
	// GetVlanSubnets Get subnets associated with a VLAN
	GetVlanSubnets(context.Context, *GetVlanSubnetsRequest) (*GetVlanSubnetsResponse, error)
	// ListVlans List VLANs with filtering
	ListVlans(context.Context, *ListVlansRequest) (*ListVlansResponse, error)
	// UpdateVlan Update a VLAN
	UpdateVlan(context.Context, *UpdateVlanRequest) (*UpdateVlanResponse, error)
}

func RegisterVlanServiceHTTPServer(s *http.Server, srv VlanServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/vlans", _VlanService_CreateVlan0_HTTP_Handler(srv))
	r.GET("/v1/vlans/{id}", _VlanService_GetVlan0_HTTP_Handler(srv))
	r.GET("/v1/vlans", _VlanService_ListVlans0_HTTP_Handler(srv))
	r.PUT("/v1/vlans/{id}", _VlanService_UpdateVlan0_HTTP_Handler(srv))
	r.DELETE("/v1/vlans/{id}", _VlanService_DeleteVlan0_HTTP_Handler(srv))
	r.GET("/v1/vlans/{id}/subnets", _VlanService_GetVlanSubnets0_HTTP_Handler(srv))
}

func _VlanService_CreateVlan0_HTTP_Handler(srv VlanServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateVlanRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVlanServiceCreateVlan)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateVlan(ctx, req.(*CreateVlanRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateVlanResponse)
		return ctx.Result(200, reply)
	}
}

func _VlanService_GetVlan0_HTTP_Handler(srv VlanServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetVlanRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVlanServiceGetVlan)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetVlan(ctx, req.(*GetVlanRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetVlanResponse)
		return ctx.Result(200, reply)
	}
}

func _VlanService_ListVlans0_HTTP_Handler(srv VlanServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListVlansRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVlanServiceListVlans)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListVlans(ctx, req.(*ListVlansRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListVlansResponse)
		return ctx.Result(200, reply)
	}
}

func _VlanService_UpdateVlan0_HTTP_Handler(srv VlanServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateVlanRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVlanServiceUpdateVlan)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateVlan(ctx, req.(*UpdateVlanRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateVlanResponse)
		return ctx.Result(200, reply)
	}
}

func _VlanService_DeleteVlan0_HTTP_Handler(srv VlanServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteVlanRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVlanServiceDeleteVlan)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteVlan(ctx, req.(*DeleteVlanRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _VlanService_GetVlanSubnets0_HTTP_Handler(srv VlanServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetVlanSubnetsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVlanServiceGetVlanSubnets)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetVlanSubnets(ctx, req.(*GetVlanSubnetsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetVlanSubnetsResponse)
		return ctx.Result(200, reply)
	}
}

type VlanServiceHTTPClient interface {
	// CreateVlan Create a new VLAN
	CreateVlan(ctx context.Context, req *CreateVlanRequest, opts ...http.CallOption) (rsp *CreateVlanResponse, err error)
	// DeleteVlan Delete a VLAN
	DeleteVlan(ctx context.Context, req *DeleteVlanRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	// GetVlan Get a VLAN by ID
	GetVlan(ctx context.Context, req *GetVlanRequest, opts ...http.CallOption) (rsp *GetVlanResponse, err error)
	// GetVlanSubnets Get subnets associated with a VLAN
	GetVlanSubnets(ctx context.Context, req *GetVlanSubnetsRequest, opts ...http.CallOption) (rsp *GetVlanSubnetsResponse, err error)
	// ListVlans List VLANs with filtering
	ListVlans(ctx context.Context, req *ListVlansRequest, opts ...http.CallOption) (rsp *ListVlansResponse, err error)
	// UpdateVlan Update a VLAN
	UpdateVlan(ctx context.Context, req *UpdateVlanRequest, opts ...http.CallOption) (rsp *UpdateVlanResponse, err error)
}

type VlanServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewVlanServiceHTTPClient(client *http.Client) VlanServiceHTTPClient {
	return &VlanServiceHTTPClientImpl{client}
}

// CreateVlan Create a new VLAN
func (c *VlanServiceHTTPClientImpl) CreateVlan(ctx context.Context, in *CreateVlanRequest, opts ...http.CallOption) (*CreateVlanResponse, error) {
	var out CreateVlanResponse
	pattern := "/v1/vlans"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationVlanServiceCreateVlan))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// DeleteVlan Delete a VLAN
func (c *VlanServiceHTTPClientImpl) DeleteVlan(ctx context.Context, in *DeleteVlanRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/v1/vlans/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationVlanServiceDeleteVlan))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetVlan Get a VLAN by ID
func (c *VlanServiceHTTPClientImpl) GetVlan(ctx context.Context, in *GetVlanRequest, opts ...http.CallOption) (*GetVlanResponse, error) {
	var out GetVlanResponse
	pattern := "/v1/vlans/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationVlanServiceGetVlan))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetVlanSubnets Get subnets associated with a VLAN
func (c *VlanServiceHTTPClientImpl) GetVlanSubnets(ctx context.Context, in *GetVlanSubnetsRequest, opts ...http.CallOption) (*GetVlanSubnetsResponse, error) {
	var out GetVlanSubnetsResponse
	pattern := "/v1/vlans/{id}/subnets"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationVlanServiceGetVlanSubnets))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListVlans List VLANs with filtering
func (c *VlanServiceHTTPClientImpl) ListVlans(ctx context.Context, in *ListVlansRequest, opts ...http.CallOption) (*ListVlansResponse, error) {
	var out ListVlansResponse
	pattern := "/v1/vlans"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationVlanServiceListVlans))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// UpdateVlan Update a VLAN
func (c *VlanServiceHTTPClientImpl) UpdateVlan(ctx context.Context, in *UpdateVlanRequest, opts ...http.CallOption) (*UpdateVlanResponse, error) {
	var out UpdateVlanResponse
	pattern := "/v1/vlans/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationVlanServiceUpdateVlan))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
