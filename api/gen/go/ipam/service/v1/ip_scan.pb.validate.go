// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: ipam/service/v1/ip_scan.proto

package ipampb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on IpScanJob with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IpScanJob) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IpScanJob with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IpScanJobMultiError, or nil
// if none found.
func (m *IpScanJob) ValidateAll() error {
	return m.validate(true)
}

func (m *IpScanJob) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.SubnetId != nil {
		// no validation rules for SubnetId
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.Progress != nil {
		// no validation rules for Progress
	}

	if m.StatusMessage != nil {
		// no validation rules for StatusMessage
	}

	if m.TotalAddresses != nil {
		// no validation rules for TotalAddresses
	}

	if m.ScannedCount != nil {
		// no validation rules for ScannedCount
	}

	if m.AliveCount != nil {
		// no validation rules for AliveCount
	}

	if m.NewCount != nil {
		// no validation rules for NewCount
	}

	if m.UpdatedCount != nil {
		// no validation rules for UpdatedCount
	}

	if m.TriggeredBy != nil {
		// no validation rules for TriggeredBy
	}

	if m.RetryCount != nil {
		// no validation rules for RetryCount
	}

	if m.MaxRetries != nil {
		// no validation rules for MaxRetries
	}

	if m.TimeoutMs != nil {
		// no validation rules for TimeoutMs
	}

	if m.Concurrency != nil {
		// no validation rules for Concurrency
	}

	if m.SkipReverseDns != nil {
		// no validation rules for SkipReverseDns
	}

	if m.TcpProbePorts != nil {
		// no validation rules for TcpProbePorts
	}

	if m.StartedAt != nil {

		if all {
			switch v := interface{}(m.GetStartedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IpScanJobValidationError{
						field:  "StartedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IpScanJobValidationError{
						field:  "StartedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IpScanJobValidationError{
					field:  "StartedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CompletedAt != nil {

		if all {
			switch v := interface{}(m.GetCompletedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IpScanJobValidationError{
						field:  "CompletedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IpScanJobValidationError{
						field:  "CompletedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCompletedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IpScanJobValidationError{
					field:  "CompletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IpScanJobValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IpScanJobValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IpScanJobValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IpScanJobValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IpScanJobValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IpScanJobValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CreatedBy != nil {
		// no validation rules for CreatedBy
	}

	if len(errors) > 0 {
		return IpScanJobMultiError(errors)
	}

	return nil
}

// IpScanJobMultiError is an error wrapping multiple validation errors returned
// by IpScanJob.ValidateAll() if the designated constraints aren't met.
type IpScanJobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IpScanJobMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IpScanJobMultiError) AllErrors() []error { return m }

// IpScanJobValidationError is the validation error returned by
// IpScanJob.Validate if the designated constraints aren't met.
type IpScanJobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IpScanJobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IpScanJobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IpScanJobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IpScanJobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IpScanJobValidationError) ErrorName() string { return "IpScanJobValidationError" }

// Error satisfies the builtin error interface
func (e IpScanJobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIpScanJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IpScanJobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IpScanJobValidationError{}

// Validate checks the field values on StartScanRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StartScanRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartScanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartScanRequestMultiError, or nil if none found.
func (m *StartScanRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartScanRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubnetId

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.ScanConfig != nil {

		if all {
			switch v := interface{}(m.GetScanConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StartScanRequestValidationError{
						field:  "ScanConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StartScanRequestValidationError{
						field:  "ScanConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScanConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StartScanRequestValidationError{
					field:  "ScanConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StartScanRequestMultiError(errors)
	}

	return nil
}

// StartScanRequestMultiError is an error wrapping multiple validation errors
// returned by StartScanRequest.ValidateAll() if the designated constraints
// aren't met.
type StartScanRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartScanRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartScanRequestMultiError) AllErrors() []error { return m }

// StartScanRequestValidationError is the validation error returned by
// StartScanRequest.Validate if the designated constraints aren't met.
type StartScanRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartScanRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartScanRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartScanRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartScanRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartScanRequestValidationError) ErrorName() string { return "StartScanRequestValidationError" }

// Error satisfies the builtin error interface
func (e StartScanRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartScanRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartScanRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartScanRequestValidationError{}

// Validate checks the field values on StartScanResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StartScanResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartScanResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartScanResponseMultiError, or nil if none found.
func (m *StartScanResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartScanResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartScanResponseValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartScanResponseValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartScanResponseValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartScanResponseMultiError(errors)
	}

	return nil
}

// StartScanResponseMultiError is an error wrapping multiple validation errors
// returned by StartScanResponse.ValidateAll() if the designated constraints
// aren't met.
type StartScanResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartScanResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartScanResponseMultiError) AllErrors() []error { return m }

// StartScanResponseValidationError is the validation error returned by
// StartScanResponse.Validate if the designated constraints aren't met.
type StartScanResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartScanResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartScanResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartScanResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartScanResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartScanResponseValidationError) ErrorName() string {
	return "StartScanResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartScanResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartScanResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartScanResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartScanResponseValidationError{}

// Validate checks the field values on GetScanJobRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetScanJobRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetScanJobRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetScanJobRequestMultiError, or nil if none found.
func (m *GetScanJobRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetScanJobRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetScanJobRequestMultiError(errors)
	}

	return nil
}

// GetScanJobRequestMultiError is an error wrapping multiple validation errors
// returned by GetScanJobRequest.ValidateAll() if the designated constraints
// aren't met.
type GetScanJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetScanJobRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetScanJobRequestMultiError) AllErrors() []error { return m }

// GetScanJobRequestValidationError is the validation error returned by
// GetScanJobRequest.Validate if the designated constraints aren't met.
type GetScanJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetScanJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetScanJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetScanJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetScanJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetScanJobRequestValidationError) ErrorName() string {
	return "GetScanJobRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetScanJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetScanJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetScanJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetScanJobRequestValidationError{}

// Validate checks the field values on GetScanJobResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetScanJobResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetScanJobResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetScanJobResponseMultiError, or nil if none found.
func (m *GetScanJobResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetScanJobResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetScanJobResponseValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetScanJobResponseValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetScanJobResponseValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetScanJobResponseMultiError(errors)
	}

	return nil
}

// GetScanJobResponseMultiError is an error wrapping multiple validation errors
// returned by GetScanJobResponse.ValidateAll() if the designated constraints
// aren't met.
type GetScanJobResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetScanJobResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetScanJobResponseMultiError) AllErrors() []error { return m }

// GetScanJobResponseValidationError is the validation error returned by
// GetScanJobResponse.Validate if the designated constraints aren't met.
type GetScanJobResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetScanJobResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetScanJobResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetScanJobResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetScanJobResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetScanJobResponseValidationError) ErrorName() string {
	return "GetScanJobResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetScanJobResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetScanJobResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetScanJobResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetScanJobResponseValidationError{}

// Validate checks the field values on ListScanJobsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListScanJobsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListScanJobsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListScanJobsRequestMultiError, or nil if none found.
func (m *ListScanJobsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListScanJobsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.SubnetId != nil {
		// no validation rules for SubnetId
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if len(errors) > 0 {
		return ListScanJobsRequestMultiError(errors)
	}

	return nil
}

// ListScanJobsRequestMultiError is an error wrapping multiple validation
// errors returned by ListScanJobsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListScanJobsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListScanJobsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListScanJobsRequestMultiError) AllErrors() []error { return m }

// ListScanJobsRequestValidationError is the validation error returned by
// ListScanJobsRequest.Validate if the designated constraints aren't met.
type ListScanJobsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListScanJobsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListScanJobsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListScanJobsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListScanJobsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListScanJobsRequestValidationError) ErrorName() string {
	return "ListScanJobsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListScanJobsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListScanJobsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListScanJobsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListScanJobsRequestValidationError{}

// Validate checks the field values on ListScanJobsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListScanJobsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListScanJobsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListScanJobsResponseMultiError, or nil if none found.
func (m *ListScanJobsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListScanJobsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListScanJobsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListScanJobsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListScanJobsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListScanJobsResponseMultiError(errors)
	}

	return nil
}

// ListScanJobsResponseMultiError is an error wrapping multiple validation
// errors returned by ListScanJobsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListScanJobsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListScanJobsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListScanJobsResponseMultiError) AllErrors() []error { return m }

// ListScanJobsResponseValidationError is the validation error returned by
// ListScanJobsResponse.Validate if the designated constraints aren't met.
type ListScanJobsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListScanJobsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListScanJobsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListScanJobsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListScanJobsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListScanJobsResponseValidationError) ErrorName() string {
	return "ListScanJobsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListScanJobsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListScanJobsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListScanJobsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListScanJobsResponseValidationError{}

// Validate checks the field values on CancelScanRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CancelScanRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelScanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelScanRequestMultiError, or nil if none found.
func (m *CancelScanRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelScanRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return CancelScanRequestMultiError(errors)
	}

	return nil
}

// CancelScanRequestMultiError is an error wrapping multiple validation errors
// returned by CancelScanRequest.ValidateAll() if the designated constraints
// aren't met.
type CancelScanRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelScanRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelScanRequestMultiError) AllErrors() []error { return m }

// CancelScanRequestValidationError is the validation error returned by
// CancelScanRequest.Validate if the designated constraints aren't met.
type CancelScanRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelScanRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelScanRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelScanRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelScanRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelScanRequestValidationError) ErrorName() string {
	return "CancelScanRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CancelScanRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelScanRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelScanRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelScanRequestValidationError{}

// Validate checks the field values on CancelScanResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelScanResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelScanResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelScanResponseMultiError, or nil if none found.
func (m *CancelScanResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelScanResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CancelScanResponseValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CancelScanResponseValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CancelScanResponseValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CancelScanResponseMultiError(errors)
	}

	return nil
}

// CancelScanResponseMultiError is an error wrapping multiple validation errors
// returned by CancelScanResponse.ValidateAll() if the designated constraints
// aren't met.
type CancelScanResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelScanResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelScanResponseMultiError) AllErrors() []error { return m }

// CancelScanResponseValidationError is the validation error returned by
// CancelScanResponse.Validate if the designated constraints aren't met.
type CancelScanResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelScanResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelScanResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelScanResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelScanResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelScanResponseValidationError) ErrorName() string {
	return "CancelScanResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CancelScanResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelScanResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelScanResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelScanResponseValidationError{}
