// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             (unknown)
// source: ipam/service/v1/ip_address.proto

package ipampb

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationIpAddressServiceAllocateNextAddress = "/ipam.service.v1.IpAddressService/AllocateNextAddress"
const OperationIpAddressServiceBulkAllocateAddresses = "/ipam.service.v1.IpAddressService/BulkAllocateAddresses"
const OperationIpAddressServiceCreateIpAddress = "/ipam.service.v1.IpAddressService/CreateIpAddress"
const OperationIpAddressServiceDeleteIpAddress = "/ipam.service.v1.IpAddressService/DeleteIpAddress"
const OperationIpAddressServiceFindAddress = "/ipam.service.v1.IpAddressService/FindAddress"
const OperationIpAddressServiceGetIpAddress = "/ipam.service.v1.IpAddressService/GetIpAddress"
const OperationIpAddressServiceListIpAddresses = "/ipam.service.v1.IpAddressService/ListIpAddresses"
const OperationIpAddressServicePingAddress = "/ipam.service.v1.IpAddressService/PingAddress"
const OperationIpAddressServiceUpdateIpAddress = "/ipam.service.v1.IpAddressService/UpdateIpAddress"

type IpAddressServiceHTTPServer interface {
	// AllocateNextAddress Allocate the next available address in a subnet
	AllocateNextAddress(context.Context, *AllocateNextAddressRequest) (*AllocateNextAddressResponse, error)
	// BulkAllocateAddresses Bulk allocate multiple addresses
	BulkAllocateAddresses(context.Context, *BulkAllocateAddressesRequest) (*BulkAllocateAddressesResponse, error)
	// CreateIpAddress Create a new IP address
	CreateIpAddress(context.Context, *CreateIpAddressRequest) (*CreateIpAddressResponse, error)
	// DeleteIpAddress Delete an IP address
	DeleteIpAddress(context.Context, *DeleteIpAddressRequest) (*emptypb.Empty, error)
	// FindAddress Find an address by IP
	FindAddress(context.Context, *FindAddressRequest) (*FindAddressResponse, error)
	// GetIpAddress Get an IP address by ID
	GetIpAddress(context.Context, *GetIpAddressRequest) (*GetIpAddressResponse, error)
	// ListIpAddresses List IP addresses with filtering
	ListIpAddresses(context.Context, *ListIpAddressesRequest) (*ListIpAddressesResponse, error)
	// PingAddress Ping an address to check reachability
	PingAddress(context.Context, *PingAddressRequest) (*PingAddressResponse, error)
	// UpdateIpAddress Update an IP address
	UpdateIpAddress(context.Context, *UpdateIpAddressRequest) (*UpdateIpAddressResponse, error)
}

func RegisterIpAddressServiceHTTPServer(s *http.Server, srv IpAddressServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/ip-addresses", _IpAddressService_CreateIpAddress0_HTTP_Handler(srv))
	r.GET("/v1/ip-addresses/{id}", _IpAddressService_GetIpAddress0_HTTP_Handler(srv))
	r.GET("/v1/ip-addresses", _IpAddressService_ListIpAddresses0_HTTP_Handler(srv))
	r.PUT("/v1/ip-addresses/{id}", _IpAddressService_UpdateIpAddress0_HTTP_Handler(srv))
	r.DELETE("/v1/ip-addresses/{id}", _IpAddressService_DeleteIpAddress0_HTTP_Handler(srv))
	r.POST("/v1/ip-addresses/allocate", _IpAddressService_AllocateNextAddress0_HTTP_Handler(srv))
	r.POST("/v1/ip-addresses/bulk-allocate", _IpAddressService_BulkAllocateAddresses0_HTTP_Handler(srv))
	r.GET("/v1/ip-addresses/find", _IpAddressService_FindAddress0_HTTP_Handler(srv))
	r.POST("/v1/ip-addresses/{id}/ping", _IpAddressService_PingAddress0_HTTP_Handler(srv))
}

func _IpAddressService_CreateIpAddress0_HTTP_Handler(srv IpAddressServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateIpAddressRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpAddressServiceCreateIpAddress)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateIpAddress(ctx, req.(*CreateIpAddressRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateIpAddressResponse)
		return ctx.Result(200, reply)
	}
}

func _IpAddressService_GetIpAddress0_HTTP_Handler(srv IpAddressServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetIpAddressRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpAddressServiceGetIpAddress)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetIpAddress(ctx, req.(*GetIpAddressRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetIpAddressResponse)
		return ctx.Result(200, reply)
	}
}

func _IpAddressService_ListIpAddresses0_HTTP_Handler(srv IpAddressServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListIpAddressesRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpAddressServiceListIpAddresses)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListIpAddresses(ctx, req.(*ListIpAddressesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListIpAddressesResponse)
		return ctx.Result(200, reply)
	}
}

func _IpAddressService_UpdateIpAddress0_HTTP_Handler(srv IpAddressServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateIpAddressRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpAddressServiceUpdateIpAddress)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateIpAddress(ctx, req.(*UpdateIpAddressRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateIpAddressResponse)
		return ctx.Result(200, reply)
	}
}

func _IpAddressService_DeleteIpAddress0_HTTP_Handler(srv IpAddressServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteIpAddressRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpAddressServiceDeleteIpAddress)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteIpAddress(ctx, req.(*DeleteIpAddressRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _IpAddressService_AllocateNextAddress0_HTTP_Handler(srv IpAddressServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AllocateNextAddressRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpAddressServiceAllocateNextAddress)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AllocateNextAddress(ctx, req.(*AllocateNextAddressRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AllocateNextAddressResponse)
		return ctx.Result(200, reply)
	}
}

func _IpAddressService_BulkAllocateAddresses0_HTTP_Handler(srv IpAddressServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BulkAllocateAddressesRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpAddressServiceBulkAllocateAddresses)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BulkAllocateAddresses(ctx, req.(*BulkAllocateAddressesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BulkAllocateAddressesResponse)
		return ctx.Result(200, reply)
	}
}

func _IpAddressService_FindAddress0_HTTP_Handler(srv IpAddressServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in FindAddressRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpAddressServiceFindAddress)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.FindAddress(ctx, req.(*FindAddressRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*FindAddressResponse)
		return ctx.Result(200, reply)
	}
}

func _IpAddressService_PingAddress0_HTTP_Handler(srv IpAddressServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in PingAddressRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationIpAddressServicePingAddress)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.PingAddress(ctx, req.(*PingAddressRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*PingAddressResponse)
		return ctx.Result(200, reply)
	}
}

type IpAddressServiceHTTPClient interface {
	// AllocateNextAddress Allocate the next available address in a subnet
	AllocateNextAddress(ctx context.Context, req *AllocateNextAddressRequest, opts ...http.CallOption) (rsp *AllocateNextAddressResponse, err error)
	// BulkAllocateAddresses Bulk allocate multiple addresses
	BulkAllocateAddresses(ctx context.Context, req *BulkAllocateAddressesRequest, opts ...http.CallOption) (rsp *BulkAllocateAddressesResponse, err error)
	// CreateIpAddress Create a new IP address
	CreateIpAddress(ctx context.Context, req *CreateIpAddressRequest, opts ...http.CallOption) (rsp *CreateIpAddressResponse, err error)
	// DeleteIpAddress Delete an IP address
	DeleteIpAddress(ctx context.Context, req *DeleteIpAddressRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	// FindAddress Find an address by IP
	FindAddress(ctx context.Context, req *FindAddressRequest, opts ...http.CallOption) (rsp *FindAddressResponse, err error)
	// GetIpAddress Get an IP address by ID
	GetIpAddress(ctx context.Context, req *GetIpAddressRequest, opts ...http.CallOption) (rsp *GetIpAddressResponse, err error)
	// ListIpAddresses List IP addresses with filtering
	ListIpAddresses(ctx context.Context, req *ListIpAddressesRequest, opts ...http.CallOption) (rsp *ListIpAddressesResponse, err error)
	// PingAddress Ping an address to check reachability
	PingAddress(ctx context.Context, req *PingAddressRequest, opts ...http.CallOption) (rsp *PingAddressResponse, err error)
	// UpdateIpAddress Update an IP address
	UpdateIpAddress(ctx context.Context, req *UpdateIpAddressRequest, opts ...http.CallOption) (rsp *UpdateIpAddressResponse, err error)
}

type IpAddressServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewIpAddressServiceHTTPClient(client *http.Client) IpAddressServiceHTTPClient {
	return &IpAddressServiceHTTPClientImpl{client}
}

// AllocateNextAddress Allocate the next available address in a subnet
func (c *IpAddressServiceHTTPClientImpl) AllocateNextAddress(ctx context.Context, in *AllocateNextAddressRequest, opts ...http.CallOption) (*AllocateNextAddressResponse, error) {
	var out AllocateNextAddressResponse
	pattern := "/v1/ip-addresses/allocate"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationIpAddressServiceAllocateNextAddress))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// BulkAllocateAddresses Bulk allocate multiple addresses
func (c *IpAddressServiceHTTPClientImpl) BulkAllocateAddresses(ctx context.Context, in *BulkAllocateAddressesRequest, opts ...http.CallOption) (*BulkAllocateAddressesResponse, error) {
	var out BulkAllocateAddressesResponse
	pattern := "/v1/ip-addresses/bulk-allocate"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationIpAddressServiceBulkAllocateAddresses))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// CreateIpAddress Create a new IP address
func (c *IpAddressServiceHTTPClientImpl) CreateIpAddress(ctx context.Context, in *CreateIpAddressRequest, opts ...http.CallOption) (*CreateIpAddressResponse, error) {
	var out CreateIpAddressResponse
	pattern := "/v1/ip-addresses"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationIpAddressServiceCreateIpAddress))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// DeleteIpAddress Delete an IP address
func (c *IpAddressServiceHTTPClientImpl) DeleteIpAddress(ctx context.Context, in *DeleteIpAddressRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/v1/ip-addresses/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationIpAddressServiceDeleteIpAddress))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// FindAddress Find an address by IP
func (c *IpAddressServiceHTTPClientImpl) FindAddress(ctx context.Context, in *FindAddressRequest, opts ...http.CallOption) (*FindAddressResponse, error) {
	var out FindAddressResponse
	pattern := "/v1/ip-addresses/find"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationIpAddressServiceFindAddress))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetIpAddress Get an IP address by ID
func (c *IpAddressServiceHTTPClientImpl) GetIpAddress(ctx context.Context, in *GetIpAddressRequest, opts ...http.CallOption) (*GetIpAddressResponse, error) {
	var out GetIpAddressResponse
	pattern := "/v1/ip-addresses/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationIpAddressServiceGetIpAddress))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListIpAddresses List IP addresses with filtering
func (c *IpAddressServiceHTTPClientImpl) ListIpAddresses(ctx context.Context, in *ListIpAddressesRequest, opts ...http.CallOption) (*ListIpAddressesResponse, error) {
	var out ListIpAddressesResponse
	pattern := "/v1/ip-addresses"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationIpAddressServiceListIpAddresses))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// PingAddress Ping an address to check reachability
func (c *IpAddressServiceHTTPClientImpl) PingAddress(ctx context.Context, in *PingAddressRequest, opts ...http.CallOption) (*PingAddressResponse, error) {
	var out PingAddressResponse
	pattern := "/v1/ip-addresses/{id}/ping"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationIpAddressServicePingAddress))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// UpdateIpAddress Update an IP address
func (c *IpAddressServiceHTTPClientImpl) UpdateIpAddress(ctx context.Context, in *UpdateIpAddressRequest, opts ...http.CallOption) (*UpdateIpAddressResponse, error) {
	var out UpdateIpAddressResponse
	pattern := "/v1/ip-addresses/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationIpAddressServiceUpdateIpAddress))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
