syntax = "proto3";

package ipam.service.v1;

import "buf/validate/validate.proto";
import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/field_mask.proto";

// IpAddress represents a single IP address
message IpAddress {
  // Unique identifier
  optional string id = 1 [json_name = "id"];

  // Tenant ID for multi-tenancy
  optional uint32 tenant_id = 2 [json_name = "tenantId"];

  // IP address (e.g., "192.168.1.10")
  optional string address = 3 [json_name = "address"];

  // Subnet ID this address belongs to
  optional string subnet_id = 4 [json_name = "subnetId"];

  // Hostname or FQDN
  optional string hostname = 5 [json_name = "hostname"];

  // MAC address
  optional string mac_address = 6 [json_name = "macAddress"];

  // Description
  optional string description = 7 [json_name = "description"];

  // Associated device ID
  optional string device_id = 8 [json_name = "deviceId"];

  // Interface name on device
  optional string interface_name = 9 [json_name = "interfaceName"];

  // Address status
  optional IpAddressStatus status = 10 [json_name = "status"];

  // Address type
  optional IpAddressType address_type = 11 [json_name = "addressType"];

  // Is this the primary address for the device
  optional bool is_primary = 12 [json_name = "isPrimary"];

  // PTR record for reverse DNS
  optional string ptr_record = 13 [json_name = "ptrRecord"];

  // DNS name
  optional string dns_name = 14 [json_name = "dnsName"];

  // Owner/contact
  optional string owner = 15 [json_name = "owner"];

  // Last seen timestamp (from network scan)
  optional google.protobuf.Timestamp last_seen = 16 [json_name = "lastSeen"];

  // Lease expiry (for DHCP)
  optional google.protobuf.Timestamp lease_expiry = 17 [json_name = "leaseExpiry"];

  // Whether this IP has a valid reverse DNS record
  optional bool has_reverse_dns = 18 [json_name = "hasReverseDns"];

  // Custom tags (JSON)
  optional string tags = 20 [json_name = "tags"];

  // Custom metadata (JSON)
  optional string metadata = 21 [json_name = "metadata"];

  // Note/comment
  optional string note = 22 [json_name = "note"];

  // Creation timestamp
  optional google.protobuf.Timestamp created_at = 30 [json_name = "createdAt"];

  // Last update timestamp
  optional google.protobuf.Timestamp updated_at = 31 [json_name = "updatedAt"];

  // Creator user ID
  optional uint32 created_by = 32 [json_name = "createdBy"];

  // Last updater user ID
  optional uint32 updated_by = 33 [json_name = "updatedBy"];
}

enum IpAddressStatus {
  IP_ADDRESS_STATUS_UNSPECIFIED = 0;
  IP_ADDRESS_STATUS_ACTIVE = 1;      // In use
  IP_ADDRESS_STATUS_RESERVED = 2;    // Reserved for future use
  IP_ADDRESS_STATUS_DHCP = 3;        // Assigned via DHCP
  IP_ADDRESS_STATUS_DEPRECATED = 4;  // Should not be used
  IP_ADDRESS_STATUS_OFFLINE = 5;     // Device offline
}

enum IpAddressType {
  IP_ADDRESS_TYPE_UNSPECIFIED = 0;
  IP_ADDRESS_TYPE_HOST = 1;          // Regular host
  IP_ADDRESS_TYPE_GATEWAY = 2;       // Gateway address
  IP_ADDRESS_TYPE_BROADCAST = 3;     // Broadcast address
  IP_ADDRESS_TYPE_NETWORK = 4;       // Network address
  IP_ADDRESS_TYPE_VIRTUAL = 5;       // Virtual IP (VIP)
  IP_ADDRESS_TYPE_ANYCAST = 6;       // Anycast address
}

// CreateIpAddressRequest creates a new IP address entry
message CreateIpAddressRequest {
  optional uint32 tenant_id = 1 [
    json_name = "tenantId",
    (google.api.field_behavior) = REQUIRED
  ];

  optional string address = 2 [
    json_name = "address",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];

  optional string subnet_id = 3 [
    json_name = "subnetId",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];

  optional string hostname = 4 [json_name = "hostname"];
  optional string mac_address = 5 [json_name = "macAddress"];
  optional string description = 6 [json_name = "description"];
  optional string device_id = 7 [json_name = "deviceId"];
  optional string interface_name = 8 [json_name = "interfaceName"];
  optional IpAddressStatus status = 9 [json_name = "status"];
  optional IpAddressType address_type = 10 [json_name = "addressType"];
  optional bool is_primary = 11 [json_name = "isPrimary"];
  optional string ptr_record = 12 [json_name = "ptrRecord"];
  optional string dns_name = 13 [json_name = "dnsName"];
  optional string owner = 14 [json_name = "owner"];
  optional string tags = 15 [json_name = "tags"];
  optional string metadata = 16 [json_name = "metadata"];
  optional string note = 17 [json_name = "note"];
}

message CreateIpAddressResponse {
  IpAddress ip_address = 1 [json_name = "ipAddress"];
}

// GetIpAddressRequest retrieves an IP address by ID
message GetIpAddressRequest {
  string id = 1 [
    json_name = "id",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];
}

message GetIpAddressResponse {
  IpAddress ip_address = 1 [json_name = "ipAddress"];
}

// ListIpAddressesRequest lists IP addresses with filtering
message ListIpAddressesRequest {
  optional uint32 tenant_id = 1 [json_name = "tenantId"];
  optional int32 page = 2 [json_name = "page"];
  optional int32 page_size = 3 [json_name = "pageSize"];
  optional bool no_paging = 4 [json_name = "noPaging"];
  optional string query = 5 [json_name = "query"];
  repeated string order_by = 6 [json_name = "orderBy"];
  optional string field_mask = 7 [json_name = "fieldMask"];

  // Filter by subnet
  optional string subnet_id = 10 [json_name = "subnetId"];

  // Filter by device
  optional string device_id = 11 [json_name = "deviceId"];

  // Filter by status
  optional IpAddressStatus status = 12 [json_name = "status"];

  // Filter by address type
  optional IpAddressType address_type = 13 [json_name = "addressType"];

  // Search by address prefix
  optional string address_prefix = 14 [json_name = "addressPrefix"];

  // Search by hostname
  optional string hostname_pattern = 15 [json_name = "hostnamePattern"];
}

message ListIpAddressesResponse {
  repeated IpAddress items = 1 [json_name = "items"];
  optional int32 total = 2 [json_name = "total"];
}

// UpdateIpAddressRequest updates an IP address
message UpdateIpAddressRequest {
  string id = 1 [
    json_name = "id",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];

  optional IpAddress data = 2 [json_name = "data"];

  google.protobuf.FieldMask update_mask = 3 [json_name = "updateMask"];
}

message UpdateIpAddressResponse {
  IpAddress ip_address = 1 [json_name = "ipAddress"];
}

// DeleteIpAddressRequest deletes an IP address
message DeleteIpAddressRequest {
  string id = 1 [
    json_name = "id",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];
}

// AllocateNextAddressRequest allocates the next available address in a subnet
message AllocateNextAddressRequest {
  optional uint32 tenant_id = 1 [
    json_name = "tenantId",
    (google.api.field_behavior) = REQUIRED
  ];

  string subnet_id = 2 [
    json_name = "subnetId",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];

  optional string hostname = 3 [json_name = "hostname"];
  optional string description = 4 [json_name = "description"];
  optional string device_id = 5 [json_name = "deviceId"];
  optional IpAddressStatus status = 6 [json_name = "status"];
  optional string owner = 7 [json_name = "owner"];

  // Skip these addresses (already reserved externally)
  repeated string skip_addresses = 10 [json_name = "skipAddresses"];

  // Start from this address
  optional string start_from = 11 [json_name = "startFrom"];
}

message AllocateNextAddressResponse {
  IpAddress ip_address = 1 [json_name = "ipAddress"];
}

// BulkAllocateAddressesRequest allocates multiple addresses
message BulkAllocateAddressesRequest {
  optional uint32 tenant_id = 1 [json_name = "tenantId"];
  string subnet_id = 2 [json_name = "subnetId"];
  int32 count = 3 [json_name = "count"];
  optional string hostname_prefix = 4 [json_name = "hostnamePrefix"];
  optional IpAddressStatus status = 5 [json_name = "status"];
}

message BulkAllocateAddressesResponse {
  repeated IpAddress ip_addresses = 1 [json_name = "ipAddresses"];
}

// FindAddressRequest finds an address by IP
message FindAddressRequest {
  optional uint32 tenant_id = 1 [json_name = "tenantId"];

  string address = 2 [
    json_name = "address",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];
}

message FindAddressResponse {
  IpAddress ip_address = 1 [json_name = "ipAddress"];
}

// PingAddressRequest checks if an address is reachable
message PingAddressRequest {
  string id = 1 [json_name = "id"];
}

message PingAddressResponse {
  bool reachable = 1 [json_name = "reachable"];
  optional int32 latency_ms = 2 [json_name = "latencyMs"];
  optional google.protobuf.Timestamp checked_at = 3 [json_name = "checkedAt"];
}

// IpAddressService manages IP addresses
service IpAddressService {
  // Create a new IP address
  rpc CreateIpAddress(CreateIpAddressRequest) returns (CreateIpAddressResponse) {
    option (google.api.http) = {
      post: "/v1/ip-addresses"
      body: "*"
    };
  }

  // Get an IP address by ID
  rpc GetIpAddress(GetIpAddressRequest) returns (GetIpAddressResponse) {
    option (google.api.http) = {
      get: "/v1/ip-addresses/{id}"
    };
  }

  // List IP addresses with filtering
  rpc ListIpAddresses(ListIpAddressesRequest) returns (ListIpAddressesResponse) {
    option (google.api.http) = {
      get: "/v1/ip-addresses"
    };
  }

  // Update an IP address
  rpc UpdateIpAddress(UpdateIpAddressRequest) returns (UpdateIpAddressResponse) {
    option (google.api.http) = {
      put: "/v1/ip-addresses/{id}"
      body: "*"
    };
  }

  // Delete an IP address
  rpc DeleteIpAddress(DeleteIpAddressRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/ip-addresses/{id}"
    };
  }

  // Allocate the next available address in a subnet
  rpc AllocateNextAddress(AllocateNextAddressRequest) returns (AllocateNextAddressResponse) {
    option (google.api.http) = {
      post: "/v1/ip-addresses/allocate"
      body: "*"
    };
  }

  // Bulk allocate multiple addresses
  rpc BulkAllocateAddresses(BulkAllocateAddressesRequest) returns (BulkAllocateAddressesResponse) {
    option (google.api.http) = {
      post: "/v1/ip-addresses/bulk-allocate"
      body: "*"
    };
  }

  // Find an address by IP
  rpc FindAddress(FindAddressRequest) returns (FindAddressResponse) {
    option (google.api.http) = {
      get: "/v1/ip-addresses/find"
    };
  }

  // Ping an address to check reachability
  rpc PingAddress(PingAddressRequest) returns (PingAddressResponse) {
    option (google.api.http) = {
      post: "/v1/ip-addresses/{id}/ping"
    };
  }
}
