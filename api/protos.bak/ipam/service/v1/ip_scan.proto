syntax = "proto3";

package ipam.service.v1;

import "buf/validate/validate.proto";
import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "ipam/service/v1/subnet.proto";

// IpScanJobStatus represents the status of a scan job
enum IpScanJobStatus {
  IP_SCAN_JOB_STATUS_UNSPECIFIED = 0;
  IP_SCAN_JOB_STATUS_PENDING = 1;
  IP_SCAN_JOB_STATUS_SCANNING = 2;
  IP_SCAN_JOB_STATUS_COMPLETED = 3;
  IP_SCAN_JOB_STATUS_FAILED = 4;
  IP_SCAN_JOB_STATUS_CANCELLED = 5;
}

// IpScanJobTrigger represents how the scan was triggered
enum IpScanJobTrigger {
  IP_SCAN_JOB_TRIGGER_UNSPECIFIED = 0;
  IP_SCAN_JOB_TRIGGER_AUTO = 1;
  IP_SCAN_JOB_TRIGGER_MANUAL = 2;
}

// IpScanJob represents a network scan job for discovering IP addresses
message IpScanJob {
  // Unique identifier
  optional string id = 1 [json_name = "id"];

  // Tenant ID for multi-tenancy
  optional uint32 tenant_id = 2 [json_name = "tenantId"];

  // Subnet ID to scan
  optional string subnet_id = 3 [json_name = "subnetId"];

  // Job status
  optional IpScanJobStatus status = 4 [json_name = "status"];

  // Progress percentage (0-100)
  optional int32 progress = 5 [json_name = "progress"];

  // Status message or error description
  optional string status_message = 6 [json_name = "statusMessage"];

  // Total number of addresses to scan
  optional int64 total_addresses = 7 [json_name = "totalAddresses"];

  // Number of addresses scanned so far
  optional int64 scanned_count = 8 [json_name = "scannedCount"];

  // Number of addresses that responded
  optional int64 alive_count = 9 [json_name = "aliveCount"];

  // Number of newly discovered addresses
  optional int64 new_count = 10 [json_name = "newCount"];

  // Number of existing addresses updated
  optional int64 updated_count = 11 [json_name = "updatedCount"];

  // How the scan was triggered
  optional IpScanJobTrigger triggered_by = 12 [json_name = "triggeredBy"];

  // Number of retry attempts
  optional int32 retry_count = 13 [json_name = "retryCount"];

  // Maximum number of retry attempts
  optional int32 max_retries = 14 [json_name = "maxRetries"];

  // TCP probe timeout in milliseconds
  optional int32 timeout_ms = 20 [json_name = "timeoutMs"];

  // Number of parallel probes
  optional int32 concurrency = 21 [json_name = "concurrency"];

  // Skip reverse DNS lookup
  optional bool skip_reverse_dns = 22 [json_name = "skipReverseDns"];

  // Comma-separated list of TCP ports to probe
  optional string tcp_probe_ports = 23 [json_name = "tcpProbePorts"];

  // When the scan started
  optional google.protobuf.Timestamp started_at = 30 [json_name = "startedAt"];

  // When the scan completed
  optional google.protobuf.Timestamp completed_at = 31 [json_name = "completedAt"];

  // Creation timestamp
  optional google.protobuf.Timestamp created_at = 32 [json_name = "createdAt"];

  // Last update timestamp
  optional google.protobuf.Timestamp updated_at = 33 [json_name = "updatedAt"];

  // Creator user ID
  optional uint32 created_by = 34 [json_name = "createdBy"];
}

// StartScanRequest starts a new scan for a subnet
message StartScanRequest {
  optional uint32 tenant_id = 1 [
    json_name = "tenantId",
    (google.api.field_behavior) = REQUIRED
  ];

  string subnet_id = 2 [
    json_name = "subnetId",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];

  // Scan configuration
  optional ScanConfig scan_config = 3 [json_name = "scanConfig"];
}

message StartScanResponse {
  IpScanJob job = 1 [json_name = "job"];
}

// GetScanJobRequest retrieves a scan job by ID
message GetScanJobRequest {
  string id = 1 [
    json_name = "id",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];
}

message GetScanJobResponse {
  IpScanJob job = 1 [json_name = "job"];
}

// ListScanJobsRequest lists scan jobs for a subnet
message ListScanJobsRequest {
  optional uint32 tenant_id = 1 [json_name = "tenantId"];
  optional int32 page = 2 [json_name = "page"];
  optional int32 page_size = 3 [json_name = "pageSize"];

  // Filter by subnet
  optional string subnet_id = 10 [json_name = "subnetId"];

  // Filter by status
  optional IpScanJobStatus status = 11 [json_name = "status"];
}

message ListScanJobsResponse {
  repeated IpScanJob items = 1 [json_name = "items"];
  optional int32 total = 2 [json_name = "total"];
}

// CancelScanRequest cancels a running or pending scan
message CancelScanRequest {
  string id = 1 [
    json_name = "id",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];
}

message CancelScanResponse {
  IpScanJob job = 1 [json_name = "job"];
}

// IpScanService manages IP address scanning
service IpScanService {
  // Start a new scan for a subnet
  rpc StartScan(StartScanRequest) returns (StartScanResponse) {
    option (google.api.http) = {
      post: "/v1/ip-scans"
      body: "*"
    };
  }

  // Get a scan job by ID
  rpc GetScanJob(GetScanJobRequest) returns (GetScanJobResponse) {
    option (google.api.http) = {
      get: "/v1/ip-scans/{id}"
    };
  }

  // List scan jobs
  rpc ListScanJobs(ListScanJobsRequest) returns (ListScanJobsResponse) {
    option (google.api.http) = {
      get: "/v1/ip-scans"
    };
  }

  // Cancel a running or pending scan
  rpc CancelScan(CancelScanRequest) returns (CancelScanResponse) {
    option (google.api.http) = {
      post: "/v1/ip-scans/{id}/cancel"
    };
  }
}
