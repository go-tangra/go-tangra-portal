syntax = "proto3";

package ipam.service.v1;

import "buf/validate/validate.proto";
import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/field_mask.proto";

// Subnet represents a network subnet (CIDR block)
message Subnet {
  // Unique identifier
  optional string id = 1 [json_name = "id"];

  // Tenant ID for multi-tenancy
  optional uint32 tenant_id = 2 [json_name = "tenantId"];

  // Human-readable name
  optional string name = 3 [json_name = "name"];

  // CIDR notation (e.g., "192.168.1.0/24")
  optional string cidr = 4 [json_name = "cidr"];

  // Optional description
  optional string description = 5 [json_name = "description"];

  // Gateway IP address
  optional string gateway = 6 [json_name = "gateway"];

  // DNS servers (comma-separated)
  optional string dns_servers = 7 [json_name = "dnsServers"];

  // Associated VLAN ID
  optional string vlan_id = 8 [json_name = "vlanId"];

  // Parent subnet ID (for hierarchical subnets)
  optional string parent_id = 9 [json_name = "parentId"];

  // Location/site ID
  optional string location_id = 10 [json_name = "locationId"];

  // Subnet status
  optional SubnetStatus status = 11 [json_name = "status"];

  // IP version (4 or 6)
  optional int32 ip_version = 12 [json_name = "ipVersion"];

  // Network address
  optional string network_address = 13 [json_name = "networkAddress"];

  // Broadcast address
  optional string broadcast_address = 14 [json_name = "broadcastAddress"];

  // Subnet mask
  optional string mask = 15 [json_name = "mask"];

  // Prefix length
  optional int32 prefix_length = 16 [json_name = "prefixLength"];

  // Total number of addresses
  optional int64 total_addresses = 17 [json_name = "totalAddresses"];

  // Number of used addresses
  optional int64 used_addresses = 18 [json_name = "usedAddresses"];

  // Number of available addresses
  optional int64 available_addresses = 19 [json_name = "availableAddresses"];

  // Utilization percentage
  optional double utilization = 20 [json_name = "utilization"];

  // Custom tags (JSON)
  optional string tags = 21 [json_name = "tags"];

  // Custom metadata (JSON)
  optional string metadata = 22 [json_name = "metadata"];

  // Creation timestamp
  optional google.protobuf.Timestamp created_at = 30 [json_name = "createdAt"];

  // Last update timestamp
  optional google.protobuf.Timestamp updated_at = 31 [json_name = "updatedAt"];

  // Creator user ID
  optional uint32 created_by = 32 [json_name = "createdBy"];

  // Last updater user ID
  optional uint32 updated_by = 33 [json_name = "updatedBy"];
}

enum SubnetStatus {
  SUBNET_STATUS_UNSPECIFIED = 0;
  SUBNET_STATUS_ACTIVE = 1;
  SUBNET_STATUS_RESERVED = 2;
  SUBNET_STATUS_DEPRECATED = 3;
  SUBNET_STATUS_DELETED = 4;
}

// ScanConfig configures how subnet scanning is performed
message ScanConfig {
  // TCP probe timeout in milliseconds (default: 1000)
  optional int32 timeout_ms = 1 [json_name = "timeoutMs"];

  // Number of parallel probes (default: 50)
  optional int32 concurrency = 2 [json_name = "concurrency"];

  // Skip reverse DNS lookup (default: false)
  optional bool skip_reverse_dns = 3 [json_name = "skipReverseDns"];

  // Comma-separated list of TCP ports to probe (default: "22,80,443,3389,445")
  optional string tcp_probe_ports = 4 [json_name = "tcpProbePorts"];
}

// CreateSubnetRequest creates a new subnet
message CreateSubnetRequest {
  optional uint32 tenant_id = 1 [
    json_name = "tenantId",
    (google.api.field_behavior) = REQUIRED
  ];

  optional string name = 2 [
    json_name = "name",
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 255,
    (google.api.field_behavior) = REQUIRED
  ];

  optional string cidr = 3 [
    json_name = "cidr",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];

  optional string description = 4 [json_name = "description"];
  optional string gateway = 5 [json_name = "gateway"];
  optional string dns_servers = 6 [json_name = "dnsServers"];
  optional string vlan_id = 7 [json_name = "vlanId"];
  optional string parent_id = 8 [json_name = "parentId"];
  optional string location_id = 9 [json_name = "locationId"];
  optional SubnetStatus status = 10 [json_name = "status"];
  optional string tags = 11 [json_name = "tags"];
  optional string metadata = 12 [json_name = "metadata"];

  // Auto-scan the subnet for active hosts after creation
  optional bool auto_scan = 20 [json_name = "autoScan"];

  // Scan configuration (used when auto_scan is true)
  optional ScanConfig scan_config = 21 [json_name = "scanConfig"];
}

message CreateSubnetResponse {
  Subnet subnet = 1 [json_name = "subnet"];
}

// GetSubnetRequest retrieves a subnet by ID
message GetSubnetRequest {
  string id = 1 [
    json_name = "id",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];
}

message GetSubnetResponse {
  Subnet subnet = 1 [json_name = "subnet"];
}

// ListSubnetsRequest lists subnets with filtering
message ListSubnetsRequest {
  optional uint32 tenant_id = 1 [json_name = "tenantId"];
  optional int32 page = 2 [json_name = "page"];
  optional int32 page_size = 3 [json_name = "pageSize"];
  optional bool no_paging = 4 [json_name = "noPaging"];
  optional string query = 5 [json_name = "query"];
  repeated string order_by = 6 [json_name = "orderBy"];
  optional string field_mask = 7 [json_name = "fieldMask"];

  // Filter by VLAN
  optional string vlan_id = 10 [json_name = "vlanId"];

  // Filter by parent subnet
  optional string parent_id = 11 [json_name = "parentId"];

  // Filter by location
  optional string location_id = 12 [json_name = "locationId"];

  // Filter by status
  optional SubnetStatus status = 13 [json_name = "status"];

  // Filter by IP version
  optional int32 ip_version = 14 [json_name = "ipVersion"];
}

message ListSubnetsResponse {
  repeated Subnet items = 1 [json_name = "items"];
  optional int32 total = 2 [json_name = "total"];
}

// UpdateSubnetRequest updates a subnet
message UpdateSubnetRequest {
  string id = 1 [
    json_name = "id",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];

  optional Subnet data = 2 [json_name = "data"];

  google.protobuf.FieldMask update_mask = 3 [json_name = "updateMask"];
}

message UpdateSubnetResponse {
  Subnet subnet = 1 [json_name = "subnet"];
}

// DeleteSubnetRequest deletes a subnet
message DeleteSubnetRequest {
  string id = 1 [
    json_name = "id",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];

  // Force delete even if subnet has addresses
  optional bool force = 2 [json_name = "force"];
}

// GetSubnetTreeRequest retrieves subnet hierarchy
message GetSubnetTreeRequest {
  optional uint32 tenant_id = 1 [json_name = "tenantId"];
  optional string root_id = 2 [json_name = "rootId"];
  optional int32 max_depth = 3 [json_name = "maxDepth"];
  optional bool include_stats = 4 [json_name = "includeStats"];
}

message SubnetTreeNode {
  Subnet subnet = 1 [json_name = "subnet"];
  repeated SubnetTreeNode children = 2 [json_name = "children"];
}

message GetSubnetTreeResponse {
  repeated SubnetTreeNode nodes = 1 [json_name = "nodes"];
}

// GetSubnetStatsRequest gets utilization statistics
message GetSubnetStatsRequest {
  string id = 1 [
    json_name = "id",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];
}

message GetSubnetStatsResponse {
  int64 total_addresses = 1 [json_name = "totalAddresses"];
  int64 used_addresses = 2 [json_name = "usedAddresses"];
  int64 available_addresses = 3 [json_name = "availableAddresses"];
  int64 reserved_addresses = 4 [json_name = "reservedAddresses"];
  double utilization = 5 [json_name = "utilization"];
}

// ScanSubnetRequest scans a subnet for active hosts
message ScanSubnetRequest {
  string id = 1 [
    json_name = "id",
    (buf.validate.field).string.min_len = 1,
    (google.api.field_behavior) = REQUIRED
  ];
}

message ScanSubnetResponse {
  repeated string discovered_addresses = 1 [json_name = "discoveredAddresses"];
  int32 new_addresses = 2 [json_name = "newAddresses"];
}

// SubnetService manages network subnets
service SubnetService {
  // Create a new subnet
  rpc CreateSubnet(CreateSubnetRequest) returns (CreateSubnetResponse) {
    option (google.api.http) = {
      post: "/v1/subnets"
      body: "*"
    };
  }

  // Get a subnet by ID
  rpc GetSubnet(GetSubnetRequest) returns (GetSubnetResponse) {
    option (google.api.http) = {
      get: "/v1/subnets/{id}"
    };
  }

  // List subnets with filtering
  rpc ListSubnets(ListSubnetsRequest) returns (ListSubnetsResponse) {
    option (google.api.http) = {
      get: "/v1/subnets"
    };
  }

  // Update a subnet
  rpc UpdateSubnet(UpdateSubnetRequest) returns (UpdateSubnetResponse) {
    option (google.api.http) = {
      put: "/v1/subnets/{id}"
      body: "*"
    };
  }

  // Delete a subnet
  rpc DeleteSubnet(DeleteSubnetRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/subnets/{id}"
    };
  }

  // Get subnet tree hierarchy
  rpc GetSubnetTree(GetSubnetTreeRequest) returns (GetSubnetTreeResponse) {
    option (google.api.http) = {
      get: "/v1/subnets/tree"
    };
  }

  // Get subnet utilization statistics
  rpc GetSubnetStats(GetSubnetStatsRequest) returns (GetSubnetStatsResponse) {
    option (google.api.http) = {
      get: "/v1/subnets/{id}/stats"
    };
  }

  // Scan subnet for active hosts
  rpc ScanSubnet(ScanSubnetRequest) returns (ScanSubnetResponse) {
    option (google.api.http) = {
      post: "/v1/subnets/{id}/scan"
    };
  }
}
