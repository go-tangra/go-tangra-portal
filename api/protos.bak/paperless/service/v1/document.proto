syntax = "proto3";

package paperless.service.v1;

import "buf/validate/validate.proto";
import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "redact/v3/redact.proto";

// Document Service - manages documents with RustFS storage integration
service PaperlessDocumentService {
  // Create a new document (upload)
  rpc CreateDocument(CreateDocumentRequest) returns (CreateDocumentResponse) {
    option (google.api.http) = {
      post: "/v1/documents"
      body: "*"
    };
  }

  // Get a document by ID (metadata only)
  rpc GetDocument(GetDocumentRequest) returns (GetDocumentResponse) {
    option (google.api.http) = {get: "/v1/documents/{id}"};
  }

  // List documents in a category
  rpc ListDocuments(ListDocumentsRequest) returns (ListDocumentsResponse) {
    option (google.api.http) = {get: "/v1/documents"};
  }

  // Update document metadata
  rpc UpdateDocument(UpdateDocumentRequest) returns (UpdateDocumentResponse) {
    option (google.api.http) = {
      put: "/v1/documents/{id}"
      body: "*"
    };
  }

  // Delete a document
  rpc DeleteDocument(DeleteDocumentRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {delete: "/v1/documents/{id}"};
  }

  // Move document to a different category
  rpc MoveDocument(MoveDocumentRequest) returns (MoveDocumentResponse) {
    option (google.api.http) = {
      post: "/v1/documents/{id}/move"
      body: "*"
    };
  }

  // Download document content
  rpc DownloadDocument(DownloadDocumentRequest) returns (DownloadDocumentResponse) {
    option (google.api.http) = {get: "/v1/documents/{id}/download"};
  }

  // Get document download URL (presigned URL)
  rpc GetDocumentDownloadUrl(GetDocumentDownloadUrlRequest) returns (GetDocumentDownloadUrlResponse) {
    option (google.api.http) = {get: "/v1/documents/{id}/download-url"};
  }

  // Search documents across categories
  rpc SearchDocuments(SearchDocumentsRequest) returns (SearchDocumentsResponse) {
    option (google.api.http) = {get: "/v1/documents/search"};
  }

  // Batch delete documents
  rpc BatchDeleteDocuments(BatchDeleteDocumentsRequest) returns (BatchDeleteDocumentsResponse) {
    option (google.api.http) = {
      post: "/v1/documents/batch-delete"
      body: "*"
    };
  }
}

// Document status
enum DocumentStatus {
  DOCUMENT_STATUS_UNSPECIFIED = 0;
  DOCUMENT_STATUS_ACTIVE = 1;
  DOCUMENT_STATUS_ARCHIVED = 2;
  DOCUMENT_STATUS_DELETED = 3;
}

// Document source - where the document originated from
enum DocumentSource {
  DOCUMENT_SOURCE_UNSPECIFIED = 0;
  DOCUMENT_SOURCE_UPLOAD = 1; // Uploaded manually by user
  DOCUMENT_SOURCE_EMAIL = 2; // Received via email
}

// Document entity
message Document {
  string id = 1 [json_name = "id"];
  uint32 tenant_id = 2 [json_name = "tenantId"];
  optional string category_id = 3 [json_name = "categoryId"];
  string category_path = 4 [json_name = "categoryPath"];
  string name = 5 [json_name = "name"];
  string description = 6 [json_name = "description"];
  string file_key = 7 [json_name = "fileKey"];
  string file_name = 8 [json_name = "fileName"];
  int64 file_size = 9 [json_name = "fileSize"];
  string mime_type = 10 [json_name = "mimeType"];
  string checksum = 11 [json_name = "checksum"];
  DocumentStatus status = 12 [json_name = "status"];
  DocumentSource source = 13 [json_name = "source"];
  map<string, string> tags = 14 [json_name = "tags"];
  google.protobuf.Timestamp create_time = 15 [json_name = "createTime"];
  google.protobuf.Timestamp update_time = 16 [json_name = "updateTime"];
  optional uint32 created_by = 17 [json_name = "createdBy"];
  optional uint32 updated_by = 18 [json_name = "updatedBy"];
}

// Request to create a document
message CreateDocumentRequest {
  // Category ID (null for root-level)
  optional string category_id = 1 [
    json_name = "categoryId",
    (buf.validate.field).string = {
      max_len: 36
      pattern: "^[a-fA-F0-9\\-]*$"
    }
  ];

  // Document name (display name)
  string name = 2 [
    json_name = "name",
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {
      min_len: 1
      max_len: 255
    }
  ];

  // Description
  string description = 3 [
    json_name = "description",
    (buf.validate.field).string = {max_len: 4096}
  ];

  // Original file name
  string file_name = 4 [
    json_name = "fileName",
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {
      min_len: 1
      max_len: 255
    }
  ];

  // File content (base64 encoded for non-streaming)
  bytes file_content = 5 [
    json_name = "fileContent",
    (google.api.field_behavior) = REQUIRED,
    (redact.v3.value).bytes = "FILE CONTENT"
  ];

  // MIME type (optional - will be detected if not provided)
  string mime_type = 6 [
    json_name = "mimeType",
    (buf.validate.field).string = {max_len: 255}
  ];

  // Custom tags
  map<string, string> tags = 7 [json_name = "tags"];

  // Document source (default: UPLOAD)
  DocumentSource source = 8 [json_name = "source"];
}

message CreateDocumentResponse {
  Document document = 1 [json_name = "document"];
}

// Request to get a document
message GetDocumentRequest {
  string id = 1 [
    json_name = "id",
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {
      min_len: 1
      max_len: 36
      pattern: "^[a-fA-F0-9\\-]+$"
    }
  ];
}

message GetDocumentResponse {
  Document document = 1 [json_name = "document"];
}

// Request to list documents
message ListDocumentsRequest {
  // Category ID (null for root-level documents)
  optional string category_id = 1 [
    json_name = "categoryId",
    (buf.validate.field).string = {
      max_len: 36
      pattern: "^[a-fA-F0-9\\-]*$"
    }
  ];

  // Pagination
  optional uint32 page = 2 [json_name = "page"];
  optional uint32 page_size = 3 [json_name = "pageSize"];

  // Filter by status
  optional DocumentStatus status = 4 [json_name = "status"];

  // Filter by name
  optional string name_filter = 5 [json_name = "nameFilter"];

  // Filter by MIME type
  optional string mime_type_filter = 6 [json_name = "mimeTypeFilter"];

  // Include subcategories
  bool include_subcategories = 7 [json_name = "includeSubcategories"];
}

message ListDocumentsResponse {
  repeated Document documents = 1 [json_name = "documents"];
  uint32 total = 2 [json_name = "total"];
}

// Request to update document metadata
message UpdateDocumentRequest {
  string id = 1 [
    json_name = "id",
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {
      min_len: 1
      max_len: 36
      pattern: "^[a-fA-F0-9\\-]+$"
    }
  ];

  // New name
  optional string name = 2 [
    json_name = "name",
    (buf.validate.field).string = {
      min_len: 1
      max_len: 255
    }
  ];

  // New description
  optional string description = 3 [
    json_name = "description",
    (buf.validate.field).string = {max_len: 4096}
  ];

  // New status
  optional DocumentStatus status = 4 [json_name = "status"];

  // New tags (replaces existing)
  map<string, string> tags = 5 [json_name = "tags"];

  // Whether to update tags (if false, tags field is ignored)
  bool update_tags = 6 [json_name = "updateTags"];
}

message UpdateDocumentResponse {
  Document document = 1 [json_name = "document"];
}

// Request to delete a document
message DeleteDocumentRequest {
  string id = 1 [
    json_name = "id",
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {
      min_len: 1
      max_len: 36
      pattern: "^[a-fA-F0-9\\-]+$"
    }
  ];

  // Permanently delete (skip soft-delete and remove from storage)
  bool permanent = 2 [json_name = "permanent"];
}

// Request to move a document
message MoveDocumentRequest {
  string id = 1 [
    json_name = "id",
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {
      min_len: 1
      max_len: 36
      pattern: "^[a-fA-F0-9\\-]+$"
    }
  ];

  // New category ID (null to move to root)
  optional string new_category_id = 2 [
    json_name = "newCategoryId",
    (buf.validate.field).string = {
      max_len: 36
      pattern: "^[a-fA-F0-9\\-]*$"
    }
  ];
}

message MoveDocumentResponse {
  Document document = 1 [json_name = "document"];
}

// Request to download document content
message DownloadDocumentRequest {
  string id = 1 [
    json_name = "id",
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {
      min_len: 1
      max_len: 36
      pattern: "^[a-fA-F0-9\\-]+$"
    }
  ];
}

message DownloadDocumentResponse {
  // File content
  bytes content = 1 [json_name = "content"];
  // Original file name
  string file_name = 2 [json_name = "fileName"];
  // MIME type
  string mime_type = 3 [json_name = "mimeType"];
  // File size
  int64 file_size = 4 [json_name = "fileSize"];
}

// Request to get document download URL
message GetDocumentDownloadUrlRequest {
  string id = 1 [
    json_name = "id",
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {
      min_len: 1
      max_len: 36
      pattern: "^[a-fA-F0-9\\-]+$"
    }
  ];

  // URL expiration in seconds (default 3600)
  optional int32 expires_in = 2 [json_name = "expiresIn"];
}

message GetDocumentDownloadUrlResponse {
  string url = 1 [json_name = "url"];
  google.protobuf.Timestamp expires_at = 2 [json_name = "expiresAt"];
}

// Request to search documents
message SearchDocumentsRequest {
  // Search query (searches name, description, file_name)
  string query = 1 [
    json_name = "query",
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {
      min_len: 1
      max_len: 255
    }
  ];

  // Limit search to category and subcategories (null for all)
  optional string category_id = 2 [
    json_name = "categoryId",
    (buf.validate.field).string = {
      max_len: 36
      pattern: "^[a-fA-F0-9\\-]*$"
    }
  ];

  // Include subcategories in search
  bool include_subcategories = 3 [json_name = "includeSubcategories"];

  // Pagination
  optional uint32 page = 4 [json_name = "page"];
  optional uint32 page_size = 5 [json_name = "pageSize"];

  // Filter by status
  optional DocumentStatus status = 6 [json_name = "status"];

  // Filter by MIME type
  optional string mime_type_filter = 7 [json_name = "mimeTypeFilter"];

  // Filter by tags (all tags must match)
  map<string, string> tags = 8 [json_name = "tags"];
}

message SearchDocumentsResponse {
  repeated Document documents = 1 [json_name = "documents"];
  uint32 total = 2 [json_name = "total"];
}

// Request to batch delete documents
message BatchDeleteDocumentsRequest {
  repeated string ids = 1 [
    json_name = "ids",
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).repeated = {
      min_items: 1
      max_items: 100
    }
  ];

  // Permanently delete (skip soft-delete and remove from storage)
  bool permanent = 2 [json_name = "permanent"];
}

message BatchDeleteDocumentsResponse {
  // Number of documents successfully deleted
  uint32 deleted_count = 1 [json_name = "deletedCount"];
  // IDs that failed to delete
  repeated string failed_ids = 2 [json_name = "failedIds"];
}
