// Code generated by ent, DO NOT EDIT.

package gen

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/go-tangra/go-tangra-portal/app/deployer/service/internal/data/ent/gen/migrate"

	"github.com/go-tangra/go-tangra-portal/app/deployer/service/internal/data/ent/gen/deploymenthistory"
	"github.com/go-tangra/go-tangra-portal/app/deployer/service/internal/data/ent/gen/deploymentjob"
	"github.com/go-tangra/go-tangra-portal/app/deployer/service/internal/data/ent/gen/deploymenttarget"
	"github.com/go-tangra/go-tangra-portal/app/deployer/service/internal/data/ent/gen/targetconfiguration"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// DeploymentHistory is the client for interacting with the DeploymentHistory builders.
	DeploymentHistory *DeploymentHistoryClient
	// DeploymentJob is the client for interacting with the DeploymentJob builders.
	DeploymentJob *DeploymentJobClient
	// DeploymentTarget is the client for interacting with the DeploymentTarget builders.
	DeploymentTarget *DeploymentTargetClient
	// TargetConfiguration is the client for interacting with the TargetConfiguration builders.
	TargetConfiguration *TargetConfigurationClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.DeploymentHistory = NewDeploymentHistoryClient(c.config)
	c.DeploymentJob = NewDeploymentJobClient(c.config)
	c.DeploymentTarget = NewDeploymentTargetClient(c.config)
	c.TargetConfiguration = NewTargetConfigurationClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("gen: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("gen: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		DeploymentHistory:   NewDeploymentHistoryClient(cfg),
		DeploymentJob:       NewDeploymentJobClient(cfg),
		DeploymentTarget:    NewDeploymentTargetClient(cfg),
		TargetConfiguration: NewTargetConfigurationClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		DeploymentHistory:   NewDeploymentHistoryClient(cfg),
		DeploymentJob:       NewDeploymentJobClient(cfg),
		DeploymentTarget:    NewDeploymentTargetClient(cfg),
		TargetConfiguration: NewTargetConfigurationClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		DeploymentHistory.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.DeploymentHistory.Use(hooks...)
	c.DeploymentJob.Use(hooks...)
	c.DeploymentTarget.Use(hooks...)
	c.TargetConfiguration.Use(hooks...)
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	c.DeploymentHistory.Intercept(interceptors...)
	c.DeploymentJob.Intercept(interceptors...)
	c.DeploymentTarget.Intercept(interceptors...)
	c.TargetConfiguration.Intercept(interceptors...)
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *DeploymentHistoryMutation:
		return c.DeploymentHistory.mutate(ctx, m)
	case *DeploymentJobMutation:
		return c.DeploymentJob.mutate(ctx, m)
	case *DeploymentTargetMutation:
		return c.DeploymentTarget.mutate(ctx, m)
	case *TargetConfigurationMutation:
		return c.TargetConfiguration.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("gen: unknown mutation type %T", m)
	}
}

// DeploymentHistoryClient is a client for the DeploymentHistory schema.
type DeploymentHistoryClient struct {
	config
}

// NewDeploymentHistoryClient returns a client for the DeploymentHistory from the given config.
func NewDeploymentHistoryClient(c config) *DeploymentHistoryClient {
	return &DeploymentHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `deploymenthistory.Hooks(f(g(h())))`.
func (c *DeploymentHistoryClient) Use(hooks ...Hook) {
	c.hooks.DeploymentHistory = append(c.hooks.DeploymentHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `deploymenthistory.Intercept(f(g(h())))`.
func (c *DeploymentHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeploymentHistory = append(c.inters.DeploymentHistory, interceptors...)
}

// Create returns a builder for creating a DeploymentHistory entity.
func (c *DeploymentHistoryClient) Create() *DeploymentHistoryCreate {
	mutation := newDeploymentHistoryMutation(c.config, OpCreate)
	return &DeploymentHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeploymentHistory entities.
func (c *DeploymentHistoryClient) CreateBulk(builders ...*DeploymentHistoryCreate) *DeploymentHistoryCreateBulk {
	return &DeploymentHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeploymentHistoryClient) MapCreateBulk(slice any, setFunc func(*DeploymentHistoryCreate, int)) *DeploymentHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeploymentHistoryCreateBulk{err: fmt.Errorf("calling to DeploymentHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeploymentHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeploymentHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeploymentHistory.
func (c *DeploymentHistoryClient) Update() *DeploymentHistoryUpdate {
	mutation := newDeploymentHistoryMutation(c.config, OpUpdate)
	return &DeploymentHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeploymentHistoryClient) UpdateOne(_m *DeploymentHistory) *DeploymentHistoryUpdateOne {
	mutation := newDeploymentHistoryMutation(c.config, OpUpdateOne, withDeploymentHistory(_m))
	return &DeploymentHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeploymentHistoryClient) UpdateOneID(id uint32) *DeploymentHistoryUpdateOne {
	mutation := newDeploymentHistoryMutation(c.config, OpUpdateOne, withDeploymentHistoryID(id))
	return &DeploymentHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeploymentHistory.
func (c *DeploymentHistoryClient) Delete() *DeploymentHistoryDelete {
	mutation := newDeploymentHistoryMutation(c.config, OpDelete)
	return &DeploymentHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeploymentHistoryClient) DeleteOne(_m *DeploymentHistory) *DeploymentHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeploymentHistoryClient) DeleteOneID(id uint32) *DeploymentHistoryDeleteOne {
	builder := c.Delete().Where(deploymenthistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeploymentHistoryDeleteOne{builder}
}

// Query returns a query builder for DeploymentHistory.
func (c *DeploymentHistoryClient) Query() *DeploymentHistoryQuery {
	return &DeploymentHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeploymentHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a DeploymentHistory entity by its id.
func (c *DeploymentHistoryClient) Get(ctx context.Context, id uint32) (*DeploymentHistory, error) {
	return c.Query().Where(deploymenthistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeploymentHistoryClient) GetX(ctx context.Context, id uint32) *DeploymentHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryJob queries the job edge of a DeploymentHistory.
func (c *DeploymentHistoryClient) QueryJob(_m *DeploymentHistory) *DeploymentJobQuery {
	query := (&DeploymentJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deploymenthistory.Table, deploymenthistory.FieldID, id),
			sqlgraph.To(deploymentjob.Table, deploymentjob.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, deploymenthistory.JobTable, deploymenthistory.JobColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeploymentHistoryClient) Hooks() []Hook {
	return c.hooks.DeploymentHistory
}

// Interceptors returns the client interceptors.
func (c *DeploymentHistoryClient) Interceptors() []Interceptor {
	return c.inters.DeploymentHistory
}

func (c *DeploymentHistoryClient) mutate(ctx context.Context, m *DeploymentHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeploymentHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeploymentHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeploymentHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeploymentHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("gen: unknown DeploymentHistory mutation op: %q", m.Op())
	}
}

// DeploymentJobClient is a client for the DeploymentJob schema.
type DeploymentJobClient struct {
	config
}

// NewDeploymentJobClient returns a client for the DeploymentJob from the given config.
func NewDeploymentJobClient(c config) *DeploymentJobClient {
	return &DeploymentJobClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `deploymentjob.Hooks(f(g(h())))`.
func (c *DeploymentJobClient) Use(hooks ...Hook) {
	c.hooks.DeploymentJob = append(c.hooks.DeploymentJob, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `deploymentjob.Intercept(f(g(h())))`.
func (c *DeploymentJobClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeploymentJob = append(c.inters.DeploymentJob, interceptors...)
}

// Create returns a builder for creating a DeploymentJob entity.
func (c *DeploymentJobClient) Create() *DeploymentJobCreate {
	mutation := newDeploymentJobMutation(c.config, OpCreate)
	return &DeploymentJobCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeploymentJob entities.
func (c *DeploymentJobClient) CreateBulk(builders ...*DeploymentJobCreate) *DeploymentJobCreateBulk {
	return &DeploymentJobCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeploymentJobClient) MapCreateBulk(slice any, setFunc func(*DeploymentJobCreate, int)) *DeploymentJobCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeploymentJobCreateBulk{err: fmt.Errorf("calling to DeploymentJobClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeploymentJobCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeploymentJobCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeploymentJob.
func (c *DeploymentJobClient) Update() *DeploymentJobUpdate {
	mutation := newDeploymentJobMutation(c.config, OpUpdate)
	return &DeploymentJobUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeploymentJobClient) UpdateOne(_m *DeploymentJob) *DeploymentJobUpdateOne {
	mutation := newDeploymentJobMutation(c.config, OpUpdateOne, withDeploymentJob(_m))
	return &DeploymentJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeploymentJobClient) UpdateOneID(id string) *DeploymentJobUpdateOne {
	mutation := newDeploymentJobMutation(c.config, OpUpdateOne, withDeploymentJobID(id))
	return &DeploymentJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeploymentJob.
func (c *DeploymentJobClient) Delete() *DeploymentJobDelete {
	mutation := newDeploymentJobMutation(c.config, OpDelete)
	return &DeploymentJobDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeploymentJobClient) DeleteOne(_m *DeploymentJob) *DeploymentJobDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeploymentJobClient) DeleteOneID(id string) *DeploymentJobDeleteOne {
	builder := c.Delete().Where(deploymentjob.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeploymentJobDeleteOne{builder}
}

// Query returns a query builder for DeploymentJob.
func (c *DeploymentJobClient) Query() *DeploymentJobQuery {
	return &DeploymentJobQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeploymentJob},
		inters: c.Interceptors(),
	}
}

// Get returns a DeploymentJob entity by its id.
func (c *DeploymentJobClient) Get(ctx context.Context, id string) (*DeploymentJob, error) {
	return c.Query().Where(deploymentjob.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeploymentJobClient) GetX(ctx context.Context, id string) *DeploymentJob {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDeploymentTarget queries the deployment_target edge of a DeploymentJob.
func (c *DeploymentJobClient) QueryDeploymentTarget(_m *DeploymentJob) *DeploymentTargetQuery {
	query := (&DeploymentTargetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deploymentjob.Table, deploymentjob.FieldID, id),
			sqlgraph.To(deploymenttarget.Table, deploymenttarget.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, deploymentjob.DeploymentTargetTable, deploymentjob.DeploymentTargetColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTargetConfiguration queries the target_configuration edge of a DeploymentJob.
func (c *DeploymentJobClient) QueryTargetConfiguration(_m *DeploymentJob) *TargetConfigurationQuery {
	query := (&TargetConfigurationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deploymentjob.Table, deploymentjob.FieldID, id),
			sqlgraph.To(targetconfiguration.Table, targetconfiguration.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, deploymentjob.TargetConfigurationTable, deploymentjob.TargetConfigurationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentJob queries the parent_job edge of a DeploymentJob.
func (c *DeploymentJobClient) QueryParentJob(_m *DeploymentJob) *DeploymentJobQuery {
	query := (&DeploymentJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deploymentjob.Table, deploymentjob.FieldID, id),
			sqlgraph.To(deploymentjob.Table, deploymentjob.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, deploymentjob.ParentJobTable, deploymentjob.ParentJobColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildJobs queries the child_jobs edge of a DeploymentJob.
func (c *DeploymentJobClient) QueryChildJobs(_m *DeploymentJob) *DeploymentJobQuery {
	query := (&DeploymentJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deploymentjob.Table, deploymentjob.FieldID, id),
			sqlgraph.To(deploymentjob.Table, deploymentjob.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, deploymentjob.ChildJobsTable, deploymentjob.ChildJobsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHistory queries the history edge of a DeploymentJob.
func (c *DeploymentJobClient) QueryHistory(_m *DeploymentJob) *DeploymentHistoryQuery {
	query := (&DeploymentHistoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deploymentjob.Table, deploymentjob.FieldID, id),
			sqlgraph.To(deploymenthistory.Table, deploymenthistory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, deploymentjob.HistoryTable, deploymentjob.HistoryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeploymentJobClient) Hooks() []Hook {
	hooks := c.hooks.DeploymentJob
	return append(hooks[:len(hooks):len(hooks)], deploymentjob.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DeploymentJobClient) Interceptors() []Interceptor {
	return c.inters.DeploymentJob
}

func (c *DeploymentJobClient) mutate(ctx context.Context, m *DeploymentJobMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeploymentJobCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeploymentJobUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeploymentJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeploymentJobDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("gen: unknown DeploymentJob mutation op: %q", m.Op())
	}
}

// DeploymentTargetClient is a client for the DeploymentTarget schema.
type DeploymentTargetClient struct {
	config
}

// NewDeploymentTargetClient returns a client for the DeploymentTarget from the given config.
func NewDeploymentTargetClient(c config) *DeploymentTargetClient {
	return &DeploymentTargetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `deploymenttarget.Hooks(f(g(h())))`.
func (c *DeploymentTargetClient) Use(hooks ...Hook) {
	c.hooks.DeploymentTarget = append(c.hooks.DeploymentTarget, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `deploymenttarget.Intercept(f(g(h())))`.
func (c *DeploymentTargetClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeploymentTarget = append(c.inters.DeploymentTarget, interceptors...)
}

// Create returns a builder for creating a DeploymentTarget entity.
func (c *DeploymentTargetClient) Create() *DeploymentTargetCreate {
	mutation := newDeploymentTargetMutation(c.config, OpCreate)
	return &DeploymentTargetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeploymentTarget entities.
func (c *DeploymentTargetClient) CreateBulk(builders ...*DeploymentTargetCreate) *DeploymentTargetCreateBulk {
	return &DeploymentTargetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeploymentTargetClient) MapCreateBulk(slice any, setFunc func(*DeploymentTargetCreate, int)) *DeploymentTargetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeploymentTargetCreateBulk{err: fmt.Errorf("calling to DeploymentTargetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeploymentTargetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeploymentTargetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeploymentTarget.
func (c *DeploymentTargetClient) Update() *DeploymentTargetUpdate {
	mutation := newDeploymentTargetMutation(c.config, OpUpdate)
	return &DeploymentTargetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeploymentTargetClient) UpdateOne(_m *DeploymentTarget) *DeploymentTargetUpdateOne {
	mutation := newDeploymentTargetMutation(c.config, OpUpdateOne, withDeploymentTarget(_m))
	return &DeploymentTargetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeploymentTargetClient) UpdateOneID(id string) *DeploymentTargetUpdateOne {
	mutation := newDeploymentTargetMutation(c.config, OpUpdateOne, withDeploymentTargetID(id))
	return &DeploymentTargetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeploymentTarget.
func (c *DeploymentTargetClient) Delete() *DeploymentTargetDelete {
	mutation := newDeploymentTargetMutation(c.config, OpDelete)
	return &DeploymentTargetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeploymentTargetClient) DeleteOne(_m *DeploymentTarget) *DeploymentTargetDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeploymentTargetClient) DeleteOneID(id string) *DeploymentTargetDeleteOne {
	builder := c.Delete().Where(deploymenttarget.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeploymentTargetDeleteOne{builder}
}

// Query returns a query builder for DeploymentTarget.
func (c *DeploymentTargetClient) Query() *DeploymentTargetQuery {
	return &DeploymentTargetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeploymentTarget},
		inters: c.Interceptors(),
	}
}

// Get returns a DeploymentTarget entity by its id.
func (c *DeploymentTargetClient) Get(ctx context.Context, id string) (*DeploymentTarget, error) {
	return c.Query().Where(deploymenttarget.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeploymentTargetClient) GetX(ctx context.Context, id string) *DeploymentTarget {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryConfigurations queries the configurations edge of a DeploymentTarget.
func (c *DeploymentTargetClient) QueryConfigurations(_m *DeploymentTarget) *TargetConfigurationQuery {
	query := (&TargetConfigurationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deploymenttarget.Table, deploymenttarget.FieldID, id),
			sqlgraph.To(targetconfiguration.Table, targetconfiguration.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, deploymenttarget.ConfigurationsTable, deploymenttarget.ConfigurationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobs queries the jobs edge of a DeploymentTarget.
func (c *DeploymentTargetClient) QueryJobs(_m *DeploymentTarget) *DeploymentJobQuery {
	query := (&DeploymentJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deploymenttarget.Table, deploymenttarget.FieldID, id),
			sqlgraph.To(deploymentjob.Table, deploymentjob.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, deploymenttarget.JobsTable, deploymenttarget.JobsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeploymentTargetClient) Hooks() []Hook {
	hooks := c.hooks.DeploymentTarget
	return append(hooks[:len(hooks):len(hooks)], deploymenttarget.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DeploymentTargetClient) Interceptors() []Interceptor {
	return c.inters.DeploymentTarget
}

func (c *DeploymentTargetClient) mutate(ctx context.Context, m *DeploymentTargetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeploymentTargetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeploymentTargetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeploymentTargetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeploymentTargetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("gen: unknown DeploymentTarget mutation op: %q", m.Op())
	}
}

// TargetConfigurationClient is a client for the TargetConfiguration schema.
type TargetConfigurationClient struct {
	config
}

// NewTargetConfigurationClient returns a client for the TargetConfiguration from the given config.
func NewTargetConfigurationClient(c config) *TargetConfigurationClient {
	return &TargetConfigurationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `targetconfiguration.Hooks(f(g(h())))`.
func (c *TargetConfigurationClient) Use(hooks ...Hook) {
	c.hooks.TargetConfiguration = append(c.hooks.TargetConfiguration, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `targetconfiguration.Intercept(f(g(h())))`.
func (c *TargetConfigurationClient) Intercept(interceptors ...Interceptor) {
	c.inters.TargetConfiguration = append(c.inters.TargetConfiguration, interceptors...)
}

// Create returns a builder for creating a TargetConfiguration entity.
func (c *TargetConfigurationClient) Create() *TargetConfigurationCreate {
	mutation := newTargetConfigurationMutation(c.config, OpCreate)
	return &TargetConfigurationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TargetConfiguration entities.
func (c *TargetConfigurationClient) CreateBulk(builders ...*TargetConfigurationCreate) *TargetConfigurationCreateBulk {
	return &TargetConfigurationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TargetConfigurationClient) MapCreateBulk(slice any, setFunc func(*TargetConfigurationCreate, int)) *TargetConfigurationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TargetConfigurationCreateBulk{err: fmt.Errorf("calling to TargetConfigurationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TargetConfigurationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TargetConfigurationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TargetConfiguration.
func (c *TargetConfigurationClient) Update() *TargetConfigurationUpdate {
	mutation := newTargetConfigurationMutation(c.config, OpUpdate)
	return &TargetConfigurationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TargetConfigurationClient) UpdateOne(_m *TargetConfiguration) *TargetConfigurationUpdateOne {
	mutation := newTargetConfigurationMutation(c.config, OpUpdateOne, withTargetConfiguration(_m))
	return &TargetConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TargetConfigurationClient) UpdateOneID(id string) *TargetConfigurationUpdateOne {
	mutation := newTargetConfigurationMutation(c.config, OpUpdateOne, withTargetConfigurationID(id))
	return &TargetConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TargetConfiguration.
func (c *TargetConfigurationClient) Delete() *TargetConfigurationDelete {
	mutation := newTargetConfigurationMutation(c.config, OpDelete)
	return &TargetConfigurationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TargetConfigurationClient) DeleteOne(_m *TargetConfiguration) *TargetConfigurationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TargetConfigurationClient) DeleteOneID(id string) *TargetConfigurationDeleteOne {
	builder := c.Delete().Where(targetconfiguration.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TargetConfigurationDeleteOne{builder}
}

// Query returns a query builder for TargetConfiguration.
func (c *TargetConfigurationClient) Query() *TargetConfigurationQuery {
	return &TargetConfigurationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTargetConfiguration},
		inters: c.Interceptors(),
	}
}

// Get returns a TargetConfiguration entity by its id.
func (c *TargetConfigurationClient) Get(ctx context.Context, id string) (*TargetConfiguration, error) {
	return c.Query().Where(targetconfiguration.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TargetConfigurationClient) GetX(ctx context.Context, id string) *TargetConfiguration {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryJobs queries the jobs edge of a TargetConfiguration.
func (c *TargetConfigurationClient) QueryJobs(_m *TargetConfiguration) *DeploymentJobQuery {
	query := (&DeploymentJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(targetconfiguration.Table, targetconfiguration.FieldID, id),
			sqlgraph.To(deploymentjob.Table, deploymentjob.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, targetconfiguration.JobsTable, targetconfiguration.JobsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeploymentTargets queries the deployment_targets edge of a TargetConfiguration.
func (c *TargetConfigurationClient) QueryDeploymentTargets(_m *TargetConfiguration) *DeploymentTargetQuery {
	query := (&DeploymentTargetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(targetconfiguration.Table, targetconfiguration.FieldID, id),
			sqlgraph.To(deploymenttarget.Table, deploymenttarget.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, targetconfiguration.DeploymentTargetsTable, targetconfiguration.DeploymentTargetsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TargetConfigurationClient) Hooks() []Hook {
	hooks := c.hooks.TargetConfiguration
	return append(hooks[:len(hooks):len(hooks)], targetconfiguration.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TargetConfigurationClient) Interceptors() []Interceptor {
	return c.inters.TargetConfiguration
}

func (c *TargetConfigurationClient) mutate(ctx context.Context, m *TargetConfigurationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TargetConfigurationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TargetConfigurationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TargetConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TargetConfigurationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("gen: unknown TargetConfiguration mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		DeploymentHistory, DeploymentJob, DeploymentTarget,
		TargetConfiguration []ent.Hook
	}
	inters struct {
		DeploymentHistory, DeploymentJob, DeploymentTarget,
		TargetConfiguration []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
