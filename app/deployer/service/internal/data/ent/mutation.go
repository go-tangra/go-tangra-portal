// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"github.com/go-tangra/go-tangra-portal/app/deployer/service/internal/data/ent/auditlog"
	"github.com/go-tangra/go-tangra-portal/app/deployer/service/internal/data/ent/deploymenthistory"
	"github.com/go-tangra/go-tangra-portal/app/deployer/service/internal/data/ent/deploymentjob"
	"github.com/go-tangra/go-tangra-portal/app/deployer/service/internal/data/ent/deploymenttarget"
	"github.com/go-tangra/go-tangra-portal/app/deployer/service/internal/data/ent/predicate"
	"github.com/go-tangra/go-tangra-portal/app/deployer/service/internal/data/ent/schema"
	"github.com/go-tangra/go-tangra-portal/app/deployer/service/internal/data/ent/targetconfiguration"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuditLog            = "AuditLog"
	TypeDeploymentHistory   = "DeploymentHistory"
	TypeDeploymentJob       = "DeploymentJob"
	TypeDeploymentTarget    = "DeploymentTarget"
	TypeTargetConfiguration = "TargetConfiguration"
)

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	create_time          *time.Time
	update_time          *time.Time
	delete_time          *time.Time
	tenant_id            *uint32
	addtenant_id         *int32
	audit_id             *string
	request_id           *string
	operation            *string
	service_name         *string
	client_id            *string
	client_common_name   *string
	client_organization  *string
	client_serial_number *string
	is_authenticated     *bool
	success              *bool
	error_code           *int32
	adderror_code        *int32
	error_message        *string
	latency_ms           *int64
	addlatency_ms        *int64
	peer_address         *string
	geo_location         *map[string]string
	log_hash             *string
	signature            *[]byte
	metadata             *map[string]string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*AuditLog, error)
	predicates           []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id uint32) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditLog entities.
func (m *AuditLogMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AuditLogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AuditLogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AuditLogMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[auditlog.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AuditLogMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AuditLogMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, auditlog.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AuditLogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AuditLogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AuditLogMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[auditlog.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AuditLogMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AuditLogMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, auditlog.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *AuditLogMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *AuditLogMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *AuditLogMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[auditlog.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *AuditLogMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *AuditLogMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, auditlog.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *AuditLogMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AuditLogMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *AuditLogMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *AuditLogMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[auditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, auditlog.FieldTenantID)
}

// SetAuditID sets the "audit_id" field.
func (m *AuditLogMutation) SetAuditID(s string) {
	m.audit_id = &s
}

// AuditID returns the value of the "audit_id" field in the mutation.
func (m *AuditLogMutation) AuditID() (r string, exists bool) {
	v := m.audit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditID returns the old "audit_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAuditID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditID: %w", err)
	}
	return oldValue.AuditID, nil
}

// ResetAuditID resets all changes to the "audit_id" field.
func (m *AuditLogMutation) ResetAuditID() {
	m.audit_id = nil
}

// SetRequestID sets the "request_id" field.
func (m *AuditLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *AuditLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *AuditLogMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[auditlog.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *AuditLogMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *AuditLogMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, auditlog.FieldRequestID)
}

// SetOperation sets the "operation" field.
func (m *AuditLogMutation) SetOperation(s string) {
	m.operation = &s
}

// Operation returns the value of the "operation" field in the mutation.
func (m *AuditLogMutation) Operation() (r string, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldOperation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *AuditLogMutation) ResetOperation() {
	m.operation = nil
}

// SetServiceName sets the "service_name" field.
func (m *AuditLogMutation) SetServiceName(s string) {
	m.service_name = &s
}

// ServiceName returns the value of the "service_name" field in the mutation.
func (m *AuditLogMutation) ServiceName() (r string, exists bool) {
	v := m.service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceName returns the old "service_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldServiceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceName: %w", err)
	}
	return oldValue.ServiceName, nil
}

// ResetServiceName resets all changes to the "service_name" field.
func (m *AuditLogMutation) ResetServiceName() {
	m.service_name = nil
}

// SetClientID sets the "client_id" field.
func (m *AuditLogMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AuditLogMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *AuditLogMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[auditlog.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *AuditLogMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AuditLogMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, auditlog.FieldClientID)
}

// SetClientCommonName sets the "client_common_name" field.
func (m *AuditLogMutation) SetClientCommonName(s string) {
	m.client_common_name = &s
}

// ClientCommonName returns the value of the "client_common_name" field in the mutation.
func (m *AuditLogMutation) ClientCommonName() (r string, exists bool) {
	v := m.client_common_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientCommonName returns the old "client_common_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientCommonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientCommonName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientCommonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientCommonName: %w", err)
	}
	return oldValue.ClientCommonName, nil
}

// ClearClientCommonName clears the value of the "client_common_name" field.
func (m *AuditLogMutation) ClearClientCommonName() {
	m.client_common_name = nil
	m.clearedFields[auditlog.FieldClientCommonName] = struct{}{}
}

// ClientCommonNameCleared returns if the "client_common_name" field was cleared in this mutation.
func (m *AuditLogMutation) ClientCommonNameCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientCommonName]
	return ok
}

// ResetClientCommonName resets all changes to the "client_common_name" field.
func (m *AuditLogMutation) ResetClientCommonName() {
	m.client_common_name = nil
	delete(m.clearedFields, auditlog.FieldClientCommonName)
}

// SetClientOrganization sets the "client_organization" field.
func (m *AuditLogMutation) SetClientOrganization(s string) {
	m.client_organization = &s
}

// ClientOrganization returns the value of the "client_organization" field in the mutation.
func (m *AuditLogMutation) ClientOrganization() (r string, exists bool) {
	v := m.client_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldClientOrganization returns the old "client_organization" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientOrganization: %w", err)
	}
	return oldValue.ClientOrganization, nil
}

// ClearClientOrganization clears the value of the "client_organization" field.
func (m *AuditLogMutation) ClearClientOrganization() {
	m.client_organization = nil
	m.clearedFields[auditlog.FieldClientOrganization] = struct{}{}
}

// ClientOrganizationCleared returns if the "client_organization" field was cleared in this mutation.
func (m *AuditLogMutation) ClientOrganizationCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientOrganization]
	return ok
}

// ResetClientOrganization resets all changes to the "client_organization" field.
func (m *AuditLogMutation) ResetClientOrganization() {
	m.client_organization = nil
	delete(m.clearedFields, auditlog.FieldClientOrganization)
}

// SetClientSerialNumber sets the "client_serial_number" field.
func (m *AuditLogMutation) SetClientSerialNumber(s string) {
	m.client_serial_number = &s
}

// ClientSerialNumber returns the value of the "client_serial_number" field in the mutation.
func (m *AuditLogMutation) ClientSerialNumber() (r string, exists bool) {
	v := m.client_serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSerialNumber returns the old "client_serial_number" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSerialNumber: %w", err)
	}
	return oldValue.ClientSerialNumber, nil
}

// ClearClientSerialNumber clears the value of the "client_serial_number" field.
func (m *AuditLogMutation) ClearClientSerialNumber() {
	m.client_serial_number = nil
	m.clearedFields[auditlog.FieldClientSerialNumber] = struct{}{}
}

// ClientSerialNumberCleared returns if the "client_serial_number" field was cleared in this mutation.
func (m *AuditLogMutation) ClientSerialNumberCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientSerialNumber]
	return ok
}

// ResetClientSerialNumber resets all changes to the "client_serial_number" field.
func (m *AuditLogMutation) ResetClientSerialNumber() {
	m.client_serial_number = nil
	delete(m.clearedFields, auditlog.FieldClientSerialNumber)
}

// SetIsAuthenticated sets the "is_authenticated" field.
func (m *AuditLogMutation) SetIsAuthenticated(b bool) {
	m.is_authenticated = &b
}

// IsAuthenticated returns the value of the "is_authenticated" field in the mutation.
func (m *AuditLogMutation) IsAuthenticated() (r bool, exists bool) {
	v := m.is_authenticated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAuthenticated returns the old "is_authenticated" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIsAuthenticated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAuthenticated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAuthenticated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAuthenticated: %w", err)
	}
	return oldValue.IsAuthenticated, nil
}

// ResetIsAuthenticated resets all changes to the "is_authenticated" field.
func (m *AuditLogMutation) ResetIsAuthenticated() {
	m.is_authenticated = nil
}

// SetSuccess sets the "success" field.
func (m *AuditLogMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *AuditLogMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *AuditLogMutation) ResetSuccess() {
	m.success = nil
}

// SetErrorCode sets the "error_code" field.
func (m *AuditLogMutation) SetErrorCode(i int32) {
	m.error_code = &i
	m.adderror_code = nil
}

// ErrorCode returns the value of the "error_code" field in the mutation.
func (m *AuditLogMutation) ErrorCode() (r int32, exists bool) {
	v := m.error_code
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "error_code" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorCode(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// AddErrorCode adds i to the "error_code" field.
func (m *AuditLogMutation) AddErrorCode(i int32) {
	if m.adderror_code != nil {
		*m.adderror_code += i
	} else {
		m.adderror_code = &i
	}
}

// AddedErrorCode returns the value that was added to the "error_code" field in this mutation.
func (m *AuditLogMutation) AddedErrorCode() (r int32, exists bool) {
	v := m.adderror_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearErrorCode clears the value of the "error_code" field.
func (m *AuditLogMutation) ClearErrorCode() {
	m.error_code = nil
	m.adderror_code = nil
	m.clearedFields[auditlog.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "error_code" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "error_code" field.
func (m *AuditLogMutation) ResetErrorCode() {
	m.error_code = nil
	m.adderror_code = nil
	delete(m.clearedFields, auditlog.FieldErrorCode)
}

// SetErrorMessage sets the "error_message" field.
func (m *AuditLogMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AuditLogMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AuditLogMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[auditlog.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AuditLogMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, auditlog.FieldErrorMessage)
}

// SetLatencyMs sets the "latency_ms" field.
func (m *AuditLogMutation) SetLatencyMs(i int64) {
	m.latency_ms = &i
	m.addlatency_ms = nil
}

// LatencyMs returns the value of the "latency_ms" field in the mutation.
func (m *AuditLogMutation) LatencyMs() (r int64, exists bool) {
	v := m.latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldLatencyMs returns the old "latency_ms" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldLatencyMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatencyMs: %w", err)
	}
	return oldValue.LatencyMs, nil
}

// AddLatencyMs adds i to the "latency_ms" field.
func (m *AuditLogMutation) AddLatencyMs(i int64) {
	if m.addlatency_ms != nil {
		*m.addlatency_ms += i
	} else {
		m.addlatency_ms = &i
	}
}

// AddedLatencyMs returns the value that was added to the "latency_ms" field in this mutation.
func (m *AuditLogMutation) AddedLatencyMs() (r int64, exists bool) {
	v := m.addlatency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatencyMs resets all changes to the "latency_ms" field.
func (m *AuditLogMutation) ResetLatencyMs() {
	m.latency_ms = nil
	m.addlatency_ms = nil
}

// SetPeerAddress sets the "peer_address" field.
func (m *AuditLogMutation) SetPeerAddress(s string) {
	m.peer_address = &s
}

// PeerAddress returns the value of the "peer_address" field in the mutation.
func (m *AuditLogMutation) PeerAddress() (r string, exists bool) {
	v := m.peer_address
	if v == nil {
		return
	}
	return *v, true
}

// OldPeerAddress returns the old "peer_address" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldPeerAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeerAddress: %w", err)
	}
	return oldValue.PeerAddress, nil
}

// ClearPeerAddress clears the value of the "peer_address" field.
func (m *AuditLogMutation) ClearPeerAddress() {
	m.peer_address = nil
	m.clearedFields[auditlog.FieldPeerAddress] = struct{}{}
}

// PeerAddressCleared returns if the "peer_address" field was cleared in this mutation.
func (m *AuditLogMutation) PeerAddressCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldPeerAddress]
	return ok
}

// ResetPeerAddress resets all changes to the "peer_address" field.
func (m *AuditLogMutation) ResetPeerAddress() {
	m.peer_address = nil
	delete(m.clearedFields, auditlog.FieldPeerAddress)
}

// SetGeoLocation sets the "geo_location" field.
func (m *AuditLogMutation) SetGeoLocation(value map[string]string) {
	m.geo_location = &value
}

// GeoLocation returns the value of the "geo_location" field in the mutation.
func (m *AuditLogMutation) GeoLocation() (r map[string]string, exists bool) {
	v := m.geo_location
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoLocation returns the old "geo_location" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldGeoLocation(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoLocation: %w", err)
	}
	return oldValue.GeoLocation, nil
}

// ClearGeoLocation clears the value of the "geo_location" field.
func (m *AuditLogMutation) ClearGeoLocation() {
	m.geo_location = nil
	m.clearedFields[auditlog.FieldGeoLocation] = struct{}{}
}

// GeoLocationCleared returns if the "geo_location" field was cleared in this mutation.
func (m *AuditLogMutation) GeoLocationCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldGeoLocation]
	return ok
}

// ResetGeoLocation resets all changes to the "geo_location" field.
func (m *AuditLogMutation) ResetGeoLocation() {
	m.geo_location = nil
	delete(m.clearedFields, auditlog.FieldGeoLocation)
}

// SetLogHash sets the "log_hash" field.
func (m *AuditLogMutation) SetLogHash(s string) {
	m.log_hash = &s
}

// LogHash returns the value of the "log_hash" field in the mutation.
func (m *AuditLogMutation) LogHash() (r string, exists bool) {
	v := m.log_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldLogHash returns the old "log_hash" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldLogHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogHash: %w", err)
	}
	return oldValue.LogHash, nil
}

// ClearLogHash clears the value of the "log_hash" field.
func (m *AuditLogMutation) ClearLogHash() {
	m.log_hash = nil
	m.clearedFields[auditlog.FieldLogHash] = struct{}{}
}

// LogHashCleared returns if the "log_hash" field was cleared in this mutation.
func (m *AuditLogMutation) LogHashCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldLogHash]
	return ok
}

// ResetLogHash resets all changes to the "log_hash" field.
func (m *AuditLogMutation) ResetLogHash() {
	m.log_hash = nil
	delete(m.clearedFields, auditlog.FieldLogHash)
}

// SetSignature sets the "signature" field.
func (m *AuditLogMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *AuditLogMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *AuditLogMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[auditlog.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *AuditLogMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *AuditLogMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, auditlog.FieldSignature)
}

// SetMetadata sets the "metadata" field.
func (m *AuditLogMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuditLogMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AuditLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[auditlog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AuditLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuditLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, auditlog.FieldMetadata)
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.create_time != nil {
		fields = append(fields, auditlog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, auditlog.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, auditlog.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.audit_id != nil {
		fields = append(fields, auditlog.FieldAuditID)
	}
	if m.request_id != nil {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.operation != nil {
		fields = append(fields, auditlog.FieldOperation)
	}
	if m.service_name != nil {
		fields = append(fields, auditlog.FieldServiceName)
	}
	if m.client_id != nil {
		fields = append(fields, auditlog.FieldClientID)
	}
	if m.client_common_name != nil {
		fields = append(fields, auditlog.FieldClientCommonName)
	}
	if m.client_organization != nil {
		fields = append(fields, auditlog.FieldClientOrganization)
	}
	if m.client_serial_number != nil {
		fields = append(fields, auditlog.FieldClientSerialNumber)
	}
	if m.is_authenticated != nil {
		fields = append(fields, auditlog.FieldIsAuthenticated)
	}
	if m.success != nil {
		fields = append(fields, auditlog.FieldSuccess)
	}
	if m.error_code != nil {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.error_message != nil {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.latency_ms != nil {
		fields = append(fields, auditlog.FieldLatencyMs)
	}
	if m.peer_address != nil {
		fields = append(fields, auditlog.FieldPeerAddress)
	}
	if m.geo_location != nil {
		fields = append(fields, auditlog.FieldGeoLocation)
	}
	if m.log_hash != nil {
		fields = append(fields, auditlog.FieldLogHash)
	}
	if m.signature != nil {
		fields = append(fields, auditlog.FieldSignature)
	}
	if m.metadata != nil {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldCreateTime:
		return m.CreateTime()
	case auditlog.FieldUpdateTime:
		return m.UpdateTime()
	case auditlog.FieldDeleteTime:
		return m.DeleteTime()
	case auditlog.FieldTenantID:
		return m.TenantID()
	case auditlog.FieldAuditID:
		return m.AuditID()
	case auditlog.FieldRequestID:
		return m.RequestID()
	case auditlog.FieldOperation:
		return m.Operation()
	case auditlog.FieldServiceName:
		return m.ServiceName()
	case auditlog.FieldClientID:
		return m.ClientID()
	case auditlog.FieldClientCommonName:
		return m.ClientCommonName()
	case auditlog.FieldClientOrganization:
		return m.ClientOrganization()
	case auditlog.FieldClientSerialNumber:
		return m.ClientSerialNumber()
	case auditlog.FieldIsAuthenticated:
		return m.IsAuthenticated()
	case auditlog.FieldSuccess:
		return m.Success()
	case auditlog.FieldErrorCode:
		return m.ErrorCode()
	case auditlog.FieldErrorMessage:
		return m.ErrorMessage()
	case auditlog.FieldLatencyMs:
		return m.LatencyMs()
	case auditlog.FieldPeerAddress:
		return m.PeerAddress()
	case auditlog.FieldGeoLocation:
		return m.GeoLocation()
	case auditlog.FieldLogHash:
		return m.LogHash()
	case auditlog.FieldSignature:
		return m.Signature()
	case auditlog.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case auditlog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case auditlog.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case auditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case auditlog.FieldAuditID:
		return m.OldAuditID(ctx)
	case auditlog.FieldRequestID:
		return m.OldRequestID(ctx)
	case auditlog.FieldOperation:
		return m.OldOperation(ctx)
	case auditlog.FieldServiceName:
		return m.OldServiceName(ctx)
	case auditlog.FieldClientID:
		return m.OldClientID(ctx)
	case auditlog.FieldClientCommonName:
		return m.OldClientCommonName(ctx)
	case auditlog.FieldClientOrganization:
		return m.OldClientOrganization(ctx)
	case auditlog.FieldClientSerialNumber:
		return m.OldClientSerialNumber(ctx)
	case auditlog.FieldIsAuthenticated:
		return m.OldIsAuthenticated(ctx)
	case auditlog.FieldSuccess:
		return m.OldSuccess(ctx)
	case auditlog.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case auditlog.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case auditlog.FieldLatencyMs:
		return m.OldLatencyMs(ctx)
	case auditlog.FieldPeerAddress:
		return m.OldPeerAddress(ctx)
	case auditlog.FieldGeoLocation:
		return m.OldGeoLocation(ctx)
	case auditlog.FieldLogHash:
		return m.OldLogHash(ctx)
	case auditlog.FieldSignature:
		return m.OldSignature(ctx)
	case auditlog.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case auditlog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case auditlog.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case auditlog.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case auditlog.FieldAuditID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditID(v)
		return nil
	case auditlog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case auditlog.FieldOperation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case auditlog.FieldServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceName(v)
		return nil
	case auditlog.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case auditlog.FieldClientCommonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientCommonName(v)
		return nil
	case auditlog.FieldClientOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientOrganization(v)
		return nil
	case auditlog.FieldClientSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSerialNumber(v)
		return nil
	case auditlog.FieldIsAuthenticated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAuthenticated(v)
		return nil
	case auditlog.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case auditlog.FieldErrorCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case auditlog.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case auditlog.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatencyMs(v)
		return nil
	case auditlog.FieldPeerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeerAddress(v)
		return nil
	case auditlog.FieldGeoLocation:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoLocation(v)
		return nil
	case auditlog.FieldLogHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogHash(v)
		return nil
	case auditlog.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case auditlog.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.adderror_code != nil {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.addlatency_ms != nil {
		fields = append(fields, auditlog.FieldLatencyMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldTenantID:
		return m.AddedTenantID()
	case auditlog.FieldErrorCode:
		return m.AddedErrorCode()
	case auditlog.FieldLatencyMs:
		return m.AddedLatencyMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case auditlog.FieldErrorCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrorCode(v)
		return nil
	case auditlog.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldCreateTime) {
		fields = append(fields, auditlog.FieldCreateTime)
	}
	if m.FieldCleared(auditlog.FieldUpdateTime) {
		fields = append(fields, auditlog.FieldUpdateTime)
	}
	if m.FieldCleared(auditlog.FieldDeleteTime) {
		fields = append(fields, auditlog.FieldDeleteTime)
	}
	if m.FieldCleared(auditlog.FieldTenantID) {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.FieldCleared(auditlog.FieldRequestID) {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.FieldCleared(auditlog.FieldClientID) {
		fields = append(fields, auditlog.FieldClientID)
	}
	if m.FieldCleared(auditlog.FieldClientCommonName) {
		fields = append(fields, auditlog.FieldClientCommonName)
	}
	if m.FieldCleared(auditlog.FieldClientOrganization) {
		fields = append(fields, auditlog.FieldClientOrganization)
	}
	if m.FieldCleared(auditlog.FieldClientSerialNumber) {
		fields = append(fields, auditlog.FieldClientSerialNumber)
	}
	if m.FieldCleared(auditlog.FieldErrorCode) {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.FieldCleared(auditlog.FieldErrorMessage) {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.FieldCleared(auditlog.FieldPeerAddress) {
		fields = append(fields, auditlog.FieldPeerAddress)
	}
	if m.FieldCleared(auditlog.FieldGeoLocation) {
		fields = append(fields, auditlog.FieldGeoLocation)
	}
	if m.FieldCleared(auditlog.FieldLogHash) {
		fields = append(fields, auditlog.FieldLogHash)
	}
	if m.FieldCleared(auditlog.FieldSignature) {
		fields = append(fields, auditlog.FieldSignature)
	}
	if m.FieldCleared(auditlog.FieldMetadata) {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case auditlog.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case auditlog.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case auditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case auditlog.FieldRequestID:
		m.ClearRequestID()
		return nil
	case auditlog.FieldClientID:
		m.ClearClientID()
		return nil
	case auditlog.FieldClientCommonName:
		m.ClearClientCommonName()
		return nil
	case auditlog.FieldClientOrganization:
		m.ClearClientOrganization()
		return nil
	case auditlog.FieldClientSerialNumber:
		m.ClearClientSerialNumber()
		return nil
	case auditlog.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	case auditlog.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case auditlog.FieldPeerAddress:
		m.ClearPeerAddress()
		return nil
	case auditlog.FieldGeoLocation:
		m.ClearGeoLocation()
		return nil
	case auditlog.FieldLogHash:
		m.ClearLogHash()
		return nil
	case auditlog.FieldSignature:
		m.ClearSignature()
		return nil
	case auditlog.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case auditlog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case auditlog.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case auditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case auditlog.FieldAuditID:
		m.ResetAuditID()
		return nil
	case auditlog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case auditlog.FieldOperation:
		m.ResetOperation()
		return nil
	case auditlog.FieldServiceName:
		m.ResetServiceName()
		return nil
	case auditlog.FieldClientID:
		m.ResetClientID()
		return nil
	case auditlog.FieldClientCommonName:
		m.ResetClientCommonName()
		return nil
	case auditlog.FieldClientOrganization:
		m.ResetClientOrganization()
		return nil
	case auditlog.FieldClientSerialNumber:
		m.ResetClientSerialNumber()
		return nil
	case auditlog.FieldIsAuthenticated:
		m.ResetIsAuthenticated()
		return nil
	case auditlog.FieldSuccess:
		m.ResetSuccess()
		return nil
	case auditlog.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case auditlog.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case auditlog.FieldLatencyMs:
		m.ResetLatencyMs()
		return nil
	case auditlog.FieldPeerAddress:
		m.ResetPeerAddress()
		return nil
	case auditlog.FieldGeoLocation:
		m.ResetGeoLocation()
		return nil
	case auditlog.FieldLogHash:
		m.ResetLogHash()
		return nil
	case auditlog.FieldSignature:
		m.ResetSignature()
		return nil
	case auditlog.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// DeploymentHistoryMutation represents an operation that mutates the DeploymentHistory nodes in the graph.
type DeploymentHistoryMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	create_time    *time.Time
	update_time    *time.Time
	delete_time    *time.Time
	action         *deploymenthistory.Action
	result         *deploymenthistory.Result
	message        *string
	duration_ms    *int64
	addduration_ms *int64
	details        *map[string]interface{}
	clearedFields  map[string]struct{}
	job            *string
	clearedjob     bool
	done           bool
	oldValue       func(context.Context) (*DeploymentHistory, error)
	predicates     []predicate.DeploymentHistory
}

var _ ent.Mutation = (*DeploymentHistoryMutation)(nil)

// deploymenthistoryOption allows management of the mutation configuration using functional options.
type deploymenthistoryOption func(*DeploymentHistoryMutation)

// newDeploymentHistoryMutation creates new mutation for the DeploymentHistory entity.
func newDeploymentHistoryMutation(c config, op Op, opts ...deploymenthistoryOption) *DeploymentHistoryMutation {
	m := &DeploymentHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeDeploymentHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeploymentHistoryID sets the ID field of the mutation.
func withDeploymentHistoryID(id uint32) deploymenthistoryOption {
	return func(m *DeploymentHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *DeploymentHistory
		)
		m.oldValue = func(ctx context.Context) (*DeploymentHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeploymentHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeploymentHistory sets the old DeploymentHistory of the mutation.
func withDeploymentHistory(node *DeploymentHistory) deploymenthistoryOption {
	return func(m *DeploymentHistoryMutation) {
		m.oldValue = func(context.Context) (*DeploymentHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeploymentHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeploymentHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeploymentHistory entities.
func (m *DeploymentHistoryMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeploymentHistoryMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeploymentHistoryMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeploymentHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DeploymentHistoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DeploymentHistoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DeploymentHistory entity.
// If the DeploymentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentHistoryMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *DeploymentHistoryMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[deploymenthistory.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *DeploymentHistoryMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[deploymenthistory.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DeploymentHistoryMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, deploymenthistory.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *DeploymentHistoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DeploymentHistoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DeploymentHistory entity.
// If the DeploymentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentHistoryMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *DeploymentHistoryMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[deploymenthistory.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *DeploymentHistoryMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[deploymenthistory.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DeploymentHistoryMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, deploymenthistory.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *DeploymentHistoryMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *DeploymentHistoryMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the DeploymentHistory entity.
// If the DeploymentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentHistoryMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *DeploymentHistoryMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[deploymenthistory.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *DeploymentHistoryMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[deploymenthistory.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *DeploymentHistoryMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, deploymenthistory.FieldDeleteTime)
}

// SetJobID sets the "job_id" field.
func (m *DeploymentHistoryMutation) SetJobID(s string) {
	m.job = &s
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *DeploymentHistoryMutation) JobID() (r string, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the DeploymentHistory entity.
// If the DeploymentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentHistoryMutation) OldJobID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *DeploymentHistoryMutation) ResetJobID() {
	m.job = nil
}

// SetAction sets the "action" field.
func (m *DeploymentHistoryMutation) SetAction(d deploymenthistory.Action) {
	m.action = &d
}

// Action returns the value of the "action" field in the mutation.
func (m *DeploymentHistoryMutation) Action() (r deploymenthistory.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the DeploymentHistory entity.
// If the DeploymentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentHistoryMutation) OldAction(ctx context.Context) (v deploymenthistory.Action, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *DeploymentHistoryMutation) ResetAction() {
	m.action = nil
}

// SetResult sets the "result" field.
func (m *DeploymentHistoryMutation) SetResult(d deploymenthistory.Result) {
	m.result = &d
}

// Result returns the value of the "result" field in the mutation.
func (m *DeploymentHistoryMutation) Result() (r deploymenthistory.Result, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the DeploymentHistory entity.
// If the DeploymentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentHistoryMutation) OldResult(ctx context.Context) (v deploymenthistory.Result, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *DeploymentHistoryMutation) ResetResult() {
	m.result = nil
}

// SetMessage sets the "message" field.
func (m *DeploymentHistoryMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *DeploymentHistoryMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the DeploymentHistory entity.
// If the DeploymentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentHistoryMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *DeploymentHistoryMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[deploymenthistory.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *DeploymentHistoryMutation) MessageCleared() bool {
	_, ok := m.clearedFields[deploymenthistory.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *DeploymentHistoryMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, deploymenthistory.FieldMessage)
}

// SetDurationMs sets the "duration_ms" field.
func (m *DeploymentHistoryMutation) SetDurationMs(i int64) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *DeploymentHistoryMutation) DurationMs() (r int64, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the DeploymentHistory entity.
// If the DeploymentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentHistoryMutation) OldDurationMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *DeploymentHistoryMutation) AddDurationMs(i int64) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *DeploymentHistoryMutation) AddedDurationMs() (r int64, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *DeploymentHistoryMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
}

// SetDetails sets the "details" field.
func (m *DeploymentHistoryMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *DeploymentHistoryMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the DeploymentHistory entity.
// If the DeploymentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentHistoryMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *DeploymentHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[deploymenthistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *DeploymentHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[deploymenthistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *DeploymentHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, deploymenthistory.FieldDetails)
}

// ClearJob clears the "job" edge to the DeploymentJob entity.
func (m *DeploymentHistoryMutation) ClearJob() {
	m.clearedjob = true
	m.clearedFields[deploymenthistory.FieldJobID] = struct{}{}
}

// JobCleared reports if the "job" edge to the DeploymentJob entity was cleared.
func (m *DeploymentHistoryMutation) JobCleared() bool {
	return m.clearedjob
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *DeploymentHistoryMutation) JobIDs() (ids []string) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *DeploymentHistoryMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// Where appends a list predicates to the DeploymentHistoryMutation builder.
func (m *DeploymentHistoryMutation) Where(ps ...predicate.DeploymentHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeploymentHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeploymentHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeploymentHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeploymentHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeploymentHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeploymentHistory).
func (m *DeploymentHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeploymentHistoryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, deploymenthistory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, deploymenthistory.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, deploymenthistory.FieldDeleteTime)
	}
	if m.job != nil {
		fields = append(fields, deploymenthistory.FieldJobID)
	}
	if m.action != nil {
		fields = append(fields, deploymenthistory.FieldAction)
	}
	if m.result != nil {
		fields = append(fields, deploymenthistory.FieldResult)
	}
	if m.message != nil {
		fields = append(fields, deploymenthistory.FieldMessage)
	}
	if m.duration_ms != nil {
		fields = append(fields, deploymenthistory.FieldDurationMs)
	}
	if m.details != nil {
		fields = append(fields, deploymenthistory.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeploymentHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deploymenthistory.FieldCreateTime:
		return m.CreateTime()
	case deploymenthistory.FieldUpdateTime:
		return m.UpdateTime()
	case deploymenthistory.FieldDeleteTime:
		return m.DeleteTime()
	case deploymenthistory.FieldJobID:
		return m.JobID()
	case deploymenthistory.FieldAction:
		return m.Action()
	case deploymenthistory.FieldResult:
		return m.Result()
	case deploymenthistory.FieldMessage:
		return m.Message()
	case deploymenthistory.FieldDurationMs:
		return m.DurationMs()
	case deploymenthistory.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeploymentHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deploymenthistory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case deploymenthistory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case deploymenthistory.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case deploymenthistory.FieldJobID:
		return m.OldJobID(ctx)
	case deploymenthistory.FieldAction:
		return m.OldAction(ctx)
	case deploymenthistory.FieldResult:
		return m.OldResult(ctx)
	case deploymenthistory.FieldMessage:
		return m.OldMessage(ctx)
	case deploymenthistory.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case deploymenthistory.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown DeploymentHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deploymenthistory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case deploymenthistory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case deploymenthistory.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case deploymenthistory.FieldJobID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case deploymenthistory.FieldAction:
		v, ok := value.(deploymenthistory.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case deploymenthistory.FieldResult:
		v, ok := value.(deploymenthistory.Result)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case deploymenthistory.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case deploymenthistory.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case deploymenthistory.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown DeploymentHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeploymentHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addduration_ms != nil {
		fields = append(fields, deploymenthistory.FieldDurationMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeploymentHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deploymenthistory.FieldDurationMs:
		return m.AddedDurationMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deploymenthistory.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown DeploymentHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeploymentHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deploymenthistory.FieldCreateTime) {
		fields = append(fields, deploymenthistory.FieldCreateTime)
	}
	if m.FieldCleared(deploymenthistory.FieldUpdateTime) {
		fields = append(fields, deploymenthistory.FieldUpdateTime)
	}
	if m.FieldCleared(deploymenthistory.FieldDeleteTime) {
		fields = append(fields, deploymenthistory.FieldDeleteTime)
	}
	if m.FieldCleared(deploymenthistory.FieldMessage) {
		fields = append(fields, deploymenthistory.FieldMessage)
	}
	if m.FieldCleared(deploymenthistory.FieldDetails) {
		fields = append(fields, deploymenthistory.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeploymentHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeploymentHistoryMutation) ClearField(name string) error {
	switch name {
	case deploymenthistory.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case deploymenthistory.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case deploymenthistory.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case deploymenthistory.FieldMessage:
		m.ClearMessage()
		return nil
	case deploymenthistory.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown DeploymentHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeploymentHistoryMutation) ResetField(name string) error {
	switch name {
	case deploymenthistory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case deploymenthistory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case deploymenthistory.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case deploymenthistory.FieldJobID:
		m.ResetJobID()
		return nil
	case deploymenthistory.FieldAction:
		m.ResetAction()
		return nil
	case deploymenthistory.FieldResult:
		m.ResetResult()
		return nil
	case deploymenthistory.FieldMessage:
		m.ResetMessage()
		return nil
	case deploymenthistory.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case deploymenthistory.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown DeploymentHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeploymentHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.job != nil {
		edges = append(edges, deploymenthistory.EdgeJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeploymentHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deploymenthistory.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeploymentHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeploymentHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeploymentHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedjob {
		edges = append(edges, deploymenthistory.EdgeJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeploymentHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case deploymenthistory.EdgeJob:
		return m.clearedjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeploymentHistoryMutation) ClearEdge(name string) error {
	switch name {
	case deploymenthistory.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown DeploymentHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeploymentHistoryMutation) ResetEdge(name string) error {
	switch name {
	case deploymenthistory.EdgeJob:
		m.ResetJob()
		return nil
	}
	return fmt.Errorf("unknown DeploymentHistory edge %s", name)
}

// DeploymentJobMutation represents an operation that mutates the DeploymentJob nodes in the graph.
type DeploymentJobMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	create_by                   *uint32
	addcreate_by                *int32
	create_time                 *time.Time
	update_time                 *time.Time
	delete_time                 *time.Time
	tenant_id                   *uint32
	addtenant_id                *int32
	certificate_id              *string
	certificate_serial          *string
	status                      *deploymentjob.Status
	status_message              *string
	progress                    *int32
	addprogress                 *int32
	retry_count                 *int32
	addretry_count              *int32
	max_retries                 *int32
	addmax_retries              *int32
	triggered_by                *deploymentjob.TriggeredBy
	result                      *map[string]interface{}
	started_at                  *time.Time
	completed_at                *time.Time
	next_retry_at               *time.Time
	clearedFields               map[string]struct{}
	deployment_target           *string
	cleareddeployment_target    bool
	target_configuration        *string
	clearedtarget_configuration bool
	parent_job                  *string
	clearedparent_job           bool
	child_jobs                  map[string]struct{}
	removedchild_jobs           map[string]struct{}
	clearedchild_jobs           bool
	history                     map[uint32]struct{}
	removedhistory              map[uint32]struct{}
	clearedhistory              bool
	done                        bool
	oldValue                    func(context.Context) (*DeploymentJob, error)
	predicates                  []predicate.DeploymentJob
}

var _ ent.Mutation = (*DeploymentJobMutation)(nil)

// deploymentjobOption allows management of the mutation configuration using functional options.
type deploymentjobOption func(*DeploymentJobMutation)

// newDeploymentJobMutation creates new mutation for the DeploymentJob entity.
func newDeploymentJobMutation(c config, op Op, opts ...deploymentjobOption) *DeploymentJobMutation {
	m := &DeploymentJobMutation{
		config:        c,
		op:            op,
		typ:           TypeDeploymentJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeploymentJobID sets the ID field of the mutation.
func withDeploymentJobID(id string) deploymentjobOption {
	return func(m *DeploymentJobMutation) {
		var (
			err   error
			once  sync.Once
			value *DeploymentJob
		)
		m.oldValue = func(ctx context.Context) (*DeploymentJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeploymentJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeploymentJob sets the old DeploymentJob of the mutation.
func withDeploymentJob(node *DeploymentJob) deploymentjobOption {
	return func(m *DeploymentJobMutation) {
		m.oldValue = func(context.Context) (*DeploymentJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeploymentJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeploymentJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeploymentJob entities.
func (m *DeploymentJobMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeploymentJobMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeploymentJobMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeploymentJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *DeploymentJobMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *DeploymentJobMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *DeploymentJobMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *DeploymentJobMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *DeploymentJobMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[deploymentjob.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *DeploymentJobMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[deploymentjob.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *DeploymentJobMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, deploymentjob.FieldCreateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *DeploymentJobMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DeploymentJobMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *DeploymentJobMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[deploymentjob.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *DeploymentJobMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[deploymentjob.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DeploymentJobMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, deploymentjob.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *DeploymentJobMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DeploymentJobMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *DeploymentJobMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[deploymentjob.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *DeploymentJobMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[deploymentjob.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DeploymentJobMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, deploymentjob.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *DeploymentJobMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *DeploymentJobMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *DeploymentJobMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[deploymentjob.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *DeploymentJobMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[deploymentjob.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *DeploymentJobMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, deploymentjob.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *DeploymentJobMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeploymentJobMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *DeploymentJobMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DeploymentJobMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *DeploymentJobMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[deploymentjob.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *DeploymentJobMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[deploymentjob.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeploymentJobMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, deploymentjob.FieldTenantID)
}

// SetDeploymentTargetID sets the "deployment_target_id" field.
func (m *DeploymentJobMutation) SetDeploymentTargetID(s string) {
	m.deployment_target = &s
}

// DeploymentTargetID returns the value of the "deployment_target_id" field in the mutation.
func (m *DeploymentJobMutation) DeploymentTargetID() (r string, exists bool) {
	v := m.deployment_target
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentTargetID returns the old "deployment_target_id" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldDeploymentTargetID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentTargetID: %w", err)
	}
	return oldValue.DeploymentTargetID, nil
}

// ClearDeploymentTargetID clears the value of the "deployment_target_id" field.
func (m *DeploymentJobMutation) ClearDeploymentTargetID() {
	m.deployment_target = nil
	m.clearedFields[deploymentjob.FieldDeploymentTargetID] = struct{}{}
}

// DeploymentTargetIDCleared returns if the "deployment_target_id" field was cleared in this mutation.
func (m *DeploymentJobMutation) DeploymentTargetIDCleared() bool {
	_, ok := m.clearedFields[deploymentjob.FieldDeploymentTargetID]
	return ok
}

// ResetDeploymentTargetID resets all changes to the "deployment_target_id" field.
func (m *DeploymentJobMutation) ResetDeploymentTargetID() {
	m.deployment_target = nil
	delete(m.clearedFields, deploymentjob.FieldDeploymentTargetID)
}

// SetTargetConfigurationID sets the "target_configuration_id" field.
func (m *DeploymentJobMutation) SetTargetConfigurationID(s string) {
	m.target_configuration = &s
}

// TargetConfigurationID returns the value of the "target_configuration_id" field in the mutation.
func (m *DeploymentJobMutation) TargetConfigurationID() (r string, exists bool) {
	v := m.target_configuration
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetConfigurationID returns the old "target_configuration_id" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldTargetConfigurationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetConfigurationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetConfigurationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetConfigurationID: %w", err)
	}
	return oldValue.TargetConfigurationID, nil
}

// ClearTargetConfigurationID clears the value of the "target_configuration_id" field.
func (m *DeploymentJobMutation) ClearTargetConfigurationID() {
	m.target_configuration = nil
	m.clearedFields[deploymentjob.FieldTargetConfigurationID] = struct{}{}
}

// TargetConfigurationIDCleared returns if the "target_configuration_id" field was cleared in this mutation.
func (m *DeploymentJobMutation) TargetConfigurationIDCleared() bool {
	_, ok := m.clearedFields[deploymentjob.FieldTargetConfigurationID]
	return ok
}

// ResetTargetConfigurationID resets all changes to the "target_configuration_id" field.
func (m *DeploymentJobMutation) ResetTargetConfigurationID() {
	m.target_configuration = nil
	delete(m.clearedFields, deploymentjob.FieldTargetConfigurationID)
}

// SetParentJobID sets the "parent_job_id" field.
func (m *DeploymentJobMutation) SetParentJobID(s string) {
	m.parent_job = &s
}

// ParentJobID returns the value of the "parent_job_id" field in the mutation.
func (m *DeploymentJobMutation) ParentJobID() (r string, exists bool) {
	v := m.parent_job
	if v == nil {
		return
	}
	return *v, true
}

// OldParentJobID returns the old "parent_job_id" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldParentJobID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentJobID: %w", err)
	}
	return oldValue.ParentJobID, nil
}

// ClearParentJobID clears the value of the "parent_job_id" field.
func (m *DeploymentJobMutation) ClearParentJobID() {
	m.parent_job = nil
	m.clearedFields[deploymentjob.FieldParentJobID] = struct{}{}
}

// ParentJobIDCleared returns if the "parent_job_id" field was cleared in this mutation.
func (m *DeploymentJobMutation) ParentJobIDCleared() bool {
	_, ok := m.clearedFields[deploymentjob.FieldParentJobID]
	return ok
}

// ResetParentJobID resets all changes to the "parent_job_id" field.
func (m *DeploymentJobMutation) ResetParentJobID() {
	m.parent_job = nil
	delete(m.clearedFields, deploymentjob.FieldParentJobID)
}

// SetCertificateID sets the "certificate_id" field.
func (m *DeploymentJobMutation) SetCertificateID(s string) {
	m.certificate_id = &s
}

// CertificateID returns the value of the "certificate_id" field in the mutation.
func (m *DeploymentJobMutation) CertificateID() (r string, exists bool) {
	v := m.certificate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateID returns the old "certificate_id" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldCertificateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateID: %w", err)
	}
	return oldValue.CertificateID, nil
}

// ResetCertificateID resets all changes to the "certificate_id" field.
func (m *DeploymentJobMutation) ResetCertificateID() {
	m.certificate_id = nil
}

// SetCertificateSerial sets the "certificate_serial" field.
func (m *DeploymentJobMutation) SetCertificateSerial(s string) {
	m.certificate_serial = &s
}

// CertificateSerial returns the value of the "certificate_serial" field in the mutation.
func (m *DeploymentJobMutation) CertificateSerial() (r string, exists bool) {
	v := m.certificate_serial
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateSerial returns the old "certificate_serial" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldCertificateSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateSerial: %w", err)
	}
	return oldValue.CertificateSerial, nil
}

// ClearCertificateSerial clears the value of the "certificate_serial" field.
func (m *DeploymentJobMutation) ClearCertificateSerial() {
	m.certificate_serial = nil
	m.clearedFields[deploymentjob.FieldCertificateSerial] = struct{}{}
}

// CertificateSerialCleared returns if the "certificate_serial" field was cleared in this mutation.
func (m *DeploymentJobMutation) CertificateSerialCleared() bool {
	_, ok := m.clearedFields[deploymentjob.FieldCertificateSerial]
	return ok
}

// ResetCertificateSerial resets all changes to the "certificate_serial" field.
func (m *DeploymentJobMutation) ResetCertificateSerial() {
	m.certificate_serial = nil
	delete(m.clearedFields, deploymentjob.FieldCertificateSerial)
}

// SetStatus sets the "status" field.
func (m *DeploymentJobMutation) SetStatus(d deploymentjob.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DeploymentJobMutation) Status() (r deploymentjob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldStatus(ctx context.Context) (v deploymentjob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DeploymentJobMutation) ResetStatus() {
	m.status = nil
}

// SetStatusMessage sets the "status_message" field.
func (m *DeploymentJobMutation) SetStatusMessage(s string) {
	m.status_message = &s
}

// StatusMessage returns the value of the "status_message" field in the mutation.
func (m *DeploymentJobMutation) StatusMessage() (r string, exists bool) {
	v := m.status_message
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusMessage returns the old "status_message" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldStatusMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusMessage: %w", err)
	}
	return oldValue.StatusMessage, nil
}

// ClearStatusMessage clears the value of the "status_message" field.
func (m *DeploymentJobMutation) ClearStatusMessage() {
	m.status_message = nil
	m.clearedFields[deploymentjob.FieldStatusMessage] = struct{}{}
}

// StatusMessageCleared returns if the "status_message" field was cleared in this mutation.
func (m *DeploymentJobMutation) StatusMessageCleared() bool {
	_, ok := m.clearedFields[deploymentjob.FieldStatusMessage]
	return ok
}

// ResetStatusMessage resets all changes to the "status_message" field.
func (m *DeploymentJobMutation) ResetStatusMessage() {
	m.status_message = nil
	delete(m.clearedFields, deploymentjob.FieldStatusMessage)
}

// SetProgress sets the "progress" field.
func (m *DeploymentJobMutation) SetProgress(i int32) {
	m.progress = &i
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *DeploymentJobMutation) Progress() (r int32, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldProgress(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds i to the "progress" field.
func (m *DeploymentJobMutation) AddProgress(i int32) {
	if m.addprogress != nil {
		*m.addprogress += i
	} else {
		m.addprogress = &i
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *DeploymentJobMutation) AddedProgress() (r int32, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress resets all changes to the "progress" field.
func (m *DeploymentJobMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetRetryCount sets the "retry_count" field.
func (m *DeploymentJobMutation) SetRetryCount(i int32) {
	m.retry_count = &i
	m.addretry_count = nil
}

// RetryCount returns the value of the "retry_count" field in the mutation.
func (m *DeploymentJobMutation) RetryCount() (r int32, exists bool) {
	v := m.retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryCount returns the old "retry_count" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldRetryCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryCount: %w", err)
	}
	return oldValue.RetryCount, nil
}

// AddRetryCount adds i to the "retry_count" field.
func (m *DeploymentJobMutation) AddRetryCount(i int32) {
	if m.addretry_count != nil {
		*m.addretry_count += i
	} else {
		m.addretry_count = &i
	}
}

// AddedRetryCount returns the value that was added to the "retry_count" field in this mutation.
func (m *DeploymentJobMutation) AddedRetryCount() (r int32, exists bool) {
	v := m.addretry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetryCount resets all changes to the "retry_count" field.
func (m *DeploymentJobMutation) ResetRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
}

// SetMaxRetries sets the "max_retries" field.
func (m *DeploymentJobMutation) SetMaxRetries(i int32) {
	m.max_retries = &i
	m.addmax_retries = nil
}

// MaxRetries returns the value of the "max_retries" field in the mutation.
func (m *DeploymentJobMutation) MaxRetries() (r int32, exists bool) {
	v := m.max_retries
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxRetries returns the old "max_retries" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldMaxRetries(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxRetries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxRetries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxRetries: %w", err)
	}
	return oldValue.MaxRetries, nil
}

// AddMaxRetries adds i to the "max_retries" field.
func (m *DeploymentJobMutation) AddMaxRetries(i int32) {
	if m.addmax_retries != nil {
		*m.addmax_retries += i
	} else {
		m.addmax_retries = &i
	}
}

// AddedMaxRetries returns the value that was added to the "max_retries" field in this mutation.
func (m *DeploymentJobMutation) AddedMaxRetries() (r int32, exists bool) {
	v := m.addmax_retries
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxRetries resets all changes to the "max_retries" field.
func (m *DeploymentJobMutation) ResetMaxRetries() {
	m.max_retries = nil
	m.addmax_retries = nil
}

// SetTriggeredBy sets the "triggered_by" field.
func (m *DeploymentJobMutation) SetTriggeredBy(db deploymentjob.TriggeredBy) {
	m.triggered_by = &db
}

// TriggeredBy returns the value of the "triggered_by" field in the mutation.
func (m *DeploymentJobMutation) TriggeredBy() (r deploymentjob.TriggeredBy, exists bool) {
	v := m.triggered_by
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggeredBy returns the old "triggered_by" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldTriggeredBy(ctx context.Context) (v deploymentjob.TriggeredBy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggeredBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggeredBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggeredBy: %w", err)
	}
	return oldValue.TriggeredBy, nil
}

// ResetTriggeredBy resets all changes to the "triggered_by" field.
func (m *DeploymentJobMutation) ResetTriggeredBy() {
	m.triggered_by = nil
}

// SetResult sets the "result" field.
func (m *DeploymentJobMutation) SetResult(value map[string]interface{}) {
	m.result = &value
}

// Result returns the value of the "result" field in the mutation.
func (m *DeploymentJobMutation) Result() (r map[string]interface{}, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldResult(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *DeploymentJobMutation) ClearResult() {
	m.result = nil
	m.clearedFields[deploymentjob.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *DeploymentJobMutation) ResultCleared() bool {
	_, ok := m.clearedFields[deploymentjob.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *DeploymentJobMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, deploymentjob.FieldResult)
}

// SetStartedAt sets the "started_at" field.
func (m *DeploymentJobMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *DeploymentJobMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *DeploymentJobMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[deploymentjob.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *DeploymentJobMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[deploymentjob.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *DeploymentJobMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, deploymentjob.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *DeploymentJobMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *DeploymentJobMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *DeploymentJobMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[deploymentjob.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *DeploymentJobMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[deploymentjob.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *DeploymentJobMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, deploymentjob.FieldCompletedAt)
}

// SetNextRetryAt sets the "next_retry_at" field.
func (m *DeploymentJobMutation) SetNextRetryAt(t time.Time) {
	m.next_retry_at = &t
}

// NextRetryAt returns the value of the "next_retry_at" field in the mutation.
func (m *DeploymentJobMutation) NextRetryAt() (r time.Time, exists bool) {
	v := m.next_retry_at
	if v == nil {
		return
	}
	return *v, true
}

// OldNextRetryAt returns the old "next_retry_at" field's value of the DeploymentJob entity.
// If the DeploymentJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentJobMutation) OldNextRetryAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextRetryAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextRetryAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextRetryAt: %w", err)
	}
	return oldValue.NextRetryAt, nil
}

// ClearNextRetryAt clears the value of the "next_retry_at" field.
func (m *DeploymentJobMutation) ClearNextRetryAt() {
	m.next_retry_at = nil
	m.clearedFields[deploymentjob.FieldNextRetryAt] = struct{}{}
}

// NextRetryAtCleared returns if the "next_retry_at" field was cleared in this mutation.
func (m *DeploymentJobMutation) NextRetryAtCleared() bool {
	_, ok := m.clearedFields[deploymentjob.FieldNextRetryAt]
	return ok
}

// ResetNextRetryAt resets all changes to the "next_retry_at" field.
func (m *DeploymentJobMutation) ResetNextRetryAt() {
	m.next_retry_at = nil
	delete(m.clearedFields, deploymentjob.FieldNextRetryAt)
}

// ClearDeploymentTarget clears the "deployment_target" edge to the DeploymentTarget entity.
func (m *DeploymentJobMutation) ClearDeploymentTarget() {
	m.cleareddeployment_target = true
	m.clearedFields[deploymentjob.FieldDeploymentTargetID] = struct{}{}
}

// DeploymentTargetCleared reports if the "deployment_target" edge to the DeploymentTarget entity was cleared.
func (m *DeploymentJobMutation) DeploymentTargetCleared() bool {
	return m.DeploymentTargetIDCleared() || m.cleareddeployment_target
}

// DeploymentTargetIDs returns the "deployment_target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeploymentTargetID instead. It exists only for internal usage by the builders.
func (m *DeploymentJobMutation) DeploymentTargetIDs() (ids []string) {
	if id := m.deployment_target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeploymentTarget resets all changes to the "deployment_target" edge.
func (m *DeploymentJobMutation) ResetDeploymentTarget() {
	m.deployment_target = nil
	m.cleareddeployment_target = false
}

// ClearTargetConfiguration clears the "target_configuration" edge to the TargetConfiguration entity.
func (m *DeploymentJobMutation) ClearTargetConfiguration() {
	m.clearedtarget_configuration = true
	m.clearedFields[deploymentjob.FieldTargetConfigurationID] = struct{}{}
}

// TargetConfigurationCleared reports if the "target_configuration" edge to the TargetConfiguration entity was cleared.
func (m *DeploymentJobMutation) TargetConfigurationCleared() bool {
	return m.TargetConfigurationIDCleared() || m.clearedtarget_configuration
}

// TargetConfigurationIDs returns the "target_configuration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetConfigurationID instead. It exists only for internal usage by the builders.
func (m *DeploymentJobMutation) TargetConfigurationIDs() (ids []string) {
	if id := m.target_configuration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTargetConfiguration resets all changes to the "target_configuration" edge.
func (m *DeploymentJobMutation) ResetTargetConfiguration() {
	m.target_configuration = nil
	m.clearedtarget_configuration = false
}

// ClearParentJob clears the "parent_job" edge to the DeploymentJob entity.
func (m *DeploymentJobMutation) ClearParentJob() {
	m.clearedparent_job = true
	m.clearedFields[deploymentjob.FieldParentJobID] = struct{}{}
}

// ParentJobCleared reports if the "parent_job" edge to the DeploymentJob entity was cleared.
func (m *DeploymentJobMutation) ParentJobCleared() bool {
	return m.ParentJobIDCleared() || m.clearedparent_job
}

// ParentJobIDs returns the "parent_job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentJobID instead. It exists only for internal usage by the builders.
func (m *DeploymentJobMutation) ParentJobIDs() (ids []string) {
	if id := m.parent_job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentJob resets all changes to the "parent_job" edge.
func (m *DeploymentJobMutation) ResetParentJob() {
	m.parent_job = nil
	m.clearedparent_job = false
}

// AddChildJobIDs adds the "child_jobs" edge to the DeploymentJob entity by ids.
func (m *DeploymentJobMutation) AddChildJobIDs(ids ...string) {
	if m.child_jobs == nil {
		m.child_jobs = make(map[string]struct{})
	}
	for i := range ids {
		m.child_jobs[ids[i]] = struct{}{}
	}
}

// ClearChildJobs clears the "child_jobs" edge to the DeploymentJob entity.
func (m *DeploymentJobMutation) ClearChildJobs() {
	m.clearedchild_jobs = true
}

// ChildJobsCleared reports if the "child_jobs" edge to the DeploymentJob entity was cleared.
func (m *DeploymentJobMutation) ChildJobsCleared() bool {
	return m.clearedchild_jobs
}

// RemoveChildJobIDs removes the "child_jobs" edge to the DeploymentJob entity by IDs.
func (m *DeploymentJobMutation) RemoveChildJobIDs(ids ...string) {
	if m.removedchild_jobs == nil {
		m.removedchild_jobs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.child_jobs, ids[i])
		m.removedchild_jobs[ids[i]] = struct{}{}
	}
}

// RemovedChildJobs returns the removed IDs of the "child_jobs" edge to the DeploymentJob entity.
func (m *DeploymentJobMutation) RemovedChildJobsIDs() (ids []string) {
	for id := range m.removedchild_jobs {
		ids = append(ids, id)
	}
	return
}

// ChildJobsIDs returns the "child_jobs" edge IDs in the mutation.
func (m *DeploymentJobMutation) ChildJobsIDs() (ids []string) {
	for id := range m.child_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetChildJobs resets all changes to the "child_jobs" edge.
func (m *DeploymentJobMutation) ResetChildJobs() {
	m.child_jobs = nil
	m.clearedchild_jobs = false
	m.removedchild_jobs = nil
}

// AddHistoryIDs adds the "history" edge to the DeploymentHistory entity by ids.
func (m *DeploymentJobMutation) AddHistoryIDs(ids ...uint32) {
	if m.history == nil {
		m.history = make(map[uint32]struct{})
	}
	for i := range ids {
		m.history[ids[i]] = struct{}{}
	}
}

// ClearHistory clears the "history" edge to the DeploymentHistory entity.
func (m *DeploymentJobMutation) ClearHistory() {
	m.clearedhistory = true
}

// HistoryCleared reports if the "history" edge to the DeploymentHistory entity was cleared.
func (m *DeploymentJobMutation) HistoryCleared() bool {
	return m.clearedhistory
}

// RemoveHistoryIDs removes the "history" edge to the DeploymentHistory entity by IDs.
func (m *DeploymentJobMutation) RemoveHistoryIDs(ids ...uint32) {
	if m.removedhistory == nil {
		m.removedhistory = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.history, ids[i])
		m.removedhistory[ids[i]] = struct{}{}
	}
}

// RemovedHistory returns the removed IDs of the "history" edge to the DeploymentHistory entity.
func (m *DeploymentJobMutation) RemovedHistoryIDs() (ids []uint32) {
	for id := range m.removedhistory {
		ids = append(ids, id)
	}
	return
}

// HistoryIDs returns the "history" edge IDs in the mutation.
func (m *DeploymentJobMutation) HistoryIDs() (ids []uint32) {
	for id := range m.history {
		ids = append(ids, id)
	}
	return
}

// ResetHistory resets all changes to the "history" edge.
func (m *DeploymentJobMutation) ResetHistory() {
	m.history = nil
	m.clearedhistory = false
	m.removedhistory = nil
}

// Where appends a list predicates to the DeploymentJobMutation builder.
func (m *DeploymentJobMutation) Where(ps ...predicate.DeploymentJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeploymentJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeploymentJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeploymentJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeploymentJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeploymentJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeploymentJob).
func (m *DeploymentJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeploymentJobMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.create_by != nil {
		fields = append(fields, deploymentjob.FieldCreateBy)
	}
	if m.create_time != nil {
		fields = append(fields, deploymentjob.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, deploymentjob.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, deploymentjob.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, deploymentjob.FieldTenantID)
	}
	if m.deployment_target != nil {
		fields = append(fields, deploymentjob.FieldDeploymentTargetID)
	}
	if m.target_configuration != nil {
		fields = append(fields, deploymentjob.FieldTargetConfigurationID)
	}
	if m.parent_job != nil {
		fields = append(fields, deploymentjob.FieldParentJobID)
	}
	if m.certificate_id != nil {
		fields = append(fields, deploymentjob.FieldCertificateID)
	}
	if m.certificate_serial != nil {
		fields = append(fields, deploymentjob.FieldCertificateSerial)
	}
	if m.status != nil {
		fields = append(fields, deploymentjob.FieldStatus)
	}
	if m.status_message != nil {
		fields = append(fields, deploymentjob.FieldStatusMessage)
	}
	if m.progress != nil {
		fields = append(fields, deploymentjob.FieldProgress)
	}
	if m.retry_count != nil {
		fields = append(fields, deploymentjob.FieldRetryCount)
	}
	if m.max_retries != nil {
		fields = append(fields, deploymentjob.FieldMaxRetries)
	}
	if m.triggered_by != nil {
		fields = append(fields, deploymentjob.FieldTriggeredBy)
	}
	if m.result != nil {
		fields = append(fields, deploymentjob.FieldResult)
	}
	if m.started_at != nil {
		fields = append(fields, deploymentjob.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, deploymentjob.FieldCompletedAt)
	}
	if m.next_retry_at != nil {
		fields = append(fields, deploymentjob.FieldNextRetryAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeploymentJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deploymentjob.FieldCreateBy:
		return m.CreateBy()
	case deploymentjob.FieldCreateTime:
		return m.CreateTime()
	case deploymentjob.FieldUpdateTime:
		return m.UpdateTime()
	case deploymentjob.FieldDeleteTime:
		return m.DeleteTime()
	case deploymentjob.FieldTenantID:
		return m.TenantID()
	case deploymentjob.FieldDeploymentTargetID:
		return m.DeploymentTargetID()
	case deploymentjob.FieldTargetConfigurationID:
		return m.TargetConfigurationID()
	case deploymentjob.FieldParentJobID:
		return m.ParentJobID()
	case deploymentjob.FieldCertificateID:
		return m.CertificateID()
	case deploymentjob.FieldCertificateSerial:
		return m.CertificateSerial()
	case deploymentjob.FieldStatus:
		return m.Status()
	case deploymentjob.FieldStatusMessage:
		return m.StatusMessage()
	case deploymentjob.FieldProgress:
		return m.Progress()
	case deploymentjob.FieldRetryCount:
		return m.RetryCount()
	case deploymentjob.FieldMaxRetries:
		return m.MaxRetries()
	case deploymentjob.FieldTriggeredBy:
		return m.TriggeredBy()
	case deploymentjob.FieldResult:
		return m.Result()
	case deploymentjob.FieldStartedAt:
		return m.StartedAt()
	case deploymentjob.FieldCompletedAt:
		return m.CompletedAt()
	case deploymentjob.FieldNextRetryAt:
		return m.NextRetryAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeploymentJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deploymentjob.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case deploymentjob.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case deploymentjob.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case deploymentjob.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case deploymentjob.FieldTenantID:
		return m.OldTenantID(ctx)
	case deploymentjob.FieldDeploymentTargetID:
		return m.OldDeploymentTargetID(ctx)
	case deploymentjob.FieldTargetConfigurationID:
		return m.OldTargetConfigurationID(ctx)
	case deploymentjob.FieldParentJobID:
		return m.OldParentJobID(ctx)
	case deploymentjob.FieldCertificateID:
		return m.OldCertificateID(ctx)
	case deploymentjob.FieldCertificateSerial:
		return m.OldCertificateSerial(ctx)
	case deploymentjob.FieldStatus:
		return m.OldStatus(ctx)
	case deploymentjob.FieldStatusMessage:
		return m.OldStatusMessage(ctx)
	case deploymentjob.FieldProgress:
		return m.OldProgress(ctx)
	case deploymentjob.FieldRetryCount:
		return m.OldRetryCount(ctx)
	case deploymentjob.FieldMaxRetries:
		return m.OldMaxRetries(ctx)
	case deploymentjob.FieldTriggeredBy:
		return m.OldTriggeredBy(ctx)
	case deploymentjob.FieldResult:
		return m.OldResult(ctx)
	case deploymentjob.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case deploymentjob.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case deploymentjob.FieldNextRetryAt:
		return m.OldNextRetryAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeploymentJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deploymentjob.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case deploymentjob.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case deploymentjob.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case deploymentjob.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case deploymentjob.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case deploymentjob.FieldDeploymentTargetID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentTargetID(v)
		return nil
	case deploymentjob.FieldTargetConfigurationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetConfigurationID(v)
		return nil
	case deploymentjob.FieldParentJobID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentJobID(v)
		return nil
	case deploymentjob.FieldCertificateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateID(v)
		return nil
	case deploymentjob.FieldCertificateSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateSerial(v)
		return nil
	case deploymentjob.FieldStatus:
		v, ok := value.(deploymentjob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case deploymentjob.FieldStatusMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusMessage(v)
		return nil
	case deploymentjob.FieldProgress:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case deploymentjob.FieldRetryCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryCount(v)
		return nil
	case deploymentjob.FieldMaxRetries:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxRetries(v)
		return nil
	case deploymentjob.FieldTriggeredBy:
		v, ok := value.(deploymentjob.TriggeredBy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggeredBy(v)
		return nil
	case deploymentjob.FieldResult:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case deploymentjob.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case deploymentjob.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case deploymentjob.FieldNextRetryAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextRetryAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeploymentJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeploymentJobMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, deploymentjob.FieldCreateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, deploymentjob.FieldTenantID)
	}
	if m.addprogress != nil {
		fields = append(fields, deploymentjob.FieldProgress)
	}
	if m.addretry_count != nil {
		fields = append(fields, deploymentjob.FieldRetryCount)
	}
	if m.addmax_retries != nil {
		fields = append(fields, deploymentjob.FieldMaxRetries)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeploymentJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deploymentjob.FieldCreateBy:
		return m.AddedCreateBy()
	case deploymentjob.FieldTenantID:
		return m.AddedTenantID()
	case deploymentjob.FieldProgress:
		return m.AddedProgress()
	case deploymentjob.FieldRetryCount:
		return m.AddedRetryCount()
	case deploymentjob.FieldMaxRetries:
		return m.AddedMaxRetries()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deploymentjob.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case deploymentjob.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case deploymentjob.FieldProgress:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	case deploymentjob.FieldRetryCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryCount(v)
		return nil
	case deploymentjob.FieldMaxRetries:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxRetries(v)
		return nil
	}
	return fmt.Errorf("unknown DeploymentJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeploymentJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deploymentjob.FieldCreateBy) {
		fields = append(fields, deploymentjob.FieldCreateBy)
	}
	if m.FieldCleared(deploymentjob.FieldCreateTime) {
		fields = append(fields, deploymentjob.FieldCreateTime)
	}
	if m.FieldCleared(deploymentjob.FieldUpdateTime) {
		fields = append(fields, deploymentjob.FieldUpdateTime)
	}
	if m.FieldCleared(deploymentjob.FieldDeleteTime) {
		fields = append(fields, deploymentjob.FieldDeleteTime)
	}
	if m.FieldCleared(deploymentjob.FieldTenantID) {
		fields = append(fields, deploymentjob.FieldTenantID)
	}
	if m.FieldCleared(deploymentjob.FieldDeploymentTargetID) {
		fields = append(fields, deploymentjob.FieldDeploymentTargetID)
	}
	if m.FieldCleared(deploymentjob.FieldTargetConfigurationID) {
		fields = append(fields, deploymentjob.FieldTargetConfigurationID)
	}
	if m.FieldCleared(deploymentjob.FieldParentJobID) {
		fields = append(fields, deploymentjob.FieldParentJobID)
	}
	if m.FieldCleared(deploymentjob.FieldCertificateSerial) {
		fields = append(fields, deploymentjob.FieldCertificateSerial)
	}
	if m.FieldCleared(deploymentjob.FieldStatusMessage) {
		fields = append(fields, deploymentjob.FieldStatusMessage)
	}
	if m.FieldCleared(deploymentjob.FieldResult) {
		fields = append(fields, deploymentjob.FieldResult)
	}
	if m.FieldCleared(deploymentjob.FieldStartedAt) {
		fields = append(fields, deploymentjob.FieldStartedAt)
	}
	if m.FieldCleared(deploymentjob.FieldCompletedAt) {
		fields = append(fields, deploymentjob.FieldCompletedAt)
	}
	if m.FieldCleared(deploymentjob.FieldNextRetryAt) {
		fields = append(fields, deploymentjob.FieldNextRetryAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeploymentJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeploymentJobMutation) ClearField(name string) error {
	switch name {
	case deploymentjob.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case deploymentjob.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case deploymentjob.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case deploymentjob.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case deploymentjob.FieldTenantID:
		m.ClearTenantID()
		return nil
	case deploymentjob.FieldDeploymentTargetID:
		m.ClearDeploymentTargetID()
		return nil
	case deploymentjob.FieldTargetConfigurationID:
		m.ClearTargetConfigurationID()
		return nil
	case deploymentjob.FieldParentJobID:
		m.ClearParentJobID()
		return nil
	case deploymentjob.FieldCertificateSerial:
		m.ClearCertificateSerial()
		return nil
	case deploymentjob.FieldStatusMessage:
		m.ClearStatusMessage()
		return nil
	case deploymentjob.FieldResult:
		m.ClearResult()
		return nil
	case deploymentjob.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case deploymentjob.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case deploymentjob.FieldNextRetryAt:
		m.ClearNextRetryAt()
		return nil
	}
	return fmt.Errorf("unknown DeploymentJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeploymentJobMutation) ResetField(name string) error {
	switch name {
	case deploymentjob.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case deploymentjob.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case deploymentjob.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case deploymentjob.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case deploymentjob.FieldTenantID:
		m.ResetTenantID()
		return nil
	case deploymentjob.FieldDeploymentTargetID:
		m.ResetDeploymentTargetID()
		return nil
	case deploymentjob.FieldTargetConfigurationID:
		m.ResetTargetConfigurationID()
		return nil
	case deploymentjob.FieldParentJobID:
		m.ResetParentJobID()
		return nil
	case deploymentjob.FieldCertificateID:
		m.ResetCertificateID()
		return nil
	case deploymentjob.FieldCertificateSerial:
		m.ResetCertificateSerial()
		return nil
	case deploymentjob.FieldStatus:
		m.ResetStatus()
		return nil
	case deploymentjob.FieldStatusMessage:
		m.ResetStatusMessage()
		return nil
	case deploymentjob.FieldProgress:
		m.ResetProgress()
		return nil
	case deploymentjob.FieldRetryCount:
		m.ResetRetryCount()
		return nil
	case deploymentjob.FieldMaxRetries:
		m.ResetMaxRetries()
		return nil
	case deploymentjob.FieldTriggeredBy:
		m.ResetTriggeredBy()
		return nil
	case deploymentjob.FieldResult:
		m.ResetResult()
		return nil
	case deploymentjob.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case deploymentjob.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case deploymentjob.FieldNextRetryAt:
		m.ResetNextRetryAt()
		return nil
	}
	return fmt.Errorf("unknown DeploymentJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeploymentJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.deployment_target != nil {
		edges = append(edges, deploymentjob.EdgeDeploymentTarget)
	}
	if m.target_configuration != nil {
		edges = append(edges, deploymentjob.EdgeTargetConfiguration)
	}
	if m.parent_job != nil {
		edges = append(edges, deploymentjob.EdgeParentJob)
	}
	if m.child_jobs != nil {
		edges = append(edges, deploymentjob.EdgeChildJobs)
	}
	if m.history != nil {
		edges = append(edges, deploymentjob.EdgeHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeploymentJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deploymentjob.EdgeDeploymentTarget:
		if id := m.deployment_target; id != nil {
			return []ent.Value{*id}
		}
	case deploymentjob.EdgeTargetConfiguration:
		if id := m.target_configuration; id != nil {
			return []ent.Value{*id}
		}
	case deploymentjob.EdgeParentJob:
		if id := m.parent_job; id != nil {
			return []ent.Value{*id}
		}
	case deploymentjob.EdgeChildJobs:
		ids := make([]ent.Value, 0, len(m.child_jobs))
		for id := range m.child_jobs {
			ids = append(ids, id)
		}
		return ids
	case deploymentjob.EdgeHistory:
		ids := make([]ent.Value, 0, len(m.history))
		for id := range m.history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeploymentJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedchild_jobs != nil {
		edges = append(edges, deploymentjob.EdgeChildJobs)
	}
	if m.removedhistory != nil {
		edges = append(edges, deploymentjob.EdgeHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeploymentJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deploymentjob.EdgeChildJobs:
		ids := make([]ent.Value, 0, len(m.removedchild_jobs))
		for id := range m.removedchild_jobs {
			ids = append(ids, id)
		}
		return ids
	case deploymentjob.EdgeHistory:
		ids := make([]ent.Value, 0, len(m.removedhistory))
		for id := range m.removedhistory {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeploymentJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareddeployment_target {
		edges = append(edges, deploymentjob.EdgeDeploymentTarget)
	}
	if m.clearedtarget_configuration {
		edges = append(edges, deploymentjob.EdgeTargetConfiguration)
	}
	if m.clearedparent_job {
		edges = append(edges, deploymentjob.EdgeParentJob)
	}
	if m.clearedchild_jobs {
		edges = append(edges, deploymentjob.EdgeChildJobs)
	}
	if m.clearedhistory {
		edges = append(edges, deploymentjob.EdgeHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeploymentJobMutation) EdgeCleared(name string) bool {
	switch name {
	case deploymentjob.EdgeDeploymentTarget:
		return m.cleareddeployment_target
	case deploymentjob.EdgeTargetConfiguration:
		return m.clearedtarget_configuration
	case deploymentjob.EdgeParentJob:
		return m.clearedparent_job
	case deploymentjob.EdgeChildJobs:
		return m.clearedchild_jobs
	case deploymentjob.EdgeHistory:
		return m.clearedhistory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeploymentJobMutation) ClearEdge(name string) error {
	switch name {
	case deploymentjob.EdgeDeploymentTarget:
		m.ClearDeploymentTarget()
		return nil
	case deploymentjob.EdgeTargetConfiguration:
		m.ClearTargetConfiguration()
		return nil
	case deploymentjob.EdgeParentJob:
		m.ClearParentJob()
		return nil
	}
	return fmt.Errorf("unknown DeploymentJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeploymentJobMutation) ResetEdge(name string) error {
	switch name {
	case deploymentjob.EdgeDeploymentTarget:
		m.ResetDeploymentTarget()
		return nil
	case deploymentjob.EdgeTargetConfiguration:
		m.ResetTargetConfiguration()
		return nil
	case deploymentjob.EdgeParentJob:
		m.ResetParentJob()
		return nil
	case deploymentjob.EdgeChildJobs:
		m.ResetChildJobs()
		return nil
	case deploymentjob.EdgeHistory:
		m.ResetHistory()
		return nil
	}
	return fmt.Errorf("unknown DeploymentJob edge %s", name)
}

// DeploymentTargetMutation represents an operation that mutates the DeploymentTarget nodes in the graph.
type DeploymentTargetMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	create_by                 *uint32
	addcreate_by              *int32
	update_by                 *uint32
	addupdate_by              *int32
	create_time               *time.Time
	update_time               *time.Time
	delete_time               *time.Time
	tenant_id                 *uint32
	addtenant_id              *int32
	name                      *string
	description               *string
	auto_deploy_on_renewal    *bool
	certificate_filters       *[]schema.CertificateFilter
	appendcertificate_filters []schema.CertificateFilter
	clearedFields             map[string]struct{}
	configurations            map[string]struct{}
	removedconfigurations     map[string]struct{}
	clearedconfigurations     bool
	jobs                      map[string]struct{}
	removedjobs               map[string]struct{}
	clearedjobs               bool
	done                      bool
	oldValue                  func(context.Context) (*DeploymentTarget, error)
	predicates                []predicate.DeploymentTarget
}

var _ ent.Mutation = (*DeploymentTargetMutation)(nil)

// deploymenttargetOption allows management of the mutation configuration using functional options.
type deploymenttargetOption func(*DeploymentTargetMutation)

// newDeploymentTargetMutation creates new mutation for the DeploymentTarget entity.
func newDeploymentTargetMutation(c config, op Op, opts ...deploymenttargetOption) *DeploymentTargetMutation {
	m := &DeploymentTargetMutation{
		config:        c,
		op:            op,
		typ:           TypeDeploymentTarget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeploymentTargetID sets the ID field of the mutation.
func withDeploymentTargetID(id string) deploymenttargetOption {
	return func(m *DeploymentTargetMutation) {
		var (
			err   error
			once  sync.Once
			value *DeploymentTarget
		)
		m.oldValue = func(ctx context.Context) (*DeploymentTarget, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeploymentTarget.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeploymentTarget sets the old DeploymentTarget of the mutation.
func withDeploymentTarget(node *DeploymentTarget) deploymenttargetOption {
	return func(m *DeploymentTargetMutation) {
		m.oldValue = func(context.Context) (*DeploymentTarget, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeploymentTargetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeploymentTargetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeploymentTarget entities.
func (m *DeploymentTargetMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeploymentTargetMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeploymentTargetMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeploymentTarget.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *DeploymentTargetMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *DeploymentTargetMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the DeploymentTarget entity.
// If the DeploymentTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentTargetMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *DeploymentTargetMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *DeploymentTargetMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *DeploymentTargetMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[deploymenttarget.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *DeploymentTargetMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[deploymenttarget.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *DeploymentTargetMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, deploymenttarget.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *DeploymentTargetMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *DeploymentTargetMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the DeploymentTarget entity.
// If the DeploymentTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentTargetMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *DeploymentTargetMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *DeploymentTargetMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *DeploymentTargetMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[deploymenttarget.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *DeploymentTargetMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[deploymenttarget.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *DeploymentTargetMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, deploymenttarget.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *DeploymentTargetMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DeploymentTargetMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DeploymentTarget entity.
// If the DeploymentTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentTargetMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *DeploymentTargetMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[deploymenttarget.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *DeploymentTargetMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[deploymenttarget.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DeploymentTargetMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, deploymenttarget.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *DeploymentTargetMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DeploymentTargetMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DeploymentTarget entity.
// If the DeploymentTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentTargetMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *DeploymentTargetMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[deploymenttarget.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *DeploymentTargetMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[deploymenttarget.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DeploymentTargetMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, deploymenttarget.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *DeploymentTargetMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *DeploymentTargetMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the DeploymentTarget entity.
// If the DeploymentTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentTargetMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *DeploymentTargetMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[deploymenttarget.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *DeploymentTargetMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[deploymenttarget.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *DeploymentTargetMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, deploymenttarget.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *DeploymentTargetMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeploymentTargetMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DeploymentTarget entity.
// If the DeploymentTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentTargetMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *DeploymentTargetMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DeploymentTargetMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *DeploymentTargetMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[deploymenttarget.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *DeploymentTargetMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[deploymenttarget.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeploymentTargetMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, deploymenttarget.FieldTenantID)
}

// SetName sets the "name" field.
func (m *DeploymentTargetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeploymentTargetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DeploymentTarget entity.
// If the DeploymentTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentTargetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeploymentTargetMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DeploymentTargetMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DeploymentTargetMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DeploymentTarget entity.
// If the DeploymentTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentTargetMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DeploymentTargetMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[deploymenttarget.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DeploymentTargetMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[deploymenttarget.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DeploymentTargetMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, deploymenttarget.FieldDescription)
}

// SetAutoDeployOnRenewal sets the "auto_deploy_on_renewal" field.
func (m *DeploymentTargetMutation) SetAutoDeployOnRenewal(b bool) {
	m.auto_deploy_on_renewal = &b
}

// AutoDeployOnRenewal returns the value of the "auto_deploy_on_renewal" field in the mutation.
func (m *DeploymentTargetMutation) AutoDeployOnRenewal() (r bool, exists bool) {
	v := m.auto_deploy_on_renewal
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoDeployOnRenewal returns the old "auto_deploy_on_renewal" field's value of the DeploymentTarget entity.
// If the DeploymentTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentTargetMutation) OldAutoDeployOnRenewal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoDeployOnRenewal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoDeployOnRenewal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoDeployOnRenewal: %w", err)
	}
	return oldValue.AutoDeployOnRenewal, nil
}

// ResetAutoDeployOnRenewal resets all changes to the "auto_deploy_on_renewal" field.
func (m *DeploymentTargetMutation) ResetAutoDeployOnRenewal() {
	m.auto_deploy_on_renewal = nil
}

// SetCertificateFilters sets the "certificate_filters" field.
func (m *DeploymentTargetMutation) SetCertificateFilters(sf []schema.CertificateFilter) {
	m.certificate_filters = &sf
	m.appendcertificate_filters = nil
}

// CertificateFilters returns the value of the "certificate_filters" field in the mutation.
func (m *DeploymentTargetMutation) CertificateFilters() (r []schema.CertificateFilter, exists bool) {
	v := m.certificate_filters
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateFilters returns the old "certificate_filters" field's value of the DeploymentTarget entity.
// If the DeploymentTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentTargetMutation) OldCertificateFilters(ctx context.Context) (v []schema.CertificateFilter, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateFilters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateFilters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateFilters: %w", err)
	}
	return oldValue.CertificateFilters, nil
}

// AppendCertificateFilters adds sf to the "certificate_filters" field.
func (m *DeploymentTargetMutation) AppendCertificateFilters(sf []schema.CertificateFilter) {
	m.appendcertificate_filters = append(m.appendcertificate_filters, sf...)
}

// AppendedCertificateFilters returns the list of values that were appended to the "certificate_filters" field in this mutation.
func (m *DeploymentTargetMutation) AppendedCertificateFilters() ([]schema.CertificateFilter, bool) {
	if len(m.appendcertificate_filters) == 0 {
		return nil, false
	}
	return m.appendcertificate_filters, true
}

// ClearCertificateFilters clears the value of the "certificate_filters" field.
func (m *DeploymentTargetMutation) ClearCertificateFilters() {
	m.certificate_filters = nil
	m.appendcertificate_filters = nil
	m.clearedFields[deploymenttarget.FieldCertificateFilters] = struct{}{}
}

// CertificateFiltersCleared returns if the "certificate_filters" field was cleared in this mutation.
func (m *DeploymentTargetMutation) CertificateFiltersCleared() bool {
	_, ok := m.clearedFields[deploymenttarget.FieldCertificateFilters]
	return ok
}

// ResetCertificateFilters resets all changes to the "certificate_filters" field.
func (m *DeploymentTargetMutation) ResetCertificateFilters() {
	m.certificate_filters = nil
	m.appendcertificate_filters = nil
	delete(m.clearedFields, deploymenttarget.FieldCertificateFilters)
}

// AddConfigurationIDs adds the "configurations" edge to the TargetConfiguration entity by ids.
func (m *DeploymentTargetMutation) AddConfigurationIDs(ids ...string) {
	if m.configurations == nil {
		m.configurations = make(map[string]struct{})
	}
	for i := range ids {
		m.configurations[ids[i]] = struct{}{}
	}
}

// ClearConfigurations clears the "configurations" edge to the TargetConfiguration entity.
func (m *DeploymentTargetMutation) ClearConfigurations() {
	m.clearedconfigurations = true
}

// ConfigurationsCleared reports if the "configurations" edge to the TargetConfiguration entity was cleared.
func (m *DeploymentTargetMutation) ConfigurationsCleared() bool {
	return m.clearedconfigurations
}

// RemoveConfigurationIDs removes the "configurations" edge to the TargetConfiguration entity by IDs.
func (m *DeploymentTargetMutation) RemoveConfigurationIDs(ids ...string) {
	if m.removedconfigurations == nil {
		m.removedconfigurations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.configurations, ids[i])
		m.removedconfigurations[ids[i]] = struct{}{}
	}
}

// RemovedConfigurations returns the removed IDs of the "configurations" edge to the TargetConfiguration entity.
func (m *DeploymentTargetMutation) RemovedConfigurationsIDs() (ids []string) {
	for id := range m.removedconfigurations {
		ids = append(ids, id)
	}
	return
}

// ConfigurationsIDs returns the "configurations" edge IDs in the mutation.
func (m *DeploymentTargetMutation) ConfigurationsIDs() (ids []string) {
	for id := range m.configurations {
		ids = append(ids, id)
	}
	return
}

// ResetConfigurations resets all changes to the "configurations" edge.
func (m *DeploymentTargetMutation) ResetConfigurations() {
	m.configurations = nil
	m.clearedconfigurations = false
	m.removedconfigurations = nil
}

// AddJobIDs adds the "jobs" edge to the DeploymentJob entity by ids.
func (m *DeploymentTargetMutation) AddJobIDs(ids ...string) {
	if m.jobs == nil {
		m.jobs = make(map[string]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the DeploymentJob entity.
func (m *DeploymentTargetMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the DeploymentJob entity was cleared.
func (m *DeploymentTargetMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the DeploymentJob entity by IDs.
func (m *DeploymentTargetMutation) RemoveJobIDs(ids ...string) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the DeploymentJob entity.
func (m *DeploymentTargetMutation) RemovedJobsIDs() (ids []string) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *DeploymentTargetMutation) JobsIDs() (ids []string) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *DeploymentTargetMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// Where appends a list predicates to the DeploymentTargetMutation builder.
func (m *DeploymentTargetMutation) Where(ps ...predicate.DeploymentTarget) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeploymentTargetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeploymentTargetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeploymentTarget, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeploymentTargetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeploymentTargetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeploymentTarget).
func (m *DeploymentTargetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeploymentTargetMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_by != nil {
		fields = append(fields, deploymenttarget.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, deploymenttarget.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, deploymenttarget.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, deploymenttarget.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, deploymenttarget.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, deploymenttarget.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, deploymenttarget.FieldName)
	}
	if m.description != nil {
		fields = append(fields, deploymenttarget.FieldDescription)
	}
	if m.auto_deploy_on_renewal != nil {
		fields = append(fields, deploymenttarget.FieldAutoDeployOnRenewal)
	}
	if m.certificate_filters != nil {
		fields = append(fields, deploymenttarget.FieldCertificateFilters)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeploymentTargetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deploymenttarget.FieldCreateBy:
		return m.CreateBy()
	case deploymenttarget.FieldUpdateBy:
		return m.UpdateBy()
	case deploymenttarget.FieldCreateTime:
		return m.CreateTime()
	case deploymenttarget.FieldUpdateTime:
		return m.UpdateTime()
	case deploymenttarget.FieldDeleteTime:
		return m.DeleteTime()
	case deploymenttarget.FieldTenantID:
		return m.TenantID()
	case deploymenttarget.FieldName:
		return m.Name()
	case deploymenttarget.FieldDescription:
		return m.Description()
	case deploymenttarget.FieldAutoDeployOnRenewal:
		return m.AutoDeployOnRenewal()
	case deploymenttarget.FieldCertificateFilters:
		return m.CertificateFilters()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeploymentTargetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deploymenttarget.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case deploymenttarget.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case deploymenttarget.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case deploymenttarget.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case deploymenttarget.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case deploymenttarget.FieldTenantID:
		return m.OldTenantID(ctx)
	case deploymenttarget.FieldName:
		return m.OldName(ctx)
	case deploymenttarget.FieldDescription:
		return m.OldDescription(ctx)
	case deploymenttarget.FieldAutoDeployOnRenewal:
		return m.OldAutoDeployOnRenewal(ctx)
	case deploymenttarget.FieldCertificateFilters:
		return m.OldCertificateFilters(ctx)
	}
	return nil, fmt.Errorf("unknown DeploymentTarget field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentTargetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deploymenttarget.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case deploymenttarget.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case deploymenttarget.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case deploymenttarget.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case deploymenttarget.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case deploymenttarget.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case deploymenttarget.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case deploymenttarget.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case deploymenttarget.FieldAutoDeployOnRenewal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoDeployOnRenewal(v)
		return nil
	case deploymenttarget.FieldCertificateFilters:
		v, ok := value.([]schema.CertificateFilter)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateFilters(v)
		return nil
	}
	return fmt.Errorf("unknown DeploymentTarget field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeploymentTargetMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, deploymenttarget.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, deploymenttarget.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, deploymenttarget.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeploymentTargetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deploymenttarget.FieldCreateBy:
		return m.AddedCreateBy()
	case deploymenttarget.FieldUpdateBy:
		return m.AddedUpdateBy()
	case deploymenttarget.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentTargetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deploymenttarget.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case deploymenttarget.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case deploymenttarget.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown DeploymentTarget numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeploymentTargetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deploymenttarget.FieldCreateBy) {
		fields = append(fields, deploymenttarget.FieldCreateBy)
	}
	if m.FieldCleared(deploymenttarget.FieldUpdateBy) {
		fields = append(fields, deploymenttarget.FieldUpdateBy)
	}
	if m.FieldCleared(deploymenttarget.FieldCreateTime) {
		fields = append(fields, deploymenttarget.FieldCreateTime)
	}
	if m.FieldCleared(deploymenttarget.FieldUpdateTime) {
		fields = append(fields, deploymenttarget.FieldUpdateTime)
	}
	if m.FieldCleared(deploymenttarget.FieldDeleteTime) {
		fields = append(fields, deploymenttarget.FieldDeleteTime)
	}
	if m.FieldCleared(deploymenttarget.FieldTenantID) {
		fields = append(fields, deploymenttarget.FieldTenantID)
	}
	if m.FieldCleared(deploymenttarget.FieldDescription) {
		fields = append(fields, deploymenttarget.FieldDescription)
	}
	if m.FieldCleared(deploymenttarget.FieldCertificateFilters) {
		fields = append(fields, deploymenttarget.FieldCertificateFilters)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeploymentTargetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeploymentTargetMutation) ClearField(name string) error {
	switch name {
	case deploymenttarget.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case deploymenttarget.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case deploymenttarget.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case deploymenttarget.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case deploymenttarget.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case deploymenttarget.FieldTenantID:
		m.ClearTenantID()
		return nil
	case deploymenttarget.FieldDescription:
		m.ClearDescription()
		return nil
	case deploymenttarget.FieldCertificateFilters:
		m.ClearCertificateFilters()
		return nil
	}
	return fmt.Errorf("unknown DeploymentTarget nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeploymentTargetMutation) ResetField(name string) error {
	switch name {
	case deploymenttarget.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case deploymenttarget.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case deploymenttarget.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case deploymenttarget.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case deploymenttarget.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case deploymenttarget.FieldTenantID:
		m.ResetTenantID()
		return nil
	case deploymenttarget.FieldName:
		m.ResetName()
		return nil
	case deploymenttarget.FieldDescription:
		m.ResetDescription()
		return nil
	case deploymenttarget.FieldAutoDeployOnRenewal:
		m.ResetAutoDeployOnRenewal()
		return nil
	case deploymenttarget.FieldCertificateFilters:
		m.ResetCertificateFilters()
		return nil
	}
	return fmt.Errorf("unknown DeploymentTarget field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeploymentTargetMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.configurations != nil {
		edges = append(edges, deploymenttarget.EdgeConfigurations)
	}
	if m.jobs != nil {
		edges = append(edges, deploymenttarget.EdgeJobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeploymentTargetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deploymenttarget.EdgeConfigurations:
		ids := make([]ent.Value, 0, len(m.configurations))
		for id := range m.configurations {
			ids = append(ids, id)
		}
		return ids
	case deploymenttarget.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeploymentTargetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedconfigurations != nil {
		edges = append(edges, deploymenttarget.EdgeConfigurations)
	}
	if m.removedjobs != nil {
		edges = append(edges, deploymenttarget.EdgeJobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeploymentTargetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deploymenttarget.EdgeConfigurations:
		ids := make([]ent.Value, 0, len(m.removedconfigurations))
		for id := range m.removedconfigurations {
			ids = append(ids, id)
		}
		return ids
	case deploymenttarget.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeploymentTargetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedconfigurations {
		edges = append(edges, deploymenttarget.EdgeConfigurations)
	}
	if m.clearedjobs {
		edges = append(edges, deploymenttarget.EdgeJobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeploymentTargetMutation) EdgeCleared(name string) bool {
	switch name {
	case deploymenttarget.EdgeConfigurations:
		return m.clearedconfigurations
	case deploymenttarget.EdgeJobs:
		return m.clearedjobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeploymentTargetMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DeploymentTarget unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeploymentTargetMutation) ResetEdge(name string) error {
	switch name {
	case deploymenttarget.EdgeConfigurations:
		m.ResetConfigurations()
		return nil
	case deploymenttarget.EdgeJobs:
		m.ResetJobs()
		return nil
	}
	return fmt.Errorf("unknown DeploymentTarget edge %s", name)
}

// TargetConfigurationMutation represents an operation that mutates the TargetConfiguration nodes in the graph.
type TargetConfigurationMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	create_by                 *uint32
	addcreate_by              *int32
	update_by                 *uint32
	addupdate_by              *int32
	create_time               *time.Time
	update_time               *time.Time
	delete_time               *time.Time
	tenant_id                 *uint32
	addtenant_id              *int32
	name                      *string
	description               *string
	provider_type             *string
	credentials_encrypted     *[]byte
	_config                   *map[string]interface{}
	status                    *targetconfiguration.Status
	status_message            *string
	last_deployment_at        *time.Time
	clearedFields             map[string]struct{}
	jobs                      map[string]struct{}
	removedjobs               map[string]struct{}
	clearedjobs               bool
	deployment_targets        map[string]struct{}
	removeddeployment_targets map[string]struct{}
	cleareddeployment_targets bool
	done                      bool
	oldValue                  func(context.Context) (*TargetConfiguration, error)
	predicates                []predicate.TargetConfiguration
}

var _ ent.Mutation = (*TargetConfigurationMutation)(nil)

// targetconfigurationOption allows management of the mutation configuration using functional options.
type targetconfigurationOption func(*TargetConfigurationMutation)

// newTargetConfigurationMutation creates new mutation for the TargetConfiguration entity.
func newTargetConfigurationMutation(c config, op Op, opts ...targetconfigurationOption) *TargetConfigurationMutation {
	m := &TargetConfigurationMutation{
		config:        c,
		op:            op,
		typ:           TypeTargetConfiguration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTargetConfigurationID sets the ID field of the mutation.
func withTargetConfigurationID(id string) targetconfigurationOption {
	return func(m *TargetConfigurationMutation) {
		var (
			err   error
			once  sync.Once
			value *TargetConfiguration
		)
		m.oldValue = func(ctx context.Context) (*TargetConfiguration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TargetConfiguration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTargetConfiguration sets the old TargetConfiguration of the mutation.
func withTargetConfiguration(node *TargetConfiguration) targetconfigurationOption {
	return func(m *TargetConfigurationMutation) {
		m.oldValue = func(context.Context) (*TargetConfiguration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TargetConfigurationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TargetConfigurationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TargetConfiguration entities.
func (m *TargetConfigurationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TargetConfigurationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TargetConfigurationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TargetConfiguration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *TargetConfigurationMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *TargetConfigurationMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the TargetConfiguration entity.
// If the TargetConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetConfigurationMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *TargetConfigurationMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *TargetConfigurationMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *TargetConfigurationMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[targetconfiguration.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *TargetConfigurationMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[targetconfiguration.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *TargetConfigurationMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, targetconfiguration.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *TargetConfigurationMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *TargetConfigurationMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the TargetConfiguration entity.
// If the TargetConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetConfigurationMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *TargetConfigurationMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *TargetConfigurationMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *TargetConfigurationMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[targetconfiguration.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *TargetConfigurationMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[targetconfiguration.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *TargetConfigurationMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, targetconfiguration.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *TargetConfigurationMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TargetConfigurationMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TargetConfiguration entity.
// If the TargetConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetConfigurationMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *TargetConfigurationMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[targetconfiguration.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *TargetConfigurationMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[targetconfiguration.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TargetConfigurationMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, targetconfiguration.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *TargetConfigurationMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TargetConfigurationMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TargetConfiguration entity.
// If the TargetConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetConfigurationMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *TargetConfigurationMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[targetconfiguration.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *TargetConfigurationMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[targetconfiguration.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TargetConfigurationMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, targetconfiguration.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *TargetConfigurationMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *TargetConfigurationMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the TargetConfiguration entity.
// If the TargetConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetConfigurationMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *TargetConfigurationMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[targetconfiguration.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *TargetConfigurationMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[targetconfiguration.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *TargetConfigurationMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, targetconfiguration.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *TargetConfigurationMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TargetConfigurationMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TargetConfiguration entity.
// If the TargetConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetConfigurationMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *TargetConfigurationMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TargetConfigurationMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *TargetConfigurationMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[targetconfiguration.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *TargetConfigurationMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[targetconfiguration.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TargetConfigurationMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, targetconfiguration.FieldTenantID)
}

// SetName sets the "name" field.
func (m *TargetConfigurationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TargetConfigurationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TargetConfiguration entity.
// If the TargetConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetConfigurationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TargetConfigurationMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TargetConfigurationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TargetConfigurationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TargetConfiguration entity.
// If the TargetConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetConfigurationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TargetConfigurationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[targetconfiguration.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TargetConfigurationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[targetconfiguration.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TargetConfigurationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, targetconfiguration.FieldDescription)
}

// SetProviderType sets the "provider_type" field.
func (m *TargetConfigurationMutation) SetProviderType(s string) {
	m.provider_type = &s
}

// ProviderType returns the value of the "provider_type" field in the mutation.
func (m *TargetConfigurationMutation) ProviderType() (r string, exists bool) {
	v := m.provider_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderType returns the old "provider_type" field's value of the TargetConfiguration entity.
// If the TargetConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetConfigurationMutation) OldProviderType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderType: %w", err)
	}
	return oldValue.ProviderType, nil
}

// ResetProviderType resets all changes to the "provider_type" field.
func (m *TargetConfigurationMutation) ResetProviderType() {
	m.provider_type = nil
}

// SetCredentialsEncrypted sets the "credentials_encrypted" field.
func (m *TargetConfigurationMutation) SetCredentialsEncrypted(b []byte) {
	m.credentials_encrypted = &b
}

// CredentialsEncrypted returns the value of the "credentials_encrypted" field in the mutation.
func (m *TargetConfigurationMutation) CredentialsEncrypted() (r []byte, exists bool) {
	v := m.credentials_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialsEncrypted returns the old "credentials_encrypted" field's value of the TargetConfiguration entity.
// If the TargetConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetConfigurationMutation) OldCredentialsEncrypted(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialsEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialsEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialsEncrypted: %w", err)
	}
	return oldValue.CredentialsEncrypted, nil
}

// ResetCredentialsEncrypted resets all changes to the "credentials_encrypted" field.
func (m *TargetConfigurationMutation) ResetCredentialsEncrypted() {
	m.credentials_encrypted = nil
}

// SetConfig sets the "config" field.
func (m *TargetConfigurationMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *TargetConfigurationMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the TargetConfiguration entity.
// If the TargetConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetConfigurationMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *TargetConfigurationMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[targetconfiguration.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *TargetConfigurationMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[targetconfiguration.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *TargetConfigurationMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, targetconfiguration.FieldConfig)
}

// SetStatus sets the "status" field.
func (m *TargetConfigurationMutation) SetStatus(t targetconfiguration.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TargetConfigurationMutation) Status() (r targetconfiguration.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TargetConfiguration entity.
// If the TargetConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetConfigurationMutation) OldStatus(ctx context.Context) (v targetconfiguration.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TargetConfigurationMutation) ResetStatus() {
	m.status = nil
}

// SetStatusMessage sets the "status_message" field.
func (m *TargetConfigurationMutation) SetStatusMessage(s string) {
	m.status_message = &s
}

// StatusMessage returns the value of the "status_message" field in the mutation.
func (m *TargetConfigurationMutation) StatusMessage() (r string, exists bool) {
	v := m.status_message
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusMessage returns the old "status_message" field's value of the TargetConfiguration entity.
// If the TargetConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetConfigurationMutation) OldStatusMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusMessage: %w", err)
	}
	return oldValue.StatusMessage, nil
}

// ClearStatusMessage clears the value of the "status_message" field.
func (m *TargetConfigurationMutation) ClearStatusMessage() {
	m.status_message = nil
	m.clearedFields[targetconfiguration.FieldStatusMessage] = struct{}{}
}

// StatusMessageCleared returns if the "status_message" field was cleared in this mutation.
func (m *TargetConfigurationMutation) StatusMessageCleared() bool {
	_, ok := m.clearedFields[targetconfiguration.FieldStatusMessage]
	return ok
}

// ResetStatusMessage resets all changes to the "status_message" field.
func (m *TargetConfigurationMutation) ResetStatusMessage() {
	m.status_message = nil
	delete(m.clearedFields, targetconfiguration.FieldStatusMessage)
}

// SetLastDeploymentAt sets the "last_deployment_at" field.
func (m *TargetConfigurationMutation) SetLastDeploymentAt(t time.Time) {
	m.last_deployment_at = &t
}

// LastDeploymentAt returns the value of the "last_deployment_at" field in the mutation.
func (m *TargetConfigurationMutation) LastDeploymentAt() (r time.Time, exists bool) {
	v := m.last_deployment_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastDeploymentAt returns the old "last_deployment_at" field's value of the TargetConfiguration entity.
// If the TargetConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetConfigurationMutation) OldLastDeploymentAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastDeploymentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastDeploymentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastDeploymentAt: %w", err)
	}
	return oldValue.LastDeploymentAt, nil
}

// ClearLastDeploymentAt clears the value of the "last_deployment_at" field.
func (m *TargetConfigurationMutation) ClearLastDeploymentAt() {
	m.last_deployment_at = nil
	m.clearedFields[targetconfiguration.FieldLastDeploymentAt] = struct{}{}
}

// LastDeploymentAtCleared returns if the "last_deployment_at" field was cleared in this mutation.
func (m *TargetConfigurationMutation) LastDeploymentAtCleared() bool {
	_, ok := m.clearedFields[targetconfiguration.FieldLastDeploymentAt]
	return ok
}

// ResetLastDeploymentAt resets all changes to the "last_deployment_at" field.
func (m *TargetConfigurationMutation) ResetLastDeploymentAt() {
	m.last_deployment_at = nil
	delete(m.clearedFields, targetconfiguration.FieldLastDeploymentAt)
}

// AddJobIDs adds the "jobs" edge to the DeploymentJob entity by ids.
func (m *TargetConfigurationMutation) AddJobIDs(ids ...string) {
	if m.jobs == nil {
		m.jobs = make(map[string]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the DeploymentJob entity.
func (m *TargetConfigurationMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the DeploymentJob entity was cleared.
func (m *TargetConfigurationMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the DeploymentJob entity by IDs.
func (m *TargetConfigurationMutation) RemoveJobIDs(ids ...string) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the DeploymentJob entity.
func (m *TargetConfigurationMutation) RemovedJobsIDs() (ids []string) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *TargetConfigurationMutation) JobsIDs() (ids []string) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *TargetConfigurationMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// AddDeploymentTargetIDs adds the "deployment_targets" edge to the DeploymentTarget entity by ids.
func (m *TargetConfigurationMutation) AddDeploymentTargetIDs(ids ...string) {
	if m.deployment_targets == nil {
		m.deployment_targets = make(map[string]struct{})
	}
	for i := range ids {
		m.deployment_targets[ids[i]] = struct{}{}
	}
}

// ClearDeploymentTargets clears the "deployment_targets" edge to the DeploymentTarget entity.
func (m *TargetConfigurationMutation) ClearDeploymentTargets() {
	m.cleareddeployment_targets = true
}

// DeploymentTargetsCleared reports if the "deployment_targets" edge to the DeploymentTarget entity was cleared.
func (m *TargetConfigurationMutation) DeploymentTargetsCleared() bool {
	return m.cleareddeployment_targets
}

// RemoveDeploymentTargetIDs removes the "deployment_targets" edge to the DeploymentTarget entity by IDs.
func (m *TargetConfigurationMutation) RemoveDeploymentTargetIDs(ids ...string) {
	if m.removeddeployment_targets == nil {
		m.removeddeployment_targets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.deployment_targets, ids[i])
		m.removeddeployment_targets[ids[i]] = struct{}{}
	}
}

// RemovedDeploymentTargets returns the removed IDs of the "deployment_targets" edge to the DeploymentTarget entity.
func (m *TargetConfigurationMutation) RemovedDeploymentTargetsIDs() (ids []string) {
	for id := range m.removeddeployment_targets {
		ids = append(ids, id)
	}
	return
}

// DeploymentTargetsIDs returns the "deployment_targets" edge IDs in the mutation.
func (m *TargetConfigurationMutation) DeploymentTargetsIDs() (ids []string) {
	for id := range m.deployment_targets {
		ids = append(ids, id)
	}
	return
}

// ResetDeploymentTargets resets all changes to the "deployment_targets" edge.
func (m *TargetConfigurationMutation) ResetDeploymentTargets() {
	m.deployment_targets = nil
	m.cleareddeployment_targets = false
	m.removeddeployment_targets = nil
}

// Where appends a list predicates to the TargetConfigurationMutation builder.
func (m *TargetConfigurationMutation) Where(ps ...predicate.TargetConfiguration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TargetConfigurationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TargetConfigurationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TargetConfiguration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TargetConfigurationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TargetConfigurationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TargetConfiguration).
func (m *TargetConfigurationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TargetConfigurationMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_by != nil {
		fields = append(fields, targetconfiguration.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, targetconfiguration.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, targetconfiguration.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, targetconfiguration.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, targetconfiguration.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, targetconfiguration.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, targetconfiguration.FieldName)
	}
	if m.description != nil {
		fields = append(fields, targetconfiguration.FieldDescription)
	}
	if m.provider_type != nil {
		fields = append(fields, targetconfiguration.FieldProviderType)
	}
	if m.credentials_encrypted != nil {
		fields = append(fields, targetconfiguration.FieldCredentialsEncrypted)
	}
	if m._config != nil {
		fields = append(fields, targetconfiguration.FieldConfig)
	}
	if m.status != nil {
		fields = append(fields, targetconfiguration.FieldStatus)
	}
	if m.status_message != nil {
		fields = append(fields, targetconfiguration.FieldStatusMessage)
	}
	if m.last_deployment_at != nil {
		fields = append(fields, targetconfiguration.FieldLastDeploymentAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TargetConfigurationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case targetconfiguration.FieldCreateBy:
		return m.CreateBy()
	case targetconfiguration.FieldUpdateBy:
		return m.UpdateBy()
	case targetconfiguration.FieldCreateTime:
		return m.CreateTime()
	case targetconfiguration.FieldUpdateTime:
		return m.UpdateTime()
	case targetconfiguration.FieldDeleteTime:
		return m.DeleteTime()
	case targetconfiguration.FieldTenantID:
		return m.TenantID()
	case targetconfiguration.FieldName:
		return m.Name()
	case targetconfiguration.FieldDescription:
		return m.Description()
	case targetconfiguration.FieldProviderType:
		return m.ProviderType()
	case targetconfiguration.FieldCredentialsEncrypted:
		return m.CredentialsEncrypted()
	case targetconfiguration.FieldConfig:
		return m.Config()
	case targetconfiguration.FieldStatus:
		return m.Status()
	case targetconfiguration.FieldStatusMessage:
		return m.StatusMessage()
	case targetconfiguration.FieldLastDeploymentAt:
		return m.LastDeploymentAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TargetConfigurationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case targetconfiguration.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case targetconfiguration.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case targetconfiguration.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case targetconfiguration.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case targetconfiguration.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case targetconfiguration.FieldTenantID:
		return m.OldTenantID(ctx)
	case targetconfiguration.FieldName:
		return m.OldName(ctx)
	case targetconfiguration.FieldDescription:
		return m.OldDescription(ctx)
	case targetconfiguration.FieldProviderType:
		return m.OldProviderType(ctx)
	case targetconfiguration.FieldCredentialsEncrypted:
		return m.OldCredentialsEncrypted(ctx)
	case targetconfiguration.FieldConfig:
		return m.OldConfig(ctx)
	case targetconfiguration.FieldStatus:
		return m.OldStatus(ctx)
	case targetconfiguration.FieldStatusMessage:
		return m.OldStatusMessage(ctx)
	case targetconfiguration.FieldLastDeploymentAt:
		return m.OldLastDeploymentAt(ctx)
	}
	return nil, fmt.Errorf("unknown TargetConfiguration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TargetConfigurationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case targetconfiguration.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case targetconfiguration.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case targetconfiguration.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case targetconfiguration.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case targetconfiguration.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case targetconfiguration.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case targetconfiguration.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case targetconfiguration.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case targetconfiguration.FieldProviderType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderType(v)
		return nil
	case targetconfiguration.FieldCredentialsEncrypted:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialsEncrypted(v)
		return nil
	case targetconfiguration.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case targetconfiguration.FieldStatus:
		v, ok := value.(targetconfiguration.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case targetconfiguration.FieldStatusMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusMessage(v)
		return nil
	case targetconfiguration.FieldLastDeploymentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastDeploymentAt(v)
		return nil
	}
	return fmt.Errorf("unknown TargetConfiguration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TargetConfigurationMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, targetconfiguration.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, targetconfiguration.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, targetconfiguration.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TargetConfigurationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case targetconfiguration.FieldCreateBy:
		return m.AddedCreateBy()
	case targetconfiguration.FieldUpdateBy:
		return m.AddedUpdateBy()
	case targetconfiguration.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TargetConfigurationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case targetconfiguration.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case targetconfiguration.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case targetconfiguration.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown TargetConfiguration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TargetConfigurationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(targetconfiguration.FieldCreateBy) {
		fields = append(fields, targetconfiguration.FieldCreateBy)
	}
	if m.FieldCleared(targetconfiguration.FieldUpdateBy) {
		fields = append(fields, targetconfiguration.FieldUpdateBy)
	}
	if m.FieldCleared(targetconfiguration.FieldCreateTime) {
		fields = append(fields, targetconfiguration.FieldCreateTime)
	}
	if m.FieldCleared(targetconfiguration.FieldUpdateTime) {
		fields = append(fields, targetconfiguration.FieldUpdateTime)
	}
	if m.FieldCleared(targetconfiguration.FieldDeleteTime) {
		fields = append(fields, targetconfiguration.FieldDeleteTime)
	}
	if m.FieldCleared(targetconfiguration.FieldTenantID) {
		fields = append(fields, targetconfiguration.FieldTenantID)
	}
	if m.FieldCleared(targetconfiguration.FieldDescription) {
		fields = append(fields, targetconfiguration.FieldDescription)
	}
	if m.FieldCleared(targetconfiguration.FieldConfig) {
		fields = append(fields, targetconfiguration.FieldConfig)
	}
	if m.FieldCleared(targetconfiguration.FieldStatusMessage) {
		fields = append(fields, targetconfiguration.FieldStatusMessage)
	}
	if m.FieldCleared(targetconfiguration.FieldLastDeploymentAt) {
		fields = append(fields, targetconfiguration.FieldLastDeploymentAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TargetConfigurationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TargetConfigurationMutation) ClearField(name string) error {
	switch name {
	case targetconfiguration.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case targetconfiguration.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case targetconfiguration.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case targetconfiguration.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case targetconfiguration.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case targetconfiguration.FieldTenantID:
		m.ClearTenantID()
		return nil
	case targetconfiguration.FieldDescription:
		m.ClearDescription()
		return nil
	case targetconfiguration.FieldConfig:
		m.ClearConfig()
		return nil
	case targetconfiguration.FieldStatusMessage:
		m.ClearStatusMessage()
		return nil
	case targetconfiguration.FieldLastDeploymentAt:
		m.ClearLastDeploymentAt()
		return nil
	}
	return fmt.Errorf("unknown TargetConfiguration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TargetConfigurationMutation) ResetField(name string) error {
	switch name {
	case targetconfiguration.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case targetconfiguration.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case targetconfiguration.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case targetconfiguration.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case targetconfiguration.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case targetconfiguration.FieldTenantID:
		m.ResetTenantID()
		return nil
	case targetconfiguration.FieldName:
		m.ResetName()
		return nil
	case targetconfiguration.FieldDescription:
		m.ResetDescription()
		return nil
	case targetconfiguration.FieldProviderType:
		m.ResetProviderType()
		return nil
	case targetconfiguration.FieldCredentialsEncrypted:
		m.ResetCredentialsEncrypted()
		return nil
	case targetconfiguration.FieldConfig:
		m.ResetConfig()
		return nil
	case targetconfiguration.FieldStatus:
		m.ResetStatus()
		return nil
	case targetconfiguration.FieldStatusMessage:
		m.ResetStatusMessage()
		return nil
	case targetconfiguration.FieldLastDeploymentAt:
		m.ResetLastDeploymentAt()
		return nil
	}
	return fmt.Errorf("unknown TargetConfiguration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TargetConfigurationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.jobs != nil {
		edges = append(edges, targetconfiguration.EdgeJobs)
	}
	if m.deployment_targets != nil {
		edges = append(edges, targetconfiguration.EdgeDeploymentTargets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TargetConfigurationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case targetconfiguration.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	case targetconfiguration.EdgeDeploymentTargets:
		ids := make([]ent.Value, 0, len(m.deployment_targets))
		for id := range m.deployment_targets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TargetConfigurationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedjobs != nil {
		edges = append(edges, targetconfiguration.EdgeJobs)
	}
	if m.removeddeployment_targets != nil {
		edges = append(edges, targetconfiguration.EdgeDeploymentTargets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TargetConfigurationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case targetconfiguration.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	case targetconfiguration.EdgeDeploymentTargets:
		ids := make([]ent.Value, 0, len(m.removeddeployment_targets))
		for id := range m.removeddeployment_targets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TargetConfigurationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedjobs {
		edges = append(edges, targetconfiguration.EdgeJobs)
	}
	if m.cleareddeployment_targets {
		edges = append(edges, targetconfiguration.EdgeDeploymentTargets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TargetConfigurationMutation) EdgeCleared(name string) bool {
	switch name {
	case targetconfiguration.EdgeJobs:
		return m.clearedjobs
	case targetconfiguration.EdgeDeploymentTargets:
		return m.cleareddeployment_targets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TargetConfigurationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TargetConfiguration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TargetConfigurationMutation) ResetEdge(name string) error {
	switch name {
	case targetconfiguration.EdgeJobs:
		m.ResetJobs()
		return nil
	case targetconfiguration.EdgeDeploymentTargets:
		m.ResetDeploymentTargets()
		return nil
	}
	return fmt.Errorf("unknown TargetConfiguration edge %s", name)
}
