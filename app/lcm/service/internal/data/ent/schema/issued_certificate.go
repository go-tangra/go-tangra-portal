package schema

import (
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"entgo.io/ent/schema/index"
)

// IssuedCertificate holds the schema definition for certificates issued by the LCM service to clients.
// This is separate from MtlsCertificate which is for client authentication to the LCM service.
type IssuedCertificate struct {
	ent.Schema
}

// Annotations of the IssuedCertificate.
func (IssuedCertificate) Annotations() []schema.Annotation {
	return []schema.Annotation{
		entsql.Annotation{Table: "issued_certificates"},
		entsql.WithComments(true),
	}
}

// Fields of the IssuedCertificate.
func (IssuedCertificate) Fields() []ent.Field {
	return []ent.Field{
		field.String("id").
			Unique().
			NotEmpty().
			Comment("Unique certificate identifier"),
		
		field.String("client_id").
			Optional().
			Comment("Legacy client identifier (deprecated - use lcm_client relationship)"),
		
		field.String("issuer_name").
			NotEmpty().
			Comment("Name of the issuer that issued this certificate"),

		field.String("issuer_type").
			Optional().
			Comment("Type of the issuer (e.g., 'self_signed', 'acme')"),

		field.Uint32("tenant_id").
			Optional().
			Comment("Tenant ID for multi-tenancy"),

		field.String("common_name").
			Optional().
			Comment("Certificate common name"),

		field.JSON("domains", []string{}).
			Comment("Domain names covered by this certificate (DNS SANs)"),

		field.JSON("ip_addresses", []string{}).
			Optional().
			Comment("IP addresses covered by this certificate (IP SANs)"),
		
		field.Enum("status").
			Values("unspecified", "pending", "processing", "issued", "expired", "revoked", "failed", "renewed").
			Default("pending").
			Comment("Current certificate status"),
		
		field.Text("cert_pem").
			Optional().
			Comment("Certificate in PEM format"),
		
		field.Text("private_key_pem").
			Optional().
			Comment("Private key in PEM format (encrypted, only for server-generated keys)"),

		field.Bool("server_generated_key").
			Default(false).
			Comment("True if private key was generated by server (no CSR provided)"),

		field.Text("ca_cert_pem").
			Optional().
			Comment("CA certificate chain in PEM format"),
		
		field.Text("csr_pem").
			Optional().
			Comment("Original Certificate Signing Request in PEM format"),
		
		field.String("certificate_fingerprint").
			Optional().
			Comment("Certificate fingerprint/hash"),
		
		field.String("error_message").
			Optional().
			Comment("Error message if certificate issuance failed"),
		
		field.Enum("key_type").
			Values("rsa", "ecdsa", "ed25519").
			Optional().
			Comment("Type of key used"),
		
		field.Int32("key_size").
			Optional().
			Comment("Size of the key in bits"),
		
		field.Bool("auto_renew_enabled").
			Default(false).
			Comment("Whether auto-renewal is enabled"),
		
		field.Int32("auto_renew_days_before_expiry").
			Optional().
			Default(30).
			Comment("Days before expiry to start renewal process"),
		
		field.Int32("auto_renew_max_attempts").
			Optional().
			Default(3).
			Comment("Maximum number of renewal attempts"),
		
		field.Int64("auto_renew_retry_interval_seconds").
			Optional().
			Default(3600).
			Comment("Interval between renewal retry attempts in seconds"),
		
		field.Time("last_renewal_at").
			Optional().
			Comment("Last time certificate was renewed"),
		
		field.Int32("renewal_attempts").
			Default(0).
			Comment("Number of renewal attempts made"),
		
		field.Time("expires_at").
			Optional().
			Comment("Certificate expiration time"),
		
		field.Time("revoked_at").
			Optional().
			Comment("Certificate revocation time"),
		
		field.String("revoked_reason").
			Optional().
			Comment("Reason for certificate revocation"),
		
		field.Time("created_at").
			Default(time.Now).
			Immutable().
			Comment("Certificate creation time"),
		
		field.Time("updated_at").
			Default(time.Now).
			UpdateDefault(time.Now).
			Comment("Last update time"),
	}
}

// Edges of the IssuedCertificate.
func (IssuedCertificate) Edges() []ent.Edge {
	return []ent.Edge{
		// Note: We use issuer_name as a string field instead of a foreign key
		// This allows for more flexible issuer references and avoids complex joins
		edge.From("lcm_client", LcmClient.Type).
			Ref("issued_certificates").
			Unique().
			Comment("The LCM client that owns this certificate"),

		edge.To("certificate_details", CertificateDetails.Type).
			Unique().
			Comment("Detailed certificate information parsed from PEM"),

		edge.From("permissions", CertificatePermission.Type).
			Ref("issued_certificate").
			Comment("Permissions granted for this certificate to other clients"),
	}
}

// Indexes of the IssuedCertificate.
func (IssuedCertificate) Indexes() []ent.Index {
	return []ent.Index{
		index.Fields("id"),
		index.Fields("tenant_id"),
		index.Fields("client_id"),
		index.Fields("issuer_name"),
		index.Fields("status"),
		index.Fields("expires_at"),
		index.Fields("created_at"),
		index.Fields("tenant_id", "status"),
		index.Fields("tenant_id", "client_id"),
		index.Fields("client_id", "status"),
		index.Fields("client_id", "issuer_name"),
	}
}