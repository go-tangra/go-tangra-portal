// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/acmeissuer"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/auditlog"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/certificatedetails"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/certificatepermission"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/certificaterenewal"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/certificaterequest"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/clientissuer"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/issuedcertificate"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/issuer"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/lcmca"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/lcmclient"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/mtlscertificate"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/mtlscertificaterequest"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/predicate"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/selfsignedissuer"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/tenantsecret"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAcmeIssuer             = "AcmeIssuer"
	TypeAuditLog               = "AuditLog"
	TypeCertificateDetails     = "CertificateDetails"
	TypeCertificatePermission  = "CertificatePermission"
	TypeCertificateRenewal     = "CertificateRenewal"
	TypeCertificateRequest     = "CertificateRequest"
	TypeClientIssuer           = "ClientIssuer"
	TypeIssuedCertificate      = "IssuedCertificate"
	TypeIssuer                 = "Issuer"
	TypeLcmCa                  = "LcmCa"
	TypeLcmClient              = "LcmClient"
	TypeMtlsCertificate        = "MtlsCertificate"
	TypeMtlsCertificateRequest = "MtlsCertificateRequest"
	TypeSelfSignedIssuer       = "SelfSignedIssuer"
	TypeTenantSecret           = "TenantSecret"
)

// AcmeIssuerMutation represents an operation that mutates the AcmeIssuer nodes in the graph.
type AcmeIssuerMutation struct {
	config
	op              Op
	typ             string
	id              *int
	email           *string
	endpoint        *string
	key_type        *acmeissuer.KeyType
	key_size        *int32
	addkey_size     *int32
	key_pem         *string
	max_retries     *int32
	addmax_retries  *int32
	base_delay      *string
	challenge_type  *acmeissuer.ChallengeType
	provider_name   *string
	provider_config *map[string]string
	eab_kid         *string
	eab_hmac_key    *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	issuer          *uint32
	clearedissuer   bool
	done            bool
	oldValue        func(context.Context) (*AcmeIssuer, error)
	predicates      []predicate.AcmeIssuer
}

var _ ent.Mutation = (*AcmeIssuerMutation)(nil)

// acmeissuerOption allows management of the mutation configuration using functional options.
type acmeissuerOption func(*AcmeIssuerMutation)

// newAcmeIssuerMutation creates new mutation for the AcmeIssuer entity.
func newAcmeIssuerMutation(c config, op Op, opts ...acmeissuerOption) *AcmeIssuerMutation {
	m := &AcmeIssuerMutation{
		config:        c,
		op:            op,
		typ:           TypeAcmeIssuer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAcmeIssuerID sets the ID field of the mutation.
func withAcmeIssuerID(id int) acmeissuerOption {
	return func(m *AcmeIssuerMutation) {
		var (
			err   error
			once  sync.Once
			value *AcmeIssuer
		)
		m.oldValue = func(ctx context.Context) (*AcmeIssuer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AcmeIssuer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAcmeIssuer sets the old AcmeIssuer of the mutation.
func withAcmeIssuer(node *AcmeIssuer) acmeissuerOption {
	return func(m *AcmeIssuerMutation) {
		m.oldValue = func(context.Context) (*AcmeIssuer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AcmeIssuerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AcmeIssuerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AcmeIssuerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AcmeIssuerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AcmeIssuer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *AcmeIssuerMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AcmeIssuerMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the AcmeIssuer entity.
// If the AcmeIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeIssuerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AcmeIssuerMutation) ResetEmail() {
	m.email = nil
}

// SetEndpoint sets the "endpoint" field.
func (m *AcmeIssuerMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *AcmeIssuerMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the AcmeIssuer entity.
// If the AcmeIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeIssuerMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *AcmeIssuerMutation) ResetEndpoint() {
	m.endpoint = nil
}

// SetKeyType sets the "key_type" field.
func (m *AcmeIssuerMutation) SetKeyType(at acmeissuer.KeyType) {
	m.key_type = &at
}

// KeyType returns the value of the "key_type" field in the mutation.
func (m *AcmeIssuerMutation) KeyType() (r acmeissuer.KeyType, exists bool) {
	v := m.key_type
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyType returns the old "key_type" field's value of the AcmeIssuer entity.
// If the AcmeIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeIssuerMutation) OldKeyType(ctx context.Context) (v acmeissuer.KeyType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyType: %w", err)
	}
	return oldValue.KeyType, nil
}

// ResetKeyType resets all changes to the "key_type" field.
func (m *AcmeIssuerMutation) ResetKeyType() {
	m.key_type = nil
}

// SetKeySize sets the "key_size" field.
func (m *AcmeIssuerMutation) SetKeySize(i int32) {
	m.key_size = &i
	m.addkey_size = nil
}

// KeySize returns the value of the "key_size" field in the mutation.
func (m *AcmeIssuerMutation) KeySize() (r int32, exists bool) {
	v := m.key_size
	if v == nil {
		return
	}
	return *v, true
}

// OldKeySize returns the old "key_size" field's value of the AcmeIssuer entity.
// If the AcmeIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeIssuerMutation) OldKeySize(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeySize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeySize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeySize: %w", err)
	}
	return oldValue.KeySize, nil
}

// AddKeySize adds i to the "key_size" field.
func (m *AcmeIssuerMutation) AddKeySize(i int32) {
	if m.addkey_size != nil {
		*m.addkey_size += i
	} else {
		m.addkey_size = &i
	}
}

// AddedKeySize returns the value that was added to the "key_size" field in this mutation.
func (m *AcmeIssuerMutation) AddedKeySize() (r int32, exists bool) {
	v := m.addkey_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetKeySize resets all changes to the "key_size" field.
func (m *AcmeIssuerMutation) ResetKeySize() {
	m.key_size = nil
	m.addkey_size = nil
}

// SetKeyPem sets the "key_pem" field.
func (m *AcmeIssuerMutation) SetKeyPem(s string) {
	m.key_pem = &s
}

// KeyPem returns the value of the "key_pem" field in the mutation.
func (m *AcmeIssuerMutation) KeyPem() (r string, exists bool) {
	v := m.key_pem
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyPem returns the old "key_pem" field's value of the AcmeIssuer entity.
// If the AcmeIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeIssuerMutation) OldKeyPem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyPem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyPem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyPem: %w", err)
	}
	return oldValue.KeyPem, nil
}

// ClearKeyPem clears the value of the "key_pem" field.
func (m *AcmeIssuerMutation) ClearKeyPem() {
	m.key_pem = nil
	m.clearedFields[acmeissuer.FieldKeyPem] = struct{}{}
}

// KeyPemCleared returns if the "key_pem" field was cleared in this mutation.
func (m *AcmeIssuerMutation) KeyPemCleared() bool {
	_, ok := m.clearedFields[acmeissuer.FieldKeyPem]
	return ok
}

// ResetKeyPem resets all changes to the "key_pem" field.
func (m *AcmeIssuerMutation) ResetKeyPem() {
	m.key_pem = nil
	delete(m.clearedFields, acmeissuer.FieldKeyPem)
}

// SetMaxRetries sets the "max_retries" field.
func (m *AcmeIssuerMutation) SetMaxRetries(i int32) {
	m.max_retries = &i
	m.addmax_retries = nil
}

// MaxRetries returns the value of the "max_retries" field in the mutation.
func (m *AcmeIssuerMutation) MaxRetries() (r int32, exists bool) {
	v := m.max_retries
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxRetries returns the old "max_retries" field's value of the AcmeIssuer entity.
// If the AcmeIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeIssuerMutation) OldMaxRetries(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxRetries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxRetries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxRetries: %w", err)
	}
	return oldValue.MaxRetries, nil
}

// AddMaxRetries adds i to the "max_retries" field.
func (m *AcmeIssuerMutation) AddMaxRetries(i int32) {
	if m.addmax_retries != nil {
		*m.addmax_retries += i
	} else {
		m.addmax_retries = &i
	}
}

// AddedMaxRetries returns the value that was added to the "max_retries" field in this mutation.
func (m *AcmeIssuerMutation) AddedMaxRetries() (r int32, exists bool) {
	v := m.addmax_retries
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxRetries resets all changes to the "max_retries" field.
func (m *AcmeIssuerMutation) ResetMaxRetries() {
	m.max_retries = nil
	m.addmax_retries = nil
}

// SetBaseDelay sets the "base_delay" field.
func (m *AcmeIssuerMutation) SetBaseDelay(s string) {
	m.base_delay = &s
}

// BaseDelay returns the value of the "base_delay" field in the mutation.
func (m *AcmeIssuerMutation) BaseDelay() (r string, exists bool) {
	v := m.base_delay
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseDelay returns the old "base_delay" field's value of the AcmeIssuer entity.
// If the AcmeIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeIssuerMutation) OldBaseDelay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseDelay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseDelay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseDelay: %w", err)
	}
	return oldValue.BaseDelay, nil
}

// ResetBaseDelay resets all changes to the "base_delay" field.
func (m *AcmeIssuerMutation) ResetBaseDelay() {
	m.base_delay = nil
}

// SetChallengeType sets the "challenge_type" field.
func (m *AcmeIssuerMutation) SetChallengeType(at acmeissuer.ChallengeType) {
	m.challenge_type = &at
}

// ChallengeType returns the value of the "challenge_type" field in the mutation.
func (m *AcmeIssuerMutation) ChallengeType() (r acmeissuer.ChallengeType, exists bool) {
	v := m.challenge_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChallengeType returns the old "challenge_type" field's value of the AcmeIssuer entity.
// If the AcmeIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeIssuerMutation) OldChallengeType(ctx context.Context) (v acmeissuer.ChallengeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChallengeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChallengeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChallengeType: %w", err)
	}
	return oldValue.ChallengeType, nil
}

// ResetChallengeType resets all changes to the "challenge_type" field.
func (m *AcmeIssuerMutation) ResetChallengeType() {
	m.challenge_type = nil
}

// SetProviderName sets the "provider_name" field.
func (m *AcmeIssuerMutation) SetProviderName(s string) {
	m.provider_name = &s
}

// ProviderName returns the value of the "provider_name" field in the mutation.
func (m *AcmeIssuerMutation) ProviderName() (r string, exists bool) {
	v := m.provider_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderName returns the old "provider_name" field's value of the AcmeIssuer entity.
// If the AcmeIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeIssuerMutation) OldProviderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderName: %w", err)
	}
	return oldValue.ProviderName, nil
}

// ClearProviderName clears the value of the "provider_name" field.
func (m *AcmeIssuerMutation) ClearProviderName() {
	m.provider_name = nil
	m.clearedFields[acmeissuer.FieldProviderName] = struct{}{}
}

// ProviderNameCleared returns if the "provider_name" field was cleared in this mutation.
func (m *AcmeIssuerMutation) ProviderNameCleared() bool {
	_, ok := m.clearedFields[acmeissuer.FieldProviderName]
	return ok
}

// ResetProviderName resets all changes to the "provider_name" field.
func (m *AcmeIssuerMutation) ResetProviderName() {
	m.provider_name = nil
	delete(m.clearedFields, acmeissuer.FieldProviderName)
}

// SetProviderConfig sets the "provider_config" field.
func (m *AcmeIssuerMutation) SetProviderConfig(value map[string]string) {
	m.provider_config = &value
}

// ProviderConfig returns the value of the "provider_config" field in the mutation.
func (m *AcmeIssuerMutation) ProviderConfig() (r map[string]string, exists bool) {
	v := m.provider_config
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderConfig returns the old "provider_config" field's value of the AcmeIssuer entity.
// If the AcmeIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeIssuerMutation) OldProviderConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderConfig: %w", err)
	}
	return oldValue.ProviderConfig, nil
}

// ClearProviderConfig clears the value of the "provider_config" field.
func (m *AcmeIssuerMutation) ClearProviderConfig() {
	m.provider_config = nil
	m.clearedFields[acmeissuer.FieldProviderConfig] = struct{}{}
}

// ProviderConfigCleared returns if the "provider_config" field was cleared in this mutation.
func (m *AcmeIssuerMutation) ProviderConfigCleared() bool {
	_, ok := m.clearedFields[acmeissuer.FieldProviderConfig]
	return ok
}

// ResetProviderConfig resets all changes to the "provider_config" field.
func (m *AcmeIssuerMutation) ResetProviderConfig() {
	m.provider_config = nil
	delete(m.clearedFields, acmeissuer.FieldProviderConfig)
}

// SetEabKid sets the "eab_kid" field.
func (m *AcmeIssuerMutation) SetEabKid(s string) {
	m.eab_kid = &s
}

// EabKid returns the value of the "eab_kid" field in the mutation.
func (m *AcmeIssuerMutation) EabKid() (r string, exists bool) {
	v := m.eab_kid
	if v == nil {
		return
	}
	return *v, true
}

// OldEabKid returns the old "eab_kid" field's value of the AcmeIssuer entity.
// If the AcmeIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeIssuerMutation) OldEabKid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEabKid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEabKid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEabKid: %w", err)
	}
	return oldValue.EabKid, nil
}

// ClearEabKid clears the value of the "eab_kid" field.
func (m *AcmeIssuerMutation) ClearEabKid() {
	m.eab_kid = nil
	m.clearedFields[acmeissuer.FieldEabKid] = struct{}{}
}

// EabKidCleared returns if the "eab_kid" field was cleared in this mutation.
func (m *AcmeIssuerMutation) EabKidCleared() bool {
	_, ok := m.clearedFields[acmeissuer.FieldEabKid]
	return ok
}

// ResetEabKid resets all changes to the "eab_kid" field.
func (m *AcmeIssuerMutation) ResetEabKid() {
	m.eab_kid = nil
	delete(m.clearedFields, acmeissuer.FieldEabKid)
}

// SetEabHmacKey sets the "eab_hmac_key" field.
func (m *AcmeIssuerMutation) SetEabHmacKey(s string) {
	m.eab_hmac_key = &s
}

// EabHmacKey returns the value of the "eab_hmac_key" field in the mutation.
func (m *AcmeIssuerMutation) EabHmacKey() (r string, exists bool) {
	v := m.eab_hmac_key
	if v == nil {
		return
	}
	return *v, true
}

// OldEabHmacKey returns the old "eab_hmac_key" field's value of the AcmeIssuer entity.
// If the AcmeIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeIssuerMutation) OldEabHmacKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEabHmacKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEabHmacKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEabHmacKey: %w", err)
	}
	return oldValue.EabHmacKey, nil
}

// ClearEabHmacKey clears the value of the "eab_hmac_key" field.
func (m *AcmeIssuerMutation) ClearEabHmacKey() {
	m.eab_hmac_key = nil
	m.clearedFields[acmeissuer.FieldEabHmacKey] = struct{}{}
}

// EabHmacKeyCleared returns if the "eab_hmac_key" field was cleared in this mutation.
func (m *AcmeIssuerMutation) EabHmacKeyCleared() bool {
	_, ok := m.clearedFields[acmeissuer.FieldEabHmacKey]
	return ok
}

// ResetEabHmacKey resets all changes to the "eab_hmac_key" field.
func (m *AcmeIssuerMutation) ResetEabHmacKey() {
	m.eab_hmac_key = nil
	delete(m.clearedFields, acmeissuer.FieldEabHmacKey)
}

// SetCreatedAt sets the "created_at" field.
func (m *AcmeIssuerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AcmeIssuerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AcmeIssuer entity.
// If the AcmeIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeIssuerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AcmeIssuerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AcmeIssuerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AcmeIssuerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AcmeIssuer entity.
// If the AcmeIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AcmeIssuerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AcmeIssuerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIssuerID sets the "issuer" edge to the Issuer entity by id.
func (m *AcmeIssuerMutation) SetIssuerID(id uint32) {
	m.issuer = &id
}

// ClearIssuer clears the "issuer" edge to the Issuer entity.
func (m *AcmeIssuerMutation) ClearIssuer() {
	m.clearedissuer = true
}

// IssuerCleared reports if the "issuer" edge to the Issuer entity was cleared.
func (m *AcmeIssuerMutation) IssuerCleared() bool {
	return m.clearedissuer
}

// IssuerID returns the "issuer" edge ID in the mutation.
func (m *AcmeIssuerMutation) IssuerID() (id uint32, exists bool) {
	if m.issuer != nil {
		return *m.issuer, true
	}
	return
}

// IssuerIDs returns the "issuer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IssuerID instead. It exists only for internal usage by the builders.
func (m *AcmeIssuerMutation) IssuerIDs() (ids []uint32) {
	if id := m.issuer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIssuer resets all changes to the "issuer" edge.
func (m *AcmeIssuerMutation) ResetIssuer() {
	m.issuer = nil
	m.clearedissuer = false
}

// Where appends a list predicates to the AcmeIssuerMutation builder.
func (m *AcmeIssuerMutation) Where(ps ...predicate.AcmeIssuer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AcmeIssuerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AcmeIssuerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AcmeIssuer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AcmeIssuerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AcmeIssuerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AcmeIssuer).
func (m *AcmeIssuerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AcmeIssuerMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.email != nil {
		fields = append(fields, acmeissuer.FieldEmail)
	}
	if m.endpoint != nil {
		fields = append(fields, acmeissuer.FieldEndpoint)
	}
	if m.key_type != nil {
		fields = append(fields, acmeissuer.FieldKeyType)
	}
	if m.key_size != nil {
		fields = append(fields, acmeissuer.FieldKeySize)
	}
	if m.key_pem != nil {
		fields = append(fields, acmeissuer.FieldKeyPem)
	}
	if m.max_retries != nil {
		fields = append(fields, acmeissuer.FieldMaxRetries)
	}
	if m.base_delay != nil {
		fields = append(fields, acmeissuer.FieldBaseDelay)
	}
	if m.challenge_type != nil {
		fields = append(fields, acmeissuer.FieldChallengeType)
	}
	if m.provider_name != nil {
		fields = append(fields, acmeissuer.FieldProviderName)
	}
	if m.provider_config != nil {
		fields = append(fields, acmeissuer.FieldProviderConfig)
	}
	if m.eab_kid != nil {
		fields = append(fields, acmeissuer.FieldEabKid)
	}
	if m.eab_hmac_key != nil {
		fields = append(fields, acmeissuer.FieldEabHmacKey)
	}
	if m.created_at != nil {
		fields = append(fields, acmeissuer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, acmeissuer.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AcmeIssuerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case acmeissuer.FieldEmail:
		return m.Email()
	case acmeissuer.FieldEndpoint:
		return m.Endpoint()
	case acmeissuer.FieldKeyType:
		return m.KeyType()
	case acmeissuer.FieldKeySize:
		return m.KeySize()
	case acmeissuer.FieldKeyPem:
		return m.KeyPem()
	case acmeissuer.FieldMaxRetries:
		return m.MaxRetries()
	case acmeissuer.FieldBaseDelay:
		return m.BaseDelay()
	case acmeissuer.FieldChallengeType:
		return m.ChallengeType()
	case acmeissuer.FieldProviderName:
		return m.ProviderName()
	case acmeissuer.FieldProviderConfig:
		return m.ProviderConfig()
	case acmeissuer.FieldEabKid:
		return m.EabKid()
	case acmeissuer.FieldEabHmacKey:
		return m.EabHmacKey()
	case acmeissuer.FieldCreatedAt:
		return m.CreatedAt()
	case acmeissuer.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AcmeIssuerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case acmeissuer.FieldEmail:
		return m.OldEmail(ctx)
	case acmeissuer.FieldEndpoint:
		return m.OldEndpoint(ctx)
	case acmeissuer.FieldKeyType:
		return m.OldKeyType(ctx)
	case acmeissuer.FieldKeySize:
		return m.OldKeySize(ctx)
	case acmeissuer.FieldKeyPem:
		return m.OldKeyPem(ctx)
	case acmeissuer.FieldMaxRetries:
		return m.OldMaxRetries(ctx)
	case acmeissuer.FieldBaseDelay:
		return m.OldBaseDelay(ctx)
	case acmeissuer.FieldChallengeType:
		return m.OldChallengeType(ctx)
	case acmeissuer.FieldProviderName:
		return m.OldProviderName(ctx)
	case acmeissuer.FieldProviderConfig:
		return m.OldProviderConfig(ctx)
	case acmeissuer.FieldEabKid:
		return m.OldEabKid(ctx)
	case acmeissuer.FieldEabHmacKey:
		return m.OldEabHmacKey(ctx)
	case acmeissuer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case acmeissuer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AcmeIssuer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AcmeIssuerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case acmeissuer.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case acmeissuer.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	case acmeissuer.FieldKeyType:
		v, ok := value.(acmeissuer.KeyType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyType(v)
		return nil
	case acmeissuer.FieldKeySize:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeySize(v)
		return nil
	case acmeissuer.FieldKeyPem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyPem(v)
		return nil
	case acmeissuer.FieldMaxRetries:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxRetries(v)
		return nil
	case acmeissuer.FieldBaseDelay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseDelay(v)
		return nil
	case acmeissuer.FieldChallengeType:
		v, ok := value.(acmeissuer.ChallengeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChallengeType(v)
		return nil
	case acmeissuer.FieldProviderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderName(v)
		return nil
	case acmeissuer.FieldProviderConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderConfig(v)
		return nil
	case acmeissuer.FieldEabKid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEabKid(v)
		return nil
	case acmeissuer.FieldEabHmacKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEabHmacKey(v)
		return nil
	case acmeissuer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case acmeissuer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AcmeIssuer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AcmeIssuerMutation) AddedFields() []string {
	var fields []string
	if m.addkey_size != nil {
		fields = append(fields, acmeissuer.FieldKeySize)
	}
	if m.addmax_retries != nil {
		fields = append(fields, acmeissuer.FieldMaxRetries)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AcmeIssuerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case acmeissuer.FieldKeySize:
		return m.AddedKeySize()
	case acmeissuer.FieldMaxRetries:
		return m.AddedMaxRetries()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AcmeIssuerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case acmeissuer.FieldKeySize:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKeySize(v)
		return nil
	case acmeissuer.FieldMaxRetries:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxRetries(v)
		return nil
	}
	return fmt.Errorf("unknown AcmeIssuer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AcmeIssuerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(acmeissuer.FieldKeyPem) {
		fields = append(fields, acmeissuer.FieldKeyPem)
	}
	if m.FieldCleared(acmeissuer.FieldProviderName) {
		fields = append(fields, acmeissuer.FieldProviderName)
	}
	if m.FieldCleared(acmeissuer.FieldProviderConfig) {
		fields = append(fields, acmeissuer.FieldProviderConfig)
	}
	if m.FieldCleared(acmeissuer.FieldEabKid) {
		fields = append(fields, acmeissuer.FieldEabKid)
	}
	if m.FieldCleared(acmeissuer.FieldEabHmacKey) {
		fields = append(fields, acmeissuer.FieldEabHmacKey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AcmeIssuerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AcmeIssuerMutation) ClearField(name string) error {
	switch name {
	case acmeissuer.FieldKeyPem:
		m.ClearKeyPem()
		return nil
	case acmeissuer.FieldProviderName:
		m.ClearProviderName()
		return nil
	case acmeissuer.FieldProviderConfig:
		m.ClearProviderConfig()
		return nil
	case acmeissuer.FieldEabKid:
		m.ClearEabKid()
		return nil
	case acmeissuer.FieldEabHmacKey:
		m.ClearEabHmacKey()
		return nil
	}
	return fmt.Errorf("unknown AcmeIssuer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AcmeIssuerMutation) ResetField(name string) error {
	switch name {
	case acmeissuer.FieldEmail:
		m.ResetEmail()
		return nil
	case acmeissuer.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	case acmeissuer.FieldKeyType:
		m.ResetKeyType()
		return nil
	case acmeissuer.FieldKeySize:
		m.ResetKeySize()
		return nil
	case acmeissuer.FieldKeyPem:
		m.ResetKeyPem()
		return nil
	case acmeissuer.FieldMaxRetries:
		m.ResetMaxRetries()
		return nil
	case acmeissuer.FieldBaseDelay:
		m.ResetBaseDelay()
		return nil
	case acmeissuer.FieldChallengeType:
		m.ResetChallengeType()
		return nil
	case acmeissuer.FieldProviderName:
		m.ResetProviderName()
		return nil
	case acmeissuer.FieldProviderConfig:
		m.ResetProviderConfig()
		return nil
	case acmeissuer.FieldEabKid:
		m.ResetEabKid()
		return nil
	case acmeissuer.FieldEabHmacKey:
		m.ResetEabHmacKey()
		return nil
	case acmeissuer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case acmeissuer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AcmeIssuer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AcmeIssuerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.issuer != nil {
		edges = append(edges, acmeissuer.EdgeIssuer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AcmeIssuerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case acmeissuer.EdgeIssuer:
		if id := m.issuer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AcmeIssuerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AcmeIssuerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AcmeIssuerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedissuer {
		edges = append(edges, acmeissuer.EdgeIssuer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AcmeIssuerMutation) EdgeCleared(name string) bool {
	switch name {
	case acmeissuer.EdgeIssuer:
		return m.clearedissuer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AcmeIssuerMutation) ClearEdge(name string) error {
	switch name {
	case acmeissuer.EdgeIssuer:
		m.ClearIssuer()
		return nil
	}
	return fmt.Errorf("unknown AcmeIssuer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AcmeIssuerMutation) ResetEdge(name string) error {
	switch name {
	case acmeissuer.EdgeIssuer:
		m.ResetIssuer()
		return nil
	}
	return fmt.Errorf("unknown AcmeIssuer edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	create_time          *time.Time
	update_time          *time.Time
	delete_time          *time.Time
	tenant_id            *uint32
	addtenant_id         *int32
	audit_id             *string
	request_id           *string
	operation            *string
	service_name         *string
	client_id            *string
	client_common_name   *string
	client_organization  *string
	client_serial_number *string
	is_authenticated     *bool
	success              *bool
	error_code           *int32
	adderror_code        *int32
	error_message        *string
	latency_ms           *int64
	addlatency_ms        *int64
	peer_address         *string
	geo_location         *map[string]string
	log_hash             *string
	signature            *[]byte
	metadata             *map[string]string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*AuditLog, error)
	predicates           []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id uint32) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditLog entities.
func (m *AuditLogMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AuditLogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AuditLogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AuditLogMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[auditlog.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AuditLogMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AuditLogMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, auditlog.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AuditLogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AuditLogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AuditLogMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[auditlog.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AuditLogMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AuditLogMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, auditlog.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *AuditLogMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *AuditLogMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *AuditLogMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[auditlog.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *AuditLogMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *AuditLogMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, auditlog.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *AuditLogMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AuditLogMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *AuditLogMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *AuditLogMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[auditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, auditlog.FieldTenantID)
}

// SetAuditID sets the "audit_id" field.
func (m *AuditLogMutation) SetAuditID(s string) {
	m.audit_id = &s
}

// AuditID returns the value of the "audit_id" field in the mutation.
func (m *AuditLogMutation) AuditID() (r string, exists bool) {
	v := m.audit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditID returns the old "audit_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAuditID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditID: %w", err)
	}
	return oldValue.AuditID, nil
}

// ResetAuditID resets all changes to the "audit_id" field.
func (m *AuditLogMutation) ResetAuditID() {
	m.audit_id = nil
}

// SetRequestID sets the "request_id" field.
func (m *AuditLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *AuditLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *AuditLogMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[auditlog.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *AuditLogMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *AuditLogMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, auditlog.FieldRequestID)
}

// SetOperation sets the "operation" field.
func (m *AuditLogMutation) SetOperation(s string) {
	m.operation = &s
}

// Operation returns the value of the "operation" field in the mutation.
func (m *AuditLogMutation) Operation() (r string, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldOperation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *AuditLogMutation) ResetOperation() {
	m.operation = nil
}

// SetServiceName sets the "service_name" field.
func (m *AuditLogMutation) SetServiceName(s string) {
	m.service_name = &s
}

// ServiceName returns the value of the "service_name" field in the mutation.
func (m *AuditLogMutation) ServiceName() (r string, exists bool) {
	v := m.service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceName returns the old "service_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldServiceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceName: %w", err)
	}
	return oldValue.ServiceName, nil
}

// ResetServiceName resets all changes to the "service_name" field.
func (m *AuditLogMutation) ResetServiceName() {
	m.service_name = nil
}

// SetClientID sets the "client_id" field.
func (m *AuditLogMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AuditLogMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *AuditLogMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[auditlog.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *AuditLogMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AuditLogMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, auditlog.FieldClientID)
}

// SetClientCommonName sets the "client_common_name" field.
func (m *AuditLogMutation) SetClientCommonName(s string) {
	m.client_common_name = &s
}

// ClientCommonName returns the value of the "client_common_name" field in the mutation.
func (m *AuditLogMutation) ClientCommonName() (r string, exists bool) {
	v := m.client_common_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientCommonName returns the old "client_common_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientCommonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientCommonName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientCommonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientCommonName: %w", err)
	}
	return oldValue.ClientCommonName, nil
}

// ClearClientCommonName clears the value of the "client_common_name" field.
func (m *AuditLogMutation) ClearClientCommonName() {
	m.client_common_name = nil
	m.clearedFields[auditlog.FieldClientCommonName] = struct{}{}
}

// ClientCommonNameCleared returns if the "client_common_name" field was cleared in this mutation.
func (m *AuditLogMutation) ClientCommonNameCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientCommonName]
	return ok
}

// ResetClientCommonName resets all changes to the "client_common_name" field.
func (m *AuditLogMutation) ResetClientCommonName() {
	m.client_common_name = nil
	delete(m.clearedFields, auditlog.FieldClientCommonName)
}

// SetClientOrganization sets the "client_organization" field.
func (m *AuditLogMutation) SetClientOrganization(s string) {
	m.client_organization = &s
}

// ClientOrganization returns the value of the "client_organization" field in the mutation.
func (m *AuditLogMutation) ClientOrganization() (r string, exists bool) {
	v := m.client_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldClientOrganization returns the old "client_organization" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientOrganization: %w", err)
	}
	return oldValue.ClientOrganization, nil
}

// ClearClientOrganization clears the value of the "client_organization" field.
func (m *AuditLogMutation) ClearClientOrganization() {
	m.client_organization = nil
	m.clearedFields[auditlog.FieldClientOrganization] = struct{}{}
}

// ClientOrganizationCleared returns if the "client_organization" field was cleared in this mutation.
func (m *AuditLogMutation) ClientOrganizationCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientOrganization]
	return ok
}

// ResetClientOrganization resets all changes to the "client_organization" field.
func (m *AuditLogMutation) ResetClientOrganization() {
	m.client_organization = nil
	delete(m.clearedFields, auditlog.FieldClientOrganization)
}

// SetClientSerialNumber sets the "client_serial_number" field.
func (m *AuditLogMutation) SetClientSerialNumber(s string) {
	m.client_serial_number = &s
}

// ClientSerialNumber returns the value of the "client_serial_number" field in the mutation.
func (m *AuditLogMutation) ClientSerialNumber() (r string, exists bool) {
	v := m.client_serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSerialNumber returns the old "client_serial_number" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSerialNumber: %w", err)
	}
	return oldValue.ClientSerialNumber, nil
}

// ClearClientSerialNumber clears the value of the "client_serial_number" field.
func (m *AuditLogMutation) ClearClientSerialNumber() {
	m.client_serial_number = nil
	m.clearedFields[auditlog.FieldClientSerialNumber] = struct{}{}
}

// ClientSerialNumberCleared returns if the "client_serial_number" field was cleared in this mutation.
func (m *AuditLogMutation) ClientSerialNumberCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientSerialNumber]
	return ok
}

// ResetClientSerialNumber resets all changes to the "client_serial_number" field.
func (m *AuditLogMutation) ResetClientSerialNumber() {
	m.client_serial_number = nil
	delete(m.clearedFields, auditlog.FieldClientSerialNumber)
}

// SetIsAuthenticated sets the "is_authenticated" field.
func (m *AuditLogMutation) SetIsAuthenticated(b bool) {
	m.is_authenticated = &b
}

// IsAuthenticated returns the value of the "is_authenticated" field in the mutation.
func (m *AuditLogMutation) IsAuthenticated() (r bool, exists bool) {
	v := m.is_authenticated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAuthenticated returns the old "is_authenticated" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIsAuthenticated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAuthenticated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAuthenticated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAuthenticated: %w", err)
	}
	return oldValue.IsAuthenticated, nil
}

// ResetIsAuthenticated resets all changes to the "is_authenticated" field.
func (m *AuditLogMutation) ResetIsAuthenticated() {
	m.is_authenticated = nil
}

// SetSuccess sets the "success" field.
func (m *AuditLogMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *AuditLogMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *AuditLogMutation) ResetSuccess() {
	m.success = nil
}

// SetErrorCode sets the "error_code" field.
func (m *AuditLogMutation) SetErrorCode(i int32) {
	m.error_code = &i
	m.adderror_code = nil
}

// ErrorCode returns the value of the "error_code" field in the mutation.
func (m *AuditLogMutation) ErrorCode() (r int32, exists bool) {
	v := m.error_code
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "error_code" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorCode(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// AddErrorCode adds i to the "error_code" field.
func (m *AuditLogMutation) AddErrorCode(i int32) {
	if m.adderror_code != nil {
		*m.adderror_code += i
	} else {
		m.adderror_code = &i
	}
}

// AddedErrorCode returns the value that was added to the "error_code" field in this mutation.
func (m *AuditLogMutation) AddedErrorCode() (r int32, exists bool) {
	v := m.adderror_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearErrorCode clears the value of the "error_code" field.
func (m *AuditLogMutation) ClearErrorCode() {
	m.error_code = nil
	m.adderror_code = nil
	m.clearedFields[auditlog.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "error_code" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "error_code" field.
func (m *AuditLogMutation) ResetErrorCode() {
	m.error_code = nil
	m.adderror_code = nil
	delete(m.clearedFields, auditlog.FieldErrorCode)
}

// SetErrorMessage sets the "error_message" field.
func (m *AuditLogMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AuditLogMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AuditLogMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[auditlog.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AuditLogMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, auditlog.FieldErrorMessage)
}

// SetLatencyMs sets the "latency_ms" field.
func (m *AuditLogMutation) SetLatencyMs(i int64) {
	m.latency_ms = &i
	m.addlatency_ms = nil
}

// LatencyMs returns the value of the "latency_ms" field in the mutation.
func (m *AuditLogMutation) LatencyMs() (r int64, exists bool) {
	v := m.latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldLatencyMs returns the old "latency_ms" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldLatencyMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatencyMs: %w", err)
	}
	return oldValue.LatencyMs, nil
}

// AddLatencyMs adds i to the "latency_ms" field.
func (m *AuditLogMutation) AddLatencyMs(i int64) {
	if m.addlatency_ms != nil {
		*m.addlatency_ms += i
	} else {
		m.addlatency_ms = &i
	}
}

// AddedLatencyMs returns the value that was added to the "latency_ms" field in this mutation.
func (m *AuditLogMutation) AddedLatencyMs() (r int64, exists bool) {
	v := m.addlatency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatencyMs resets all changes to the "latency_ms" field.
func (m *AuditLogMutation) ResetLatencyMs() {
	m.latency_ms = nil
	m.addlatency_ms = nil
}

// SetPeerAddress sets the "peer_address" field.
func (m *AuditLogMutation) SetPeerAddress(s string) {
	m.peer_address = &s
}

// PeerAddress returns the value of the "peer_address" field in the mutation.
func (m *AuditLogMutation) PeerAddress() (r string, exists bool) {
	v := m.peer_address
	if v == nil {
		return
	}
	return *v, true
}

// OldPeerAddress returns the old "peer_address" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldPeerAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeerAddress: %w", err)
	}
	return oldValue.PeerAddress, nil
}

// ClearPeerAddress clears the value of the "peer_address" field.
func (m *AuditLogMutation) ClearPeerAddress() {
	m.peer_address = nil
	m.clearedFields[auditlog.FieldPeerAddress] = struct{}{}
}

// PeerAddressCleared returns if the "peer_address" field was cleared in this mutation.
func (m *AuditLogMutation) PeerAddressCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldPeerAddress]
	return ok
}

// ResetPeerAddress resets all changes to the "peer_address" field.
func (m *AuditLogMutation) ResetPeerAddress() {
	m.peer_address = nil
	delete(m.clearedFields, auditlog.FieldPeerAddress)
}

// SetGeoLocation sets the "geo_location" field.
func (m *AuditLogMutation) SetGeoLocation(value map[string]string) {
	m.geo_location = &value
}

// GeoLocation returns the value of the "geo_location" field in the mutation.
func (m *AuditLogMutation) GeoLocation() (r map[string]string, exists bool) {
	v := m.geo_location
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoLocation returns the old "geo_location" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldGeoLocation(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoLocation: %w", err)
	}
	return oldValue.GeoLocation, nil
}

// ClearGeoLocation clears the value of the "geo_location" field.
func (m *AuditLogMutation) ClearGeoLocation() {
	m.geo_location = nil
	m.clearedFields[auditlog.FieldGeoLocation] = struct{}{}
}

// GeoLocationCleared returns if the "geo_location" field was cleared in this mutation.
func (m *AuditLogMutation) GeoLocationCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldGeoLocation]
	return ok
}

// ResetGeoLocation resets all changes to the "geo_location" field.
func (m *AuditLogMutation) ResetGeoLocation() {
	m.geo_location = nil
	delete(m.clearedFields, auditlog.FieldGeoLocation)
}

// SetLogHash sets the "log_hash" field.
func (m *AuditLogMutation) SetLogHash(s string) {
	m.log_hash = &s
}

// LogHash returns the value of the "log_hash" field in the mutation.
func (m *AuditLogMutation) LogHash() (r string, exists bool) {
	v := m.log_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldLogHash returns the old "log_hash" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldLogHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogHash: %w", err)
	}
	return oldValue.LogHash, nil
}

// ClearLogHash clears the value of the "log_hash" field.
func (m *AuditLogMutation) ClearLogHash() {
	m.log_hash = nil
	m.clearedFields[auditlog.FieldLogHash] = struct{}{}
}

// LogHashCleared returns if the "log_hash" field was cleared in this mutation.
func (m *AuditLogMutation) LogHashCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldLogHash]
	return ok
}

// ResetLogHash resets all changes to the "log_hash" field.
func (m *AuditLogMutation) ResetLogHash() {
	m.log_hash = nil
	delete(m.clearedFields, auditlog.FieldLogHash)
}

// SetSignature sets the "signature" field.
func (m *AuditLogMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *AuditLogMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *AuditLogMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[auditlog.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *AuditLogMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *AuditLogMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, auditlog.FieldSignature)
}

// SetMetadata sets the "metadata" field.
func (m *AuditLogMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuditLogMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AuditLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[auditlog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AuditLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuditLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, auditlog.FieldMetadata)
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.create_time != nil {
		fields = append(fields, auditlog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, auditlog.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, auditlog.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.audit_id != nil {
		fields = append(fields, auditlog.FieldAuditID)
	}
	if m.request_id != nil {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.operation != nil {
		fields = append(fields, auditlog.FieldOperation)
	}
	if m.service_name != nil {
		fields = append(fields, auditlog.FieldServiceName)
	}
	if m.client_id != nil {
		fields = append(fields, auditlog.FieldClientID)
	}
	if m.client_common_name != nil {
		fields = append(fields, auditlog.FieldClientCommonName)
	}
	if m.client_organization != nil {
		fields = append(fields, auditlog.FieldClientOrganization)
	}
	if m.client_serial_number != nil {
		fields = append(fields, auditlog.FieldClientSerialNumber)
	}
	if m.is_authenticated != nil {
		fields = append(fields, auditlog.FieldIsAuthenticated)
	}
	if m.success != nil {
		fields = append(fields, auditlog.FieldSuccess)
	}
	if m.error_code != nil {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.error_message != nil {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.latency_ms != nil {
		fields = append(fields, auditlog.FieldLatencyMs)
	}
	if m.peer_address != nil {
		fields = append(fields, auditlog.FieldPeerAddress)
	}
	if m.geo_location != nil {
		fields = append(fields, auditlog.FieldGeoLocation)
	}
	if m.log_hash != nil {
		fields = append(fields, auditlog.FieldLogHash)
	}
	if m.signature != nil {
		fields = append(fields, auditlog.FieldSignature)
	}
	if m.metadata != nil {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldCreateTime:
		return m.CreateTime()
	case auditlog.FieldUpdateTime:
		return m.UpdateTime()
	case auditlog.FieldDeleteTime:
		return m.DeleteTime()
	case auditlog.FieldTenantID:
		return m.TenantID()
	case auditlog.FieldAuditID:
		return m.AuditID()
	case auditlog.FieldRequestID:
		return m.RequestID()
	case auditlog.FieldOperation:
		return m.Operation()
	case auditlog.FieldServiceName:
		return m.ServiceName()
	case auditlog.FieldClientID:
		return m.ClientID()
	case auditlog.FieldClientCommonName:
		return m.ClientCommonName()
	case auditlog.FieldClientOrganization:
		return m.ClientOrganization()
	case auditlog.FieldClientSerialNumber:
		return m.ClientSerialNumber()
	case auditlog.FieldIsAuthenticated:
		return m.IsAuthenticated()
	case auditlog.FieldSuccess:
		return m.Success()
	case auditlog.FieldErrorCode:
		return m.ErrorCode()
	case auditlog.FieldErrorMessage:
		return m.ErrorMessage()
	case auditlog.FieldLatencyMs:
		return m.LatencyMs()
	case auditlog.FieldPeerAddress:
		return m.PeerAddress()
	case auditlog.FieldGeoLocation:
		return m.GeoLocation()
	case auditlog.FieldLogHash:
		return m.LogHash()
	case auditlog.FieldSignature:
		return m.Signature()
	case auditlog.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case auditlog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case auditlog.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case auditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case auditlog.FieldAuditID:
		return m.OldAuditID(ctx)
	case auditlog.FieldRequestID:
		return m.OldRequestID(ctx)
	case auditlog.FieldOperation:
		return m.OldOperation(ctx)
	case auditlog.FieldServiceName:
		return m.OldServiceName(ctx)
	case auditlog.FieldClientID:
		return m.OldClientID(ctx)
	case auditlog.FieldClientCommonName:
		return m.OldClientCommonName(ctx)
	case auditlog.FieldClientOrganization:
		return m.OldClientOrganization(ctx)
	case auditlog.FieldClientSerialNumber:
		return m.OldClientSerialNumber(ctx)
	case auditlog.FieldIsAuthenticated:
		return m.OldIsAuthenticated(ctx)
	case auditlog.FieldSuccess:
		return m.OldSuccess(ctx)
	case auditlog.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case auditlog.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case auditlog.FieldLatencyMs:
		return m.OldLatencyMs(ctx)
	case auditlog.FieldPeerAddress:
		return m.OldPeerAddress(ctx)
	case auditlog.FieldGeoLocation:
		return m.OldGeoLocation(ctx)
	case auditlog.FieldLogHash:
		return m.OldLogHash(ctx)
	case auditlog.FieldSignature:
		return m.OldSignature(ctx)
	case auditlog.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case auditlog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case auditlog.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case auditlog.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case auditlog.FieldAuditID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditID(v)
		return nil
	case auditlog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case auditlog.FieldOperation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case auditlog.FieldServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceName(v)
		return nil
	case auditlog.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case auditlog.FieldClientCommonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientCommonName(v)
		return nil
	case auditlog.FieldClientOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientOrganization(v)
		return nil
	case auditlog.FieldClientSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSerialNumber(v)
		return nil
	case auditlog.FieldIsAuthenticated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAuthenticated(v)
		return nil
	case auditlog.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case auditlog.FieldErrorCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case auditlog.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case auditlog.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatencyMs(v)
		return nil
	case auditlog.FieldPeerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeerAddress(v)
		return nil
	case auditlog.FieldGeoLocation:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoLocation(v)
		return nil
	case auditlog.FieldLogHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogHash(v)
		return nil
	case auditlog.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case auditlog.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.adderror_code != nil {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.addlatency_ms != nil {
		fields = append(fields, auditlog.FieldLatencyMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldTenantID:
		return m.AddedTenantID()
	case auditlog.FieldErrorCode:
		return m.AddedErrorCode()
	case auditlog.FieldLatencyMs:
		return m.AddedLatencyMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case auditlog.FieldErrorCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrorCode(v)
		return nil
	case auditlog.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldCreateTime) {
		fields = append(fields, auditlog.FieldCreateTime)
	}
	if m.FieldCleared(auditlog.FieldUpdateTime) {
		fields = append(fields, auditlog.FieldUpdateTime)
	}
	if m.FieldCleared(auditlog.FieldDeleteTime) {
		fields = append(fields, auditlog.FieldDeleteTime)
	}
	if m.FieldCleared(auditlog.FieldTenantID) {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.FieldCleared(auditlog.FieldRequestID) {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.FieldCleared(auditlog.FieldClientID) {
		fields = append(fields, auditlog.FieldClientID)
	}
	if m.FieldCleared(auditlog.FieldClientCommonName) {
		fields = append(fields, auditlog.FieldClientCommonName)
	}
	if m.FieldCleared(auditlog.FieldClientOrganization) {
		fields = append(fields, auditlog.FieldClientOrganization)
	}
	if m.FieldCleared(auditlog.FieldClientSerialNumber) {
		fields = append(fields, auditlog.FieldClientSerialNumber)
	}
	if m.FieldCleared(auditlog.FieldErrorCode) {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.FieldCleared(auditlog.FieldErrorMessage) {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.FieldCleared(auditlog.FieldPeerAddress) {
		fields = append(fields, auditlog.FieldPeerAddress)
	}
	if m.FieldCleared(auditlog.FieldGeoLocation) {
		fields = append(fields, auditlog.FieldGeoLocation)
	}
	if m.FieldCleared(auditlog.FieldLogHash) {
		fields = append(fields, auditlog.FieldLogHash)
	}
	if m.FieldCleared(auditlog.FieldSignature) {
		fields = append(fields, auditlog.FieldSignature)
	}
	if m.FieldCleared(auditlog.FieldMetadata) {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case auditlog.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case auditlog.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case auditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case auditlog.FieldRequestID:
		m.ClearRequestID()
		return nil
	case auditlog.FieldClientID:
		m.ClearClientID()
		return nil
	case auditlog.FieldClientCommonName:
		m.ClearClientCommonName()
		return nil
	case auditlog.FieldClientOrganization:
		m.ClearClientOrganization()
		return nil
	case auditlog.FieldClientSerialNumber:
		m.ClearClientSerialNumber()
		return nil
	case auditlog.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	case auditlog.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case auditlog.FieldPeerAddress:
		m.ClearPeerAddress()
		return nil
	case auditlog.FieldGeoLocation:
		m.ClearGeoLocation()
		return nil
	case auditlog.FieldLogHash:
		m.ClearLogHash()
		return nil
	case auditlog.FieldSignature:
		m.ClearSignature()
		return nil
	case auditlog.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case auditlog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case auditlog.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case auditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case auditlog.FieldAuditID:
		m.ResetAuditID()
		return nil
	case auditlog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case auditlog.FieldOperation:
		m.ResetOperation()
		return nil
	case auditlog.FieldServiceName:
		m.ResetServiceName()
		return nil
	case auditlog.FieldClientID:
		m.ResetClientID()
		return nil
	case auditlog.FieldClientCommonName:
		m.ResetClientCommonName()
		return nil
	case auditlog.FieldClientOrganization:
		m.ResetClientOrganization()
		return nil
	case auditlog.FieldClientSerialNumber:
		m.ResetClientSerialNumber()
		return nil
	case auditlog.FieldIsAuthenticated:
		m.ResetIsAuthenticated()
		return nil
	case auditlog.FieldSuccess:
		m.ResetSuccess()
		return nil
	case auditlog.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case auditlog.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case auditlog.FieldLatencyMs:
		m.ResetLatencyMs()
		return nil
	case auditlog.FieldPeerAddress:
		m.ResetPeerAddress()
		return nil
	case auditlog.FieldGeoLocation:
		m.ResetGeoLocation()
		return nil
	case auditlog.FieldLogHash:
		m.ResetLogHash()
		return nil
	case auditlog.FieldSignature:
		m.ResetSignature()
		return nil
	case auditlog.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// CertificateDetailsMutation represents an operation that mutates the CertificateDetails nodes in the graph.
type CertificateDetailsMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uint32
	create_by                   *uint32
	addcreate_by                *int32
	update_by                   *uint32
	addupdate_by                *int32
	create_time                 *time.Time
	update_time                 *time.Time
	delete_time                 *time.Time
	serial_number               *string
	ip_addresses                *[]string
	appendip_addresses          []string
	subject_common_name         *string
	subject_organization        *string
	subject_organizational_unit *string
	subject_country             *string
	subject_state               *string
	subject_locality            *string
	issuer_common_name          *string
	issuer_organization         *string
	issuer_country              *string
	issuer_type                 *string
	signature_algorithm         *string
	public_key_algorithm        *string
	key_size                    *int
	addkey_size                 *int
	dns_names                   *[]string
	appenddns_names             []string
	email_addresses             *[]string
	appendemail_addresses       []string
	not_before                  *time.Time
	not_after                   *time.Time
	is_ca                       *bool
	key_usage                   *string
	extended_key_usage          *[]string
	appendextended_key_usage    []string
	clearedFields               map[string]struct{}
	issued_certificate          *string
	clearedissued_certificate   bool
	done                        bool
	oldValue                    func(context.Context) (*CertificateDetails, error)
	predicates                  []predicate.CertificateDetails
}

var _ ent.Mutation = (*CertificateDetailsMutation)(nil)

// certificatedetailsOption allows management of the mutation configuration using functional options.
type certificatedetailsOption func(*CertificateDetailsMutation)

// newCertificateDetailsMutation creates new mutation for the CertificateDetails entity.
func newCertificateDetailsMutation(c config, op Op, opts ...certificatedetailsOption) *CertificateDetailsMutation {
	m := &CertificateDetailsMutation{
		config:        c,
		op:            op,
		typ:           TypeCertificateDetails,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificateDetailsID sets the ID field of the mutation.
func withCertificateDetailsID(id uint32) certificatedetailsOption {
	return func(m *CertificateDetailsMutation) {
		var (
			err   error
			once  sync.Once
			value *CertificateDetails
		)
		m.oldValue = func(ctx context.Context) (*CertificateDetails, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CertificateDetails.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertificateDetails sets the old CertificateDetails of the mutation.
func withCertificateDetails(node *CertificateDetails) certificatedetailsOption {
	return func(m *CertificateDetailsMutation) {
		m.oldValue = func(context.Context) (*CertificateDetails, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificateDetailsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificateDetailsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CertificateDetails entities.
func (m *CertificateDetailsMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertificateDetailsMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertificateDetailsMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CertificateDetails.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *CertificateDetailsMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *CertificateDetailsMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *CertificateDetailsMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *CertificateDetailsMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *CertificateDetailsMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[certificatedetails.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *CertificateDetailsMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *CertificateDetailsMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, certificatedetails.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *CertificateDetailsMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *CertificateDetailsMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *CertificateDetailsMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *CertificateDetailsMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *CertificateDetailsMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[certificatedetails.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *CertificateDetailsMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *CertificateDetailsMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, certificatedetails.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *CertificateDetailsMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CertificateDetailsMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *CertificateDetailsMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[certificatedetails.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *CertificateDetailsMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CertificateDetailsMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, certificatedetails.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *CertificateDetailsMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CertificateDetailsMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *CertificateDetailsMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[certificatedetails.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *CertificateDetailsMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CertificateDetailsMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, certificatedetails.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *CertificateDetailsMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *CertificateDetailsMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *CertificateDetailsMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[certificatedetails.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *CertificateDetailsMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *CertificateDetailsMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, certificatedetails.FieldDeleteTime)
}

// SetCertificateID sets the "certificate_id" field.
func (m *CertificateDetailsMutation) SetCertificateID(s string) {
	m.issued_certificate = &s
}

// CertificateID returns the value of the "certificate_id" field in the mutation.
func (m *CertificateDetailsMutation) CertificateID() (r string, exists bool) {
	v := m.issued_certificate
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateID returns the old "certificate_id" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldCertificateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateID: %w", err)
	}
	return oldValue.CertificateID, nil
}

// ResetCertificateID resets all changes to the "certificate_id" field.
func (m *CertificateDetailsMutation) ResetCertificateID() {
	m.issued_certificate = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *CertificateDetailsMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *CertificateDetailsMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ClearSerialNumber clears the value of the "serial_number" field.
func (m *CertificateDetailsMutation) ClearSerialNumber() {
	m.serial_number = nil
	m.clearedFields[certificatedetails.FieldSerialNumber] = struct{}{}
}

// SerialNumberCleared returns if the "serial_number" field was cleared in this mutation.
func (m *CertificateDetailsMutation) SerialNumberCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldSerialNumber]
	return ok
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *CertificateDetailsMutation) ResetSerialNumber() {
	m.serial_number = nil
	delete(m.clearedFields, certificatedetails.FieldSerialNumber)
}

// SetIPAddresses sets the "ip_addresses" field.
func (m *CertificateDetailsMutation) SetIPAddresses(s []string) {
	m.ip_addresses = &s
	m.appendip_addresses = nil
}

// IPAddresses returns the value of the "ip_addresses" field in the mutation.
func (m *CertificateDetailsMutation) IPAddresses() (r []string, exists bool) {
	v := m.ip_addresses
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddresses returns the old "ip_addresses" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldIPAddresses(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddresses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddresses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddresses: %w", err)
	}
	return oldValue.IPAddresses, nil
}

// AppendIPAddresses adds s to the "ip_addresses" field.
func (m *CertificateDetailsMutation) AppendIPAddresses(s []string) {
	m.appendip_addresses = append(m.appendip_addresses, s...)
}

// AppendedIPAddresses returns the list of values that were appended to the "ip_addresses" field in this mutation.
func (m *CertificateDetailsMutation) AppendedIPAddresses() ([]string, bool) {
	if len(m.appendip_addresses) == 0 {
		return nil, false
	}
	return m.appendip_addresses, true
}

// ClearIPAddresses clears the value of the "ip_addresses" field.
func (m *CertificateDetailsMutation) ClearIPAddresses() {
	m.ip_addresses = nil
	m.appendip_addresses = nil
	m.clearedFields[certificatedetails.FieldIPAddresses] = struct{}{}
}

// IPAddressesCleared returns if the "ip_addresses" field was cleared in this mutation.
func (m *CertificateDetailsMutation) IPAddressesCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldIPAddresses]
	return ok
}

// ResetIPAddresses resets all changes to the "ip_addresses" field.
func (m *CertificateDetailsMutation) ResetIPAddresses() {
	m.ip_addresses = nil
	m.appendip_addresses = nil
	delete(m.clearedFields, certificatedetails.FieldIPAddresses)
}

// SetSubjectCommonName sets the "subject_common_name" field.
func (m *CertificateDetailsMutation) SetSubjectCommonName(s string) {
	m.subject_common_name = &s
}

// SubjectCommonName returns the value of the "subject_common_name" field in the mutation.
func (m *CertificateDetailsMutation) SubjectCommonName() (r string, exists bool) {
	v := m.subject_common_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectCommonName returns the old "subject_common_name" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldSubjectCommonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectCommonName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectCommonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectCommonName: %w", err)
	}
	return oldValue.SubjectCommonName, nil
}

// ClearSubjectCommonName clears the value of the "subject_common_name" field.
func (m *CertificateDetailsMutation) ClearSubjectCommonName() {
	m.subject_common_name = nil
	m.clearedFields[certificatedetails.FieldSubjectCommonName] = struct{}{}
}

// SubjectCommonNameCleared returns if the "subject_common_name" field was cleared in this mutation.
func (m *CertificateDetailsMutation) SubjectCommonNameCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldSubjectCommonName]
	return ok
}

// ResetSubjectCommonName resets all changes to the "subject_common_name" field.
func (m *CertificateDetailsMutation) ResetSubjectCommonName() {
	m.subject_common_name = nil
	delete(m.clearedFields, certificatedetails.FieldSubjectCommonName)
}

// SetSubjectOrganization sets the "subject_organization" field.
func (m *CertificateDetailsMutation) SetSubjectOrganization(s string) {
	m.subject_organization = &s
}

// SubjectOrganization returns the value of the "subject_organization" field in the mutation.
func (m *CertificateDetailsMutation) SubjectOrganization() (r string, exists bool) {
	v := m.subject_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectOrganization returns the old "subject_organization" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldSubjectOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectOrganization: %w", err)
	}
	return oldValue.SubjectOrganization, nil
}

// ClearSubjectOrganization clears the value of the "subject_organization" field.
func (m *CertificateDetailsMutation) ClearSubjectOrganization() {
	m.subject_organization = nil
	m.clearedFields[certificatedetails.FieldSubjectOrganization] = struct{}{}
}

// SubjectOrganizationCleared returns if the "subject_organization" field was cleared in this mutation.
func (m *CertificateDetailsMutation) SubjectOrganizationCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldSubjectOrganization]
	return ok
}

// ResetSubjectOrganization resets all changes to the "subject_organization" field.
func (m *CertificateDetailsMutation) ResetSubjectOrganization() {
	m.subject_organization = nil
	delete(m.clearedFields, certificatedetails.FieldSubjectOrganization)
}

// SetSubjectOrganizationalUnit sets the "subject_organizational_unit" field.
func (m *CertificateDetailsMutation) SetSubjectOrganizationalUnit(s string) {
	m.subject_organizational_unit = &s
}

// SubjectOrganizationalUnit returns the value of the "subject_organizational_unit" field in the mutation.
func (m *CertificateDetailsMutation) SubjectOrganizationalUnit() (r string, exists bool) {
	v := m.subject_organizational_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectOrganizationalUnit returns the old "subject_organizational_unit" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldSubjectOrganizationalUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectOrganizationalUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectOrganizationalUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectOrganizationalUnit: %w", err)
	}
	return oldValue.SubjectOrganizationalUnit, nil
}

// ClearSubjectOrganizationalUnit clears the value of the "subject_organizational_unit" field.
func (m *CertificateDetailsMutation) ClearSubjectOrganizationalUnit() {
	m.subject_organizational_unit = nil
	m.clearedFields[certificatedetails.FieldSubjectOrganizationalUnit] = struct{}{}
}

// SubjectOrganizationalUnitCleared returns if the "subject_organizational_unit" field was cleared in this mutation.
func (m *CertificateDetailsMutation) SubjectOrganizationalUnitCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldSubjectOrganizationalUnit]
	return ok
}

// ResetSubjectOrganizationalUnit resets all changes to the "subject_organizational_unit" field.
func (m *CertificateDetailsMutation) ResetSubjectOrganizationalUnit() {
	m.subject_organizational_unit = nil
	delete(m.clearedFields, certificatedetails.FieldSubjectOrganizationalUnit)
}

// SetSubjectCountry sets the "subject_country" field.
func (m *CertificateDetailsMutation) SetSubjectCountry(s string) {
	m.subject_country = &s
}

// SubjectCountry returns the value of the "subject_country" field in the mutation.
func (m *CertificateDetailsMutation) SubjectCountry() (r string, exists bool) {
	v := m.subject_country
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectCountry returns the old "subject_country" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldSubjectCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectCountry: %w", err)
	}
	return oldValue.SubjectCountry, nil
}

// ClearSubjectCountry clears the value of the "subject_country" field.
func (m *CertificateDetailsMutation) ClearSubjectCountry() {
	m.subject_country = nil
	m.clearedFields[certificatedetails.FieldSubjectCountry] = struct{}{}
}

// SubjectCountryCleared returns if the "subject_country" field was cleared in this mutation.
func (m *CertificateDetailsMutation) SubjectCountryCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldSubjectCountry]
	return ok
}

// ResetSubjectCountry resets all changes to the "subject_country" field.
func (m *CertificateDetailsMutation) ResetSubjectCountry() {
	m.subject_country = nil
	delete(m.clearedFields, certificatedetails.FieldSubjectCountry)
}

// SetSubjectState sets the "subject_state" field.
func (m *CertificateDetailsMutation) SetSubjectState(s string) {
	m.subject_state = &s
}

// SubjectState returns the value of the "subject_state" field in the mutation.
func (m *CertificateDetailsMutation) SubjectState() (r string, exists bool) {
	v := m.subject_state
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectState returns the old "subject_state" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldSubjectState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectState: %w", err)
	}
	return oldValue.SubjectState, nil
}

// ClearSubjectState clears the value of the "subject_state" field.
func (m *CertificateDetailsMutation) ClearSubjectState() {
	m.subject_state = nil
	m.clearedFields[certificatedetails.FieldSubjectState] = struct{}{}
}

// SubjectStateCleared returns if the "subject_state" field was cleared in this mutation.
func (m *CertificateDetailsMutation) SubjectStateCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldSubjectState]
	return ok
}

// ResetSubjectState resets all changes to the "subject_state" field.
func (m *CertificateDetailsMutation) ResetSubjectState() {
	m.subject_state = nil
	delete(m.clearedFields, certificatedetails.FieldSubjectState)
}

// SetSubjectLocality sets the "subject_locality" field.
func (m *CertificateDetailsMutation) SetSubjectLocality(s string) {
	m.subject_locality = &s
}

// SubjectLocality returns the value of the "subject_locality" field in the mutation.
func (m *CertificateDetailsMutation) SubjectLocality() (r string, exists bool) {
	v := m.subject_locality
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectLocality returns the old "subject_locality" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldSubjectLocality(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectLocality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectLocality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectLocality: %w", err)
	}
	return oldValue.SubjectLocality, nil
}

// ClearSubjectLocality clears the value of the "subject_locality" field.
func (m *CertificateDetailsMutation) ClearSubjectLocality() {
	m.subject_locality = nil
	m.clearedFields[certificatedetails.FieldSubjectLocality] = struct{}{}
}

// SubjectLocalityCleared returns if the "subject_locality" field was cleared in this mutation.
func (m *CertificateDetailsMutation) SubjectLocalityCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldSubjectLocality]
	return ok
}

// ResetSubjectLocality resets all changes to the "subject_locality" field.
func (m *CertificateDetailsMutation) ResetSubjectLocality() {
	m.subject_locality = nil
	delete(m.clearedFields, certificatedetails.FieldSubjectLocality)
}

// SetIssuerCommonName sets the "issuer_common_name" field.
func (m *CertificateDetailsMutation) SetIssuerCommonName(s string) {
	m.issuer_common_name = &s
}

// IssuerCommonName returns the value of the "issuer_common_name" field in the mutation.
func (m *CertificateDetailsMutation) IssuerCommonName() (r string, exists bool) {
	v := m.issuer_common_name
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerCommonName returns the old "issuer_common_name" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldIssuerCommonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerCommonName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerCommonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerCommonName: %w", err)
	}
	return oldValue.IssuerCommonName, nil
}

// ClearIssuerCommonName clears the value of the "issuer_common_name" field.
func (m *CertificateDetailsMutation) ClearIssuerCommonName() {
	m.issuer_common_name = nil
	m.clearedFields[certificatedetails.FieldIssuerCommonName] = struct{}{}
}

// IssuerCommonNameCleared returns if the "issuer_common_name" field was cleared in this mutation.
func (m *CertificateDetailsMutation) IssuerCommonNameCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldIssuerCommonName]
	return ok
}

// ResetIssuerCommonName resets all changes to the "issuer_common_name" field.
func (m *CertificateDetailsMutation) ResetIssuerCommonName() {
	m.issuer_common_name = nil
	delete(m.clearedFields, certificatedetails.FieldIssuerCommonName)
}

// SetIssuerOrganization sets the "issuer_organization" field.
func (m *CertificateDetailsMutation) SetIssuerOrganization(s string) {
	m.issuer_organization = &s
}

// IssuerOrganization returns the value of the "issuer_organization" field in the mutation.
func (m *CertificateDetailsMutation) IssuerOrganization() (r string, exists bool) {
	v := m.issuer_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerOrganization returns the old "issuer_organization" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldIssuerOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerOrganization: %w", err)
	}
	return oldValue.IssuerOrganization, nil
}

// ClearIssuerOrganization clears the value of the "issuer_organization" field.
func (m *CertificateDetailsMutation) ClearIssuerOrganization() {
	m.issuer_organization = nil
	m.clearedFields[certificatedetails.FieldIssuerOrganization] = struct{}{}
}

// IssuerOrganizationCleared returns if the "issuer_organization" field was cleared in this mutation.
func (m *CertificateDetailsMutation) IssuerOrganizationCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldIssuerOrganization]
	return ok
}

// ResetIssuerOrganization resets all changes to the "issuer_organization" field.
func (m *CertificateDetailsMutation) ResetIssuerOrganization() {
	m.issuer_organization = nil
	delete(m.clearedFields, certificatedetails.FieldIssuerOrganization)
}

// SetIssuerCountry sets the "issuer_country" field.
func (m *CertificateDetailsMutation) SetIssuerCountry(s string) {
	m.issuer_country = &s
}

// IssuerCountry returns the value of the "issuer_country" field in the mutation.
func (m *CertificateDetailsMutation) IssuerCountry() (r string, exists bool) {
	v := m.issuer_country
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerCountry returns the old "issuer_country" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldIssuerCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerCountry: %w", err)
	}
	return oldValue.IssuerCountry, nil
}

// ClearIssuerCountry clears the value of the "issuer_country" field.
func (m *CertificateDetailsMutation) ClearIssuerCountry() {
	m.issuer_country = nil
	m.clearedFields[certificatedetails.FieldIssuerCountry] = struct{}{}
}

// IssuerCountryCleared returns if the "issuer_country" field was cleared in this mutation.
func (m *CertificateDetailsMutation) IssuerCountryCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldIssuerCountry]
	return ok
}

// ResetIssuerCountry resets all changes to the "issuer_country" field.
func (m *CertificateDetailsMutation) ResetIssuerCountry() {
	m.issuer_country = nil
	delete(m.clearedFields, certificatedetails.FieldIssuerCountry)
}

// SetIssuerType sets the "issuer_type" field.
func (m *CertificateDetailsMutation) SetIssuerType(s string) {
	m.issuer_type = &s
}

// IssuerType returns the value of the "issuer_type" field in the mutation.
func (m *CertificateDetailsMutation) IssuerType() (r string, exists bool) {
	v := m.issuer_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerType returns the old "issuer_type" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldIssuerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerType: %w", err)
	}
	return oldValue.IssuerType, nil
}

// ClearIssuerType clears the value of the "issuer_type" field.
func (m *CertificateDetailsMutation) ClearIssuerType() {
	m.issuer_type = nil
	m.clearedFields[certificatedetails.FieldIssuerType] = struct{}{}
}

// IssuerTypeCleared returns if the "issuer_type" field was cleared in this mutation.
func (m *CertificateDetailsMutation) IssuerTypeCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldIssuerType]
	return ok
}

// ResetIssuerType resets all changes to the "issuer_type" field.
func (m *CertificateDetailsMutation) ResetIssuerType() {
	m.issuer_type = nil
	delete(m.clearedFields, certificatedetails.FieldIssuerType)
}

// SetSignatureAlgorithm sets the "signature_algorithm" field.
func (m *CertificateDetailsMutation) SetSignatureAlgorithm(s string) {
	m.signature_algorithm = &s
}

// SignatureAlgorithm returns the value of the "signature_algorithm" field in the mutation.
func (m *CertificateDetailsMutation) SignatureAlgorithm() (r string, exists bool) {
	v := m.signature_algorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldSignatureAlgorithm returns the old "signature_algorithm" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldSignatureAlgorithm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignatureAlgorithm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignatureAlgorithm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignatureAlgorithm: %w", err)
	}
	return oldValue.SignatureAlgorithm, nil
}

// ClearSignatureAlgorithm clears the value of the "signature_algorithm" field.
func (m *CertificateDetailsMutation) ClearSignatureAlgorithm() {
	m.signature_algorithm = nil
	m.clearedFields[certificatedetails.FieldSignatureAlgorithm] = struct{}{}
}

// SignatureAlgorithmCleared returns if the "signature_algorithm" field was cleared in this mutation.
func (m *CertificateDetailsMutation) SignatureAlgorithmCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldSignatureAlgorithm]
	return ok
}

// ResetSignatureAlgorithm resets all changes to the "signature_algorithm" field.
func (m *CertificateDetailsMutation) ResetSignatureAlgorithm() {
	m.signature_algorithm = nil
	delete(m.clearedFields, certificatedetails.FieldSignatureAlgorithm)
}

// SetPublicKeyAlgorithm sets the "public_key_algorithm" field.
func (m *CertificateDetailsMutation) SetPublicKeyAlgorithm(s string) {
	m.public_key_algorithm = &s
}

// PublicKeyAlgorithm returns the value of the "public_key_algorithm" field in the mutation.
func (m *CertificateDetailsMutation) PublicKeyAlgorithm() (r string, exists bool) {
	v := m.public_key_algorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKeyAlgorithm returns the old "public_key_algorithm" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldPublicKeyAlgorithm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKeyAlgorithm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKeyAlgorithm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKeyAlgorithm: %w", err)
	}
	return oldValue.PublicKeyAlgorithm, nil
}

// ClearPublicKeyAlgorithm clears the value of the "public_key_algorithm" field.
func (m *CertificateDetailsMutation) ClearPublicKeyAlgorithm() {
	m.public_key_algorithm = nil
	m.clearedFields[certificatedetails.FieldPublicKeyAlgorithm] = struct{}{}
}

// PublicKeyAlgorithmCleared returns if the "public_key_algorithm" field was cleared in this mutation.
func (m *CertificateDetailsMutation) PublicKeyAlgorithmCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldPublicKeyAlgorithm]
	return ok
}

// ResetPublicKeyAlgorithm resets all changes to the "public_key_algorithm" field.
func (m *CertificateDetailsMutation) ResetPublicKeyAlgorithm() {
	m.public_key_algorithm = nil
	delete(m.clearedFields, certificatedetails.FieldPublicKeyAlgorithm)
}

// SetKeySize sets the "key_size" field.
func (m *CertificateDetailsMutation) SetKeySize(i int) {
	m.key_size = &i
	m.addkey_size = nil
}

// KeySize returns the value of the "key_size" field in the mutation.
func (m *CertificateDetailsMutation) KeySize() (r int, exists bool) {
	v := m.key_size
	if v == nil {
		return
	}
	return *v, true
}

// OldKeySize returns the old "key_size" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldKeySize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeySize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeySize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeySize: %w", err)
	}
	return oldValue.KeySize, nil
}

// AddKeySize adds i to the "key_size" field.
func (m *CertificateDetailsMutation) AddKeySize(i int) {
	if m.addkey_size != nil {
		*m.addkey_size += i
	} else {
		m.addkey_size = &i
	}
}

// AddedKeySize returns the value that was added to the "key_size" field in this mutation.
func (m *CertificateDetailsMutation) AddedKeySize() (r int, exists bool) {
	v := m.addkey_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearKeySize clears the value of the "key_size" field.
func (m *CertificateDetailsMutation) ClearKeySize() {
	m.key_size = nil
	m.addkey_size = nil
	m.clearedFields[certificatedetails.FieldKeySize] = struct{}{}
}

// KeySizeCleared returns if the "key_size" field was cleared in this mutation.
func (m *CertificateDetailsMutation) KeySizeCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldKeySize]
	return ok
}

// ResetKeySize resets all changes to the "key_size" field.
func (m *CertificateDetailsMutation) ResetKeySize() {
	m.key_size = nil
	m.addkey_size = nil
	delete(m.clearedFields, certificatedetails.FieldKeySize)
}

// SetDNSNames sets the "dns_names" field.
func (m *CertificateDetailsMutation) SetDNSNames(s []string) {
	m.dns_names = &s
	m.appenddns_names = nil
}

// DNSNames returns the value of the "dns_names" field in the mutation.
func (m *CertificateDetailsMutation) DNSNames() (r []string, exists bool) {
	v := m.dns_names
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSNames returns the old "dns_names" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldDNSNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSNames: %w", err)
	}
	return oldValue.DNSNames, nil
}

// AppendDNSNames adds s to the "dns_names" field.
func (m *CertificateDetailsMutation) AppendDNSNames(s []string) {
	m.appenddns_names = append(m.appenddns_names, s...)
}

// AppendedDNSNames returns the list of values that were appended to the "dns_names" field in this mutation.
func (m *CertificateDetailsMutation) AppendedDNSNames() ([]string, bool) {
	if len(m.appenddns_names) == 0 {
		return nil, false
	}
	return m.appenddns_names, true
}

// ClearDNSNames clears the value of the "dns_names" field.
func (m *CertificateDetailsMutation) ClearDNSNames() {
	m.dns_names = nil
	m.appenddns_names = nil
	m.clearedFields[certificatedetails.FieldDNSNames] = struct{}{}
}

// DNSNamesCleared returns if the "dns_names" field was cleared in this mutation.
func (m *CertificateDetailsMutation) DNSNamesCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldDNSNames]
	return ok
}

// ResetDNSNames resets all changes to the "dns_names" field.
func (m *CertificateDetailsMutation) ResetDNSNames() {
	m.dns_names = nil
	m.appenddns_names = nil
	delete(m.clearedFields, certificatedetails.FieldDNSNames)
}

// SetEmailAddresses sets the "email_addresses" field.
func (m *CertificateDetailsMutation) SetEmailAddresses(s []string) {
	m.email_addresses = &s
	m.appendemail_addresses = nil
}

// EmailAddresses returns the value of the "email_addresses" field in the mutation.
func (m *CertificateDetailsMutation) EmailAddresses() (r []string, exists bool) {
	v := m.email_addresses
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailAddresses returns the old "email_addresses" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldEmailAddresses(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailAddresses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailAddresses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailAddresses: %w", err)
	}
	return oldValue.EmailAddresses, nil
}

// AppendEmailAddresses adds s to the "email_addresses" field.
func (m *CertificateDetailsMutation) AppendEmailAddresses(s []string) {
	m.appendemail_addresses = append(m.appendemail_addresses, s...)
}

// AppendedEmailAddresses returns the list of values that were appended to the "email_addresses" field in this mutation.
func (m *CertificateDetailsMutation) AppendedEmailAddresses() ([]string, bool) {
	if len(m.appendemail_addresses) == 0 {
		return nil, false
	}
	return m.appendemail_addresses, true
}

// ClearEmailAddresses clears the value of the "email_addresses" field.
func (m *CertificateDetailsMutation) ClearEmailAddresses() {
	m.email_addresses = nil
	m.appendemail_addresses = nil
	m.clearedFields[certificatedetails.FieldEmailAddresses] = struct{}{}
}

// EmailAddressesCleared returns if the "email_addresses" field was cleared in this mutation.
func (m *CertificateDetailsMutation) EmailAddressesCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldEmailAddresses]
	return ok
}

// ResetEmailAddresses resets all changes to the "email_addresses" field.
func (m *CertificateDetailsMutation) ResetEmailAddresses() {
	m.email_addresses = nil
	m.appendemail_addresses = nil
	delete(m.clearedFields, certificatedetails.FieldEmailAddresses)
}

// SetNotBefore sets the "not_before" field.
func (m *CertificateDetailsMutation) SetNotBefore(t time.Time) {
	m.not_before = &t
}

// NotBefore returns the value of the "not_before" field in the mutation.
func (m *CertificateDetailsMutation) NotBefore() (r time.Time, exists bool) {
	v := m.not_before
	if v == nil {
		return
	}
	return *v, true
}

// OldNotBefore returns the old "not_before" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldNotBefore(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotBefore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotBefore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotBefore: %w", err)
	}
	return oldValue.NotBefore, nil
}

// ClearNotBefore clears the value of the "not_before" field.
func (m *CertificateDetailsMutation) ClearNotBefore() {
	m.not_before = nil
	m.clearedFields[certificatedetails.FieldNotBefore] = struct{}{}
}

// NotBeforeCleared returns if the "not_before" field was cleared in this mutation.
func (m *CertificateDetailsMutation) NotBeforeCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldNotBefore]
	return ok
}

// ResetNotBefore resets all changes to the "not_before" field.
func (m *CertificateDetailsMutation) ResetNotBefore() {
	m.not_before = nil
	delete(m.clearedFields, certificatedetails.FieldNotBefore)
}

// SetNotAfter sets the "not_after" field.
func (m *CertificateDetailsMutation) SetNotAfter(t time.Time) {
	m.not_after = &t
}

// NotAfter returns the value of the "not_after" field in the mutation.
func (m *CertificateDetailsMutation) NotAfter() (r time.Time, exists bool) {
	v := m.not_after
	if v == nil {
		return
	}
	return *v, true
}

// OldNotAfter returns the old "not_after" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldNotAfter(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotAfter: %w", err)
	}
	return oldValue.NotAfter, nil
}

// ClearNotAfter clears the value of the "not_after" field.
func (m *CertificateDetailsMutation) ClearNotAfter() {
	m.not_after = nil
	m.clearedFields[certificatedetails.FieldNotAfter] = struct{}{}
}

// NotAfterCleared returns if the "not_after" field was cleared in this mutation.
func (m *CertificateDetailsMutation) NotAfterCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldNotAfter]
	return ok
}

// ResetNotAfter resets all changes to the "not_after" field.
func (m *CertificateDetailsMutation) ResetNotAfter() {
	m.not_after = nil
	delete(m.clearedFields, certificatedetails.FieldNotAfter)
}

// SetIsCa sets the "is_ca" field.
func (m *CertificateDetailsMutation) SetIsCa(b bool) {
	m.is_ca = &b
}

// IsCa returns the value of the "is_ca" field in the mutation.
func (m *CertificateDetailsMutation) IsCa() (r bool, exists bool) {
	v := m.is_ca
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCa returns the old "is_ca" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldIsCa(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCa: %w", err)
	}
	return oldValue.IsCa, nil
}

// ResetIsCa resets all changes to the "is_ca" field.
func (m *CertificateDetailsMutation) ResetIsCa() {
	m.is_ca = nil
}

// SetKeyUsage sets the "key_usage" field.
func (m *CertificateDetailsMutation) SetKeyUsage(s string) {
	m.key_usage = &s
}

// KeyUsage returns the value of the "key_usage" field in the mutation.
func (m *CertificateDetailsMutation) KeyUsage() (r string, exists bool) {
	v := m.key_usage
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyUsage returns the old "key_usage" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldKeyUsage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyUsage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyUsage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyUsage: %w", err)
	}
	return oldValue.KeyUsage, nil
}

// ClearKeyUsage clears the value of the "key_usage" field.
func (m *CertificateDetailsMutation) ClearKeyUsage() {
	m.key_usage = nil
	m.clearedFields[certificatedetails.FieldKeyUsage] = struct{}{}
}

// KeyUsageCleared returns if the "key_usage" field was cleared in this mutation.
func (m *CertificateDetailsMutation) KeyUsageCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldKeyUsage]
	return ok
}

// ResetKeyUsage resets all changes to the "key_usage" field.
func (m *CertificateDetailsMutation) ResetKeyUsage() {
	m.key_usage = nil
	delete(m.clearedFields, certificatedetails.FieldKeyUsage)
}

// SetExtendedKeyUsage sets the "extended_key_usage" field.
func (m *CertificateDetailsMutation) SetExtendedKeyUsage(s []string) {
	m.extended_key_usage = &s
	m.appendextended_key_usage = nil
}

// ExtendedKeyUsage returns the value of the "extended_key_usage" field in the mutation.
func (m *CertificateDetailsMutation) ExtendedKeyUsage() (r []string, exists bool) {
	v := m.extended_key_usage
	if v == nil {
		return
	}
	return *v, true
}

// OldExtendedKeyUsage returns the old "extended_key_usage" field's value of the CertificateDetails entity.
// If the CertificateDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateDetailsMutation) OldExtendedKeyUsage(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtendedKeyUsage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtendedKeyUsage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtendedKeyUsage: %w", err)
	}
	return oldValue.ExtendedKeyUsage, nil
}

// AppendExtendedKeyUsage adds s to the "extended_key_usage" field.
func (m *CertificateDetailsMutation) AppendExtendedKeyUsage(s []string) {
	m.appendextended_key_usage = append(m.appendextended_key_usage, s...)
}

// AppendedExtendedKeyUsage returns the list of values that were appended to the "extended_key_usage" field in this mutation.
func (m *CertificateDetailsMutation) AppendedExtendedKeyUsage() ([]string, bool) {
	if len(m.appendextended_key_usage) == 0 {
		return nil, false
	}
	return m.appendextended_key_usage, true
}

// ClearExtendedKeyUsage clears the value of the "extended_key_usage" field.
func (m *CertificateDetailsMutation) ClearExtendedKeyUsage() {
	m.extended_key_usage = nil
	m.appendextended_key_usage = nil
	m.clearedFields[certificatedetails.FieldExtendedKeyUsage] = struct{}{}
}

// ExtendedKeyUsageCleared returns if the "extended_key_usage" field was cleared in this mutation.
func (m *CertificateDetailsMutation) ExtendedKeyUsageCleared() bool {
	_, ok := m.clearedFields[certificatedetails.FieldExtendedKeyUsage]
	return ok
}

// ResetExtendedKeyUsage resets all changes to the "extended_key_usage" field.
func (m *CertificateDetailsMutation) ResetExtendedKeyUsage() {
	m.extended_key_usage = nil
	m.appendextended_key_usage = nil
	delete(m.clearedFields, certificatedetails.FieldExtendedKeyUsage)
}

// SetIssuedCertificateID sets the "issued_certificate" edge to the IssuedCertificate entity by id.
func (m *CertificateDetailsMutation) SetIssuedCertificateID(id string) {
	m.issued_certificate = &id
}

// ClearIssuedCertificate clears the "issued_certificate" edge to the IssuedCertificate entity.
func (m *CertificateDetailsMutation) ClearIssuedCertificate() {
	m.clearedissued_certificate = true
	m.clearedFields[certificatedetails.FieldCertificateID] = struct{}{}
}

// IssuedCertificateCleared reports if the "issued_certificate" edge to the IssuedCertificate entity was cleared.
func (m *CertificateDetailsMutation) IssuedCertificateCleared() bool {
	return m.clearedissued_certificate
}

// IssuedCertificateID returns the "issued_certificate" edge ID in the mutation.
func (m *CertificateDetailsMutation) IssuedCertificateID() (id string, exists bool) {
	if m.issued_certificate != nil {
		return *m.issued_certificate, true
	}
	return
}

// IssuedCertificateIDs returns the "issued_certificate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IssuedCertificateID instead. It exists only for internal usage by the builders.
func (m *CertificateDetailsMutation) IssuedCertificateIDs() (ids []string) {
	if id := m.issued_certificate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIssuedCertificate resets all changes to the "issued_certificate" edge.
func (m *CertificateDetailsMutation) ResetIssuedCertificate() {
	m.issued_certificate = nil
	m.clearedissued_certificate = false
}

// Where appends a list predicates to the CertificateDetailsMutation builder.
func (m *CertificateDetailsMutation) Where(ps ...predicate.CertificateDetails) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertificateDetailsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertificateDetailsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CertificateDetails, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertificateDetailsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertificateDetailsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CertificateDetails).
func (m *CertificateDetailsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertificateDetailsMutation) Fields() []string {
	fields := make([]string, 0, 28)
	if m.create_by != nil {
		fields = append(fields, certificatedetails.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, certificatedetails.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, certificatedetails.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, certificatedetails.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, certificatedetails.FieldDeleteTime)
	}
	if m.issued_certificate != nil {
		fields = append(fields, certificatedetails.FieldCertificateID)
	}
	if m.serial_number != nil {
		fields = append(fields, certificatedetails.FieldSerialNumber)
	}
	if m.ip_addresses != nil {
		fields = append(fields, certificatedetails.FieldIPAddresses)
	}
	if m.subject_common_name != nil {
		fields = append(fields, certificatedetails.FieldSubjectCommonName)
	}
	if m.subject_organization != nil {
		fields = append(fields, certificatedetails.FieldSubjectOrganization)
	}
	if m.subject_organizational_unit != nil {
		fields = append(fields, certificatedetails.FieldSubjectOrganizationalUnit)
	}
	if m.subject_country != nil {
		fields = append(fields, certificatedetails.FieldSubjectCountry)
	}
	if m.subject_state != nil {
		fields = append(fields, certificatedetails.FieldSubjectState)
	}
	if m.subject_locality != nil {
		fields = append(fields, certificatedetails.FieldSubjectLocality)
	}
	if m.issuer_common_name != nil {
		fields = append(fields, certificatedetails.FieldIssuerCommonName)
	}
	if m.issuer_organization != nil {
		fields = append(fields, certificatedetails.FieldIssuerOrganization)
	}
	if m.issuer_country != nil {
		fields = append(fields, certificatedetails.FieldIssuerCountry)
	}
	if m.issuer_type != nil {
		fields = append(fields, certificatedetails.FieldIssuerType)
	}
	if m.signature_algorithm != nil {
		fields = append(fields, certificatedetails.FieldSignatureAlgorithm)
	}
	if m.public_key_algorithm != nil {
		fields = append(fields, certificatedetails.FieldPublicKeyAlgorithm)
	}
	if m.key_size != nil {
		fields = append(fields, certificatedetails.FieldKeySize)
	}
	if m.dns_names != nil {
		fields = append(fields, certificatedetails.FieldDNSNames)
	}
	if m.email_addresses != nil {
		fields = append(fields, certificatedetails.FieldEmailAddresses)
	}
	if m.not_before != nil {
		fields = append(fields, certificatedetails.FieldNotBefore)
	}
	if m.not_after != nil {
		fields = append(fields, certificatedetails.FieldNotAfter)
	}
	if m.is_ca != nil {
		fields = append(fields, certificatedetails.FieldIsCa)
	}
	if m.key_usage != nil {
		fields = append(fields, certificatedetails.FieldKeyUsage)
	}
	if m.extended_key_usage != nil {
		fields = append(fields, certificatedetails.FieldExtendedKeyUsage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertificateDetailsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certificatedetails.FieldCreateBy:
		return m.CreateBy()
	case certificatedetails.FieldUpdateBy:
		return m.UpdateBy()
	case certificatedetails.FieldCreateTime:
		return m.CreateTime()
	case certificatedetails.FieldUpdateTime:
		return m.UpdateTime()
	case certificatedetails.FieldDeleteTime:
		return m.DeleteTime()
	case certificatedetails.FieldCertificateID:
		return m.CertificateID()
	case certificatedetails.FieldSerialNumber:
		return m.SerialNumber()
	case certificatedetails.FieldIPAddresses:
		return m.IPAddresses()
	case certificatedetails.FieldSubjectCommonName:
		return m.SubjectCommonName()
	case certificatedetails.FieldSubjectOrganization:
		return m.SubjectOrganization()
	case certificatedetails.FieldSubjectOrganizationalUnit:
		return m.SubjectOrganizationalUnit()
	case certificatedetails.FieldSubjectCountry:
		return m.SubjectCountry()
	case certificatedetails.FieldSubjectState:
		return m.SubjectState()
	case certificatedetails.FieldSubjectLocality:
		return m.SubjectLocality()
	case certificatedetails.FieldIssuerCommonName:
		return m.IssuerCommonName()
	case certificatedetails.FieldIssuerOrganization:
		return m.IssuerOrganization()
	case certificatedetails.FieldIssuerCountry:
		return m.IssuerCountry()
	case certificatedetails.FieldIssuerType:
		return m.IssuerType()
	case certificatedetails.FieldSignatureAlgorithm:
		return m.SignatureAlgorithm()
	case certificatedetails.FieldPublicKeyAlgorithm:
		return m.PublicKeyAlgorithm()
	case certificatedetails.FieldKeySize:
		return m.KeySize()
	case certificatedetails.FieldDNSNames:
		return m.DNSNames()
	case certificatedetails.FieldEmailAddresses:
		return m.EmailAddresses()
	case certificatedetails.FieldNotBefore:
		return m.NotBefore()
	case certificatedetails.FieldNotAfter:
		return m.NotAfter()
	case certificatedetails.FieldIsCa:
		return m.IsCa()
	case certificatedetails.FieldKeyUsage:
		return m.KeyUsage()
	case certificatedetails.FieldExtendedKeyUsage:
		return m.ExtendedKeyUsage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertificateDetailsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certificatedetails.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case certificatedetails.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case certificatedetails.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case certificatedetails.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case certificatedetails.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case certificatedetails.FieldCertificateID:
		return m.OldCertificateID(ctx)
	case certificatedetails.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case certificatedetails.FieldIPAddresses:
		return m.OldIPAddresses(ctx)
	case certificatedetails.FieldSubjectCommonName:
		return m.OldSubjectCommonName(ctx)
	case certificatedetails.FieldSubjectOrganization:
		return m.OldSubjectOrganization(ctx)
	case certificatedetails.FieldSubjectOrganizationalUnit:
		return m.OldSubjectOrganizationalUnit(ctx)
	case certificatedetails.FieldSubjectCountry:
		return m.OldSubjectCountry(ctx)
	case certificatedetails.FieldSubjectState:
		return m.OldSubjectState(ctx)
	case certificatedetails.FieldSubjectLocality:
		return m.OldSubjectLocality(ctx)
	case certificatedetails.FieldIssuerCommonName:
		return m.OldIssuerCommonName(ctx)
	case certificatedetails.FieldIssuerOrganization:
		return m.OldIssuerOrganization(ctx)
	case certificatedetails.FieldIssuerCountry:
		return m.OldIssuerCountry(ctx)
	case certificatedetails.FieldIssuerType:
		return m.OldIssuerType(ctx)
	case certificatedetails.FieldSignatureAlgorithm:
		return m.OldSignatureAlgorithm(ctx)
	case certificatedetails.FieldPublicKeyAlgorithm:
		return m.OldPublicKeyAlgorithm(ctx)
	case certificatedetails.FieldKeySize:
		return m.OldKeySize(ctx)
	case certificatedetails.FieldDNSNames:
		return m.OldDNSNames(ctx)
	case certificatedetails.FieldEmailAddresses:
		return m.OldEmailAddresses(ctx)
	case certificatedetails.FieldNotBefore:
		return m.OldNotBefore(ctx)
	case certificatedetails.FieldNotAfter:
		return m.OldNotAfter(ctx)
	case certificatedetails.FieldIsCa:
		return m.OldIsCa(ctx)
	case certificatedetails.FieldKeyUsage:
		return m.OldKeyUsage(ctx)
	case certificatedetails.FieldExtendedKeyUsage:
		return m.OldExtendedKeyUsage(ctx)
	}
	return nil, fmt.Errorf("unknown CertificateDetails field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificateDetailsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certificatedetails.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case certificatedetails.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case certificatedetails.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case certificatedetails.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case certificatedetails.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case certificatedetails.FieldCertificateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateID(v)
		return nil
	case certificatedetails.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case certificatedetails.FieldIPAddresses:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddresses(v)
		return nil
	case certificatedetails.FieldSubjectCommonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectCommonName(v)
		return nil
	case certificatedetails.FieldSubjectOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectOrganization(v)
		return nil
	case certificatedetails.FieldSubjectOrganizationalUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectOrganizationalUnit(v)
		return nil
	case certificatedetails.FieldSubjectCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectCountry(v)
		return nil
	case certificatedetails.FieldSubjectState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectState(v)
		return nil
	case certificatedetails.FieldSubjectLocality:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectLocality(v)
		return nil
	case certificatedetails.FieldIssuerCommonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerCommonName(v)
		return nil
	case certificatedetails.FieldIssuerOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerOrganization(v)
		return nil
	case certificatedetails.FieldIssuerCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerCountry(v)
		return nil
	case certificatedetails.FieldIssuerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerType(v)
		return nil
	case certificatedetails.FieldSignatureAlgorithm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignatureAlgorithm(v)
		return nil
	case certificatedetails.FieldPublicKeyAlgorithm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKeyAlgorithm(v)
		return nil
	case certificatedetails.FieldKeySize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeySize(v)
		return nil
	case certificatedetails.FieldDNSNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSNames(v)
		return nil
	case certificatedetails.FieldEmailAddresses:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailAddresses(v)
		return nil
	case certificatedetails.FieldNotBefore:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotBefore(v)
		return nil
	case certificatedetails.FieldNotAfter:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotAfter(v)
		return nil
	case certificatedetails.FieldIsCa:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCa(v)
		return nil
	case certificatedetails.FieldKeyUsage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyUsage(v)
		return nil
	case certificatedetails.FieldExtendedKeyUsage:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtendedKeyUsage(v)
		return nil
	}
	return fmt.Errorf("unknown CertificateDetails field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertificateDetailsMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, certificatedetails.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, certificatedetails.FieldUpdateBy)
	}
	if m.addkey_size != nil {
		fields = append(fields, certificatedetails.FieldKeySize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertificateDetailsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case certificatedetails.FieldCreateBy:
		return m.AddedCreateBy()
	case certificatedetails.FieldUpdateBy:
		return m.AddedUpdateBy()
	case certificatedetails.FieldKeySize:
		return m.AddedKeySize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificateDetailsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case certificatedetails.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case certificatedetails.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case certificatedetails.FieldKeySize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKeySize(v)
		return nil
	}
	return fmt.Errorf("unknown CertificateDetails numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertificateDetailsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certificatedetails.FieldCreateBy) {
		fields = append(fields, certificatedetails.FieldCreateBy)
	}
	if m.FieldCleared(certificatedetails.FieldUpdateBy) {
		fields = append(fields, certificatedetails.FieldUpdateBy)
	}
	if m.FieldCleared(certificatedetails.FieldCreateTime) {
		fields = append(fields, certificatedetails.FieldCreateTime)
	}
	if m.FieldCleared(certificatedetails.FieldUpdateTime) {
		fields = append(fields, certificatedetails.FieldUpdateTime)
	}
	if m.FieldCleared(certificatedetails.FieldDeleteTime) {
		fields = append(fields, certificatedetails.FieldDeleteTime)
	}
	if m.FieldCleared(certificatedetails.FieldSerialNumber) {
		fields = append(fields, certificatedetails.FieldSerialNumber)
	}
	if m.FieldCleared(certificatedetails.FieldIPAddresses) {
		fields = append(fields, certificatedetails.FieldIPAddresses)
	}
	if m.FieldCleared(certificatedetails.FieldSubjectCommonName) {
		fields = append(fields, certificatedetails.FieldSubjectCommonName)
	}
	if m.FieldCleared(certificatedetails.FieldSubjectOrganization) {
		fields = append(fields, certificatedetails.FieldSubjectOrganization)
	}
	if m.FieldCleared(certificatedetails.FieldSubjectOrganizationalUnit) {
		fields = append(fields, certificatedetails.FieldSubjectOrganizationalUnit)
	}
	if m.FieldCleared(certificatedetails.FieldSubjectCountry) {
		fields = append(fields, certificatedetails.FieldSubjectCountry)
	}
	if m.FieldCleared(certificatedetails.FieldSubjectState) {
		fields = append(fields, certificatedetails.FieldSubjectState)
	}
	if m.FieldCleared(certificatedetails.FieldSubjectLocality) {
		fields = append(fields, certificatedetails.FieldSubjectLocality)
	}
	if m.FieldCleared(certificatedetails.FieldIssuerCommonName) {
		fields = append(fields, certificatedetails.FieldIssuerCommonName)
	}
	if m.FieldCleared(certificatedetails.FieldIssuerOrganization) {
		fields = append(fields, certificatedetails.FieldIssuerOrganization)
	}
	if m.FieldCleared(certificatedetails.FieldIssuerCountry) {
		fields = append(fields, certificatedetails.FieldIssuerCountry)
	}
	if m.FieldCleared(certificatedetails.FieldIssuerType) {
		fields = append(fields, certificatedetails.FieldIssuerType)
	}
	if m.FieldCleared(certificatedetails.FieldSignatureAlgorithm) {
		fields = append(fields, certificatedetails.FieldSignatureAlgorithm)
	}
	if m.FieldCleared(certificatedetails.FieldPublicKeyAlgorithm) {
		fields = append(fields, certificatedetails.FieldPublicKeyAlgorithm)
	}
	if m.FieldCleared(certificatedetails.FieldKeySize) {
		fields = append(fields, certificatedetails.FieldKeySize)
	}
	if m.FieldCleared(certificatedetails.FieldDNSNames) {
		fields = append(fields, certificatedetails.FieldDNSNames)
	}
	if m.FieldCleared(certificatedetails.FieldEmailAddresses) {
		fields = append(fields, certificatedetails.FieldEmailAddresses)
	}
	if m.FieldCleared(certificatedetails.FieldNotBefore) {
		fields = append(fields, certificatedetails.FieldNotBefore)
	}
	if m.FieldCleared(certificatedetails.FieldNotAfter) {
		fields = append(fields, certificatedetails.FieldNotAfter)
	}
	if m.FieldCleared(certificatedetails.FieldKeyUsage) {
		fields = append(fields, certificatedetails.FieldKeyUsage)
	}
	if m.FieldCleared(certificatedetails.FieldExtendedKeyUsage) {
		fields = append(fields, certificatedetails.FieldExtendedKeyUsage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertificateDetailsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificateDetailsMutation) ClearField(name string) error {
	switch name {
	case certificatedetails.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case certificatedetails.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case certificatedetails.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case certificatedetails.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case certificatedetails.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case certificatedetails.FieldSerialNumber:
		m.ClearSerialNumber()
		return nil
	case certificatedetails.FieldIPAddresses:
		m.ClearIPAddresses()
		return nil
	case certificatedetails.FieldSubjectCommonName:
		m.ClearSubjectCommonName()
		return nil
	case certificatedetails.FieldSubjectOrganization:
		m.ClearSubjectOrganization()
		return nil
	case certificatedetails.FieldSubjectOrganizationalUnit:
		m.ClearSubjectOrganizationalUnit()
		return nil
	case certificatedetails.FieldSubjectCountry:
		m.ClearSubjectCountry()
		return nil
	case certificatedetails.FieldSubjectState:
		m.ClearSubjectState()
		return nil
	case certificatedetails.FieldSubjectLocality:
		m.ClearSubjectLocality()
		return nil
	case certificatedetails.FieldIssuerCommonName:
		m.ClearIssuerCommonName()
		return nil
	case certificatedetails.FieldIssuerOrganization:
		m.ClearIssuerOrganization()
		return nil
	case certificatedetails.FieldIssuerCountry:
		m.ClearIssuerCountry()
		return nil
	case certificatedetails.FieldIssuerType:
		m.ClearIssuerType()
		return nil
	case certificatedetails.FieldSignatureAlgorithm:
		m.ClearSignatureAlgorithm()
		return nil
	case certificatedetails.FieldPublicKeyAlgorithm:
		m.ClearPublicKeyAlgorithm()
		return nil
	case certificatedetails.FieldKeySize:
		m.ClearKeySize()
		return nil
	case certificatedetails.FieldDNSNames:
		m.ClearDNSNames()
		return nil
	case certificatedetails.FieldEmailAddresses:
		m.ClearEmailAddresses()
		return nil
	case certificatedetails.FieldNotBefore:
		m.ClearNotBefore()
		return nil
	case certificatedetails.FieldNotAfter:
		m.ClearNotAfter()
		return nil
	case certificatedetails.FieldKeyUsage:
		m.ClearKeyUsage()
		return nil
	case certificatedetails.FieldExtendedKeyUsage:
		m.ClearExtendedKeyUsage()
		return nil
	}
	return fmt.Errorf("unknown CertificateDetails nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertificateDetailsMutation) ResetField(name string) error {
	switch name {
	case certificatedetails.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case certificatedetails.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case certificatedetails.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case certificatedetails.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case certificatedetails.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case certificatedetails.FieldCertificateID:
		m.ResetCertificateID()
		return nil
	case certificatedetails.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case certificatedetails.FieldIPAddresses:
		m.ResetIPAddresses()
		return nil
	case certificatedetails.FieldSubjectCommonName:
		m.ResetSubjectCommonName()
		return nil
	case certificatedetails.FieldSubjectOrganization:
		m.ResetSubjectOrganization()
		return nil
	case certificatedetails.FieldSubjectOrganizationalUnit:
		m.ResetSubjectOrganizationalUnit()
		return nil
	case certificatedetails.FieldSubjectCountry:
		m.ResetSubjectCountry()
		return nil
	case certificatedetails.FieldSubjectState:
		m.ResetSubjectState()
		return nil
	case certificatedetails.FieldSubjectLocality:
		m.ResetSubjectLocality()
		return nil
	case certificatedetails.FieldIssuerCommonName:
		m.ResetIssuerCommonName()
		return nil
	case certificatedetails.FieldIssuerOrganization:
		m.ResetIssuerOrganization()
		return nil
	case certificatedetails.FieldIssuerCountry:
		m.ResetIssuerCountry()
		return nil
	case certificatedetails.FieldIssuerType:
		m.ResetIssuerType()
		return nil
	case certificatedetails.FieldSignatureAlgorithm:
		m.ResetSignatureAlgorithm()
		return nil
	case certificatedetails.FieldPublicKeyAlgorithm:
		m.ResetPublicKeyAlgorithm()
		return nil
	case certificatedetails.FieldKeySize:
		m.ResetKeySize()
		return nil
	case certificatedetails.FieldDNSNames:
		m.ResetDNSNames()
		return nil
	case certificatedetails.FieldEmailAddresses:
		m.ResetEmailAddresses()
		return nil
	case certificatedetails.FieldNotBefore:
		m.ResetNotBefore()
		return nil
	case certificatedetails.FieldNotAfter:
		m.ResetNotAfter()
		return nil
	case certificatedetails.FieldIsCa:
		m.ResetIsCa()
		return nil
	case certificatedetails.FieldKeyUsage:
		m.ResetKeyUsage()
		return nil
	case certificatedetails.FieldExtendedKeyUsage:
		m.ResetExtendedKeyUsage()
		return nil
	}
	return fmt.Errorf("unknown CertificateDetails field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertificateDetailsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.issued_certificate != nil {
		edges = append(edges, certificatedetails.EdgeIssuedCertificate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertificateDetailsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certificatedetails.EdgeIssuedCertificate:
		if id := m.issued_certificate; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertificateDetailsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertificateDetailsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertificateDetailsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedissued_certificate {
		edges = append(edges, certificatedetails.EdgeIssuedCertificate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertificateDetailsMutation) EdgeCleared(name string) bool {
	switch name {
	case certificatedetails.EdgeIssuedCertificate:
		return m.clearedissued_certificate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertificateDetailsMutation) ClearEdge(name string) error {
	switch name {
	case certificatedetails.EdgeIssuedCertificate:
		m.ClearIssuedCertificate()
		return nil
	}
	return fmt.Errorf("unknown CertificateDetails unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertificateDetailsMutation) ResetEdge(name string) error {
	switch name {
	case certificatedetails.EdgeIssuedCertificate:
		m.ResetIssuedCertificate()
		return nil
	}
	return fmt.Errorf("unknown CertificateDetails edge %s", name)
}

// CertificatePermissionMutation represents an operation that mutates the CertificatePermission nodes in the graph.
type CertificatePermissionMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint32
	tenant_id                 *uint32
	addtenant_id              *int32
	permission_type           *certificatepermission.PermissionType
	granted_by                *string
	expires_at                *time.Time
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	issued_certificate        *string
	clearedissued_certificate bool
	grantee                   *uint32
	clearedgrantee            bool
	done                      bool
	oldValue                  func(context.Context) (*CertificatePermission, error)
	predicates                []predicate.CertificatePermission
}

var _ ent.Mutation = (*CertificatePermissionMutation)(nil)

// certificatepermissionOption allows management of the mutation configuration using functional options.
type certificatepermissionOption func(*CertificatePermissionMutation)

// newCertificatePermissionMutation creates new mutation for the CertificatePermission entity.
func newCertificatePermissionMutation(c config, op Op, opts ...certificatepermissionOption) *CertificatePermissionMutation {
	m := &CertificatePermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeCertificatePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificatePermissionID sets the ID field of the mutation.
func withCertificatePermissionID(id uint32) certificatepermissionOption {
	return func(m *CertificatePermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *CertificatePermission
		)
		m.oldValue = func(ctx context.Context) (*CertificatePermission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CertificatePermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertificatePermission sets the old CertificatePermission of the mutation.
func withCertificatePermission(node *CertificatePermission) certificatepermissionOption {
	return func(m *CertificatePermissionMutation) {
		m.oldValue = func(context.Context) (*CertificatePermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificatePermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificatePermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CertificatePermission entities.
func (m *CertificatePermissionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertificatePermissionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertificatePermissionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CertificatePermission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *CertificatePermissionMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CertificatePermissionMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CertificatePermission entity.
// If the CertificatePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificatePermissionMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *CertificatePermissionMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *CertificatePermissionMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *CertificatePermissionMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[certificatepermission.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *CertificatePermissionMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[certificatepermission.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CertificatePermissionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, certificatepermission.FieldTenantID)
}

// SetCertificateID sets the "certificate_id" field.
func (m *CertificatePermissionMutation) SetCertificateID(s string) {
	m.issued_certificate = &s
}

// CertificateID returns the value of the "certificate_id" field in the mutation.
func (m *CertificatePermissionMutation) CertificateID() (r string, exists bool) {
	v := m.issued_certificate
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateID returns the old "certificate_id" field's value of the CertificatePermission entity.
// If the CertificatePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificatePermissionMutation) OldCertificateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateID: %w", err)
	}
	return oldValue.CertificateID, nil
}

// ResetCertificateID resets all changes to the "certificate_id" field.
func (m *CertificatePermissionMutation) ResetCertificateID() {
	m.issued_certificate = nil
}

// SetGranteeID sets the "grantee_id" field.
func (m *CertificatePermissionMutation) SetGranteeID(u uint32) {
	m.grantee = &u
}

// GranteeID returns the value of the "grantee_id" field in the mutation.
func (m *CertificatePermissionMutation) GranteeID() (r uint32, exists bool) {
	v := m.grantee
	if v == nil {
		return
	}
	return *v, true
}

// OldGranteeID returns the old "grantee_id" field's value of the CertificatePermission entity.
// If the CertificatePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificatePermissionMutation) OldGranteeID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGranteeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGranteeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGranteeID: %w", err)
	}
	return oldValue.GranteeID, nil
}

// ResetGranteeID resets all changes to the "grantee_id" field.
func (m *CertificatePermissionMutation) ResetGranteeID() {
	m.grantee = nil
}

// SetPermissionType sets the "permission_type" field.
func (m *CertificatePermissionMutation) SetPermissionType(ct certificatepermission.PermissionType) {
	m.permission_type = &ct
}

// PermissionType returns the value of the "permission_type" field in the mutation.
func (m *CertificatePermissionMutation) PermissionType() (r certificatepermission.PermissionType, exists bool) {
	v := m.permission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionType returns the old "permission_type" field's value of the CertificatePermission entity.
// If the CertificatePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificatePermissionMutation) OldPermissionType(ctx context.Context) (v certificatepermission.PermissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionType: %w", err)
	}
	return oldValue.PermissionType, nil
}

// ResetPermissionType resets all changes to the "permission_type" field.
func (m *CertificatePermissionMutation) ResetPermissionType() {
	m.permission_type = nil
}

// SetGrantedBy sets the "granted_by" field.
func (m *CertificatePermissionMutation) SetGrantedBy(s string) {
	m.granted_by = &s
}

// GrantedBy returns the value of the "granted_by" field in the mutation.
func (m *CertificatePermissionMutation) GrantedBy() (r string, exists bool) {
	v := m.granted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedBy returns the old "granted_by" field's value of the CertificatePermission entity.
// If the CertificatePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificatePermissionMutation) OldGrantedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedBy: %w", err)
	}
	return oldValue.GrantedBy, nil
}

// ResetGrantedBy resets all changes to the "granted_by" field.
func (m *CertificatePermissionMutation) ResetGrantedBy() {
	m.granted_by = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *CertificatePermissionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *CertificatePermissionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the CertificatePermission entity.
// If the CertificatePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificatePermissionMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *CertificatePermissionMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[certificatepermission.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *CertificatePermissionMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[certificatepermission.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *CertificatePermissionMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, certificatepermission.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *CertificatePermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CertificatePermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CertificatePermission entity.
// If the CertificatePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificatePermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CertificatePermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CertificatePermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CertificatePermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CertificatePermission entity.
// If the CertificatePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificatePermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CertificatePermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIssuedCertificateID sets the "issued_certificate" edge to the IssuedCertificate entity by id.
func (m *CertificatePermissionMutation) SetIssuedCertificateID(id string) {
	m.issued_certificate = &id
}

// ClearIssuedCertificate clears the "issued_certificate" edge to the IssuedCertificate entity.
func (m *CertificatePermissionMutation) ClearIssuedCertificate() {
	m.clearedissued_certificate = true
	m.clearedFields[certificatepermission.FieldCertificateID] = struct{}{}
}

// IssuedCertificateCleared reports if the "issued_certificate" edge to the IssuedCertificate entity was cleared.
func (m *CertificatePermissionMutation) IssuedCertificateCleared() bool {
	return m.clearedissued_certificate
}

// IssuedCertificateID returns the "issued_certificate" edge ID in the mutation.
func (m *CertificatePermissionMutation) IssuedCertificateID() (id string, exists bool) {
	if m.issued_certificate != nil {
		return *m.issued_certificate, true
	}
	return
}

// IssuedCertificateIDs returns the "issued_certificate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IssuedCertificateID instead. It exists only for internal usage by the builders.
func (m *CertificatePermissionMutation) IssuedCertificateIDs() (ids []string) {
	if id := m.issued_certificate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIssuedCertificate resets all changes to the "issued_certificate" edge.
func (m *CertificatePermissionMutation) ResetIssuedCertificate() {
	m.issued_certificate = nil
	m.clearedissued_certificate = false
}

// ClearGrantee clears the "grantee" edge to the LcmClient entity.
func (m *CertificatePermissionMutation) ClearGrantee() {
	m.clearedgrantee = true
	m.clearedFields[certificatepermission.FieldGranteeID] = struct{}{}
}

// GranteeCleared reports if the "grantee" edge to the LcmClient entity was cleared.
func (m *CertificatePermissionMutation) GranteeCleared() bool {
	return m.clearedgrantee
}

// GranteeIDs returns the "grantee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GranteeID instead. It exists only for internal usage by the builders.
func (m *CertificatePermissionMutation) GranteeIDs() (ids []uint32) {
	if id := m.grantee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGrantee resets all changes to the "grantee" edge.
func (m *CertificatePermissionMutation) ResetGrantee() {
	m.grantee = nil
	m.clearedgrantee = false
}

// Where appends a list predicates to the CertificatePermissionMutation builder.
func (m *CertificatePermissionMutation) Where(ps ...predicate.CertificatePermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertificatePermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertificatePermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CertificatePermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertificatePermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertificatePermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CertificatePermission).
func (m *CertificatePermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertificatePermissionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tenant_id != nil {
		fields = append(fields, certificatepermission.FieldTenantID)
	}
	if m.issued_certificate != nil {
		fields = append(fields, certificatepermission.FieldCertificateID)
	}
	if m.grantee != nil {
		fields = append(fields, certificatepermission.FieldGranteeID)
	}
	if m.permission_type != nil {
		fields = append(fields, certificatepermission.FieldPermissionType)
	}
	if m.granted_by != nil {
		fields = append(fields, certificatepermission.FieldGrantedBy)
	}
	if m.expires_at != nil {
		fields = append(fields, certificatepermission.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, certificatepermission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, certificatepermission.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertificatePermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certificatepermission.FieldTenantID:
		return m.TenantID()
	case certificatepermission.FieldCertificateID:
		return m.CertificateID()
	case certificatepermission.FieldGranteeID:
		return m.GranteeID()
	case certificatepermission.FieldPermissionType:
		return m.PermissionType()
	case certificatepermission.FieldGrantedBy:
		return m.GrantedBy()
	case certificatepermission.FieldExpiresAt:
		return m.ExpiresAt()
	case certificatepermission.FieldCreatedAt:
		return m.CreatedAt()
	case certificatepermission.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertificatePermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certificatepermission.FieldTenantID:
		return m.OldTenantID(ctx)
	case certificatepermission.FieldCertificateID:
		return m.OldCertificateID(ctx)
	case certificatepermission.FieldGranteeID:
		return m.OldGranteeID(ctx)
	case certificatepermission.FieldPermissionType:
		return m.OldPermissionType(ctx)
	case certificatepermission.FieldGrantedBy:
		return m.OldGrantedBy(ctx)
	case certificatepermission.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case certificatepermission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case certificatepermission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CertificatePermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificatePermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certificatepermission.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case certificatepermission.FieldCertificateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateID(v)
		return nil
	case certificatepermission.FieldGranteeID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGranteeID(v)
		return nil
	case certificatepermission.FieldPermissionType:
		v, ok := value.(certificatepermission.PermissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionType(v)
		return nil
	case certificatepermission.FieldGrantedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedBy(v)
		return nil
	case certificatepermission.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case certificatepermission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case certificatepermission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CertificatePermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertificatePermissionMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, certificatepermission.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertificatePermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case certificatepermission.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificatePermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case certificatepermission.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown CertificatePermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertificatePermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certificatepermission.FieldTenantID) {
		fields = append(fields, certificatepermission.FieldTenantID)
	}
	if m.FieldCleared(certificatepermission.FieldExpiresAt) {
		fields = append(fields, certificatepermission.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertificatePermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificatePermissionMutation) ClearField(name string) error {
	switch name {
	case certificatepermission.FieldTenantID:
		m.ClearTenantID()
		return nil
	case certificatepermission.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown CertificatePermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertificatePermissionMutation) ResetField(name string) error {
	switch name {
	case certificatepermission.FieldTenantID:
		m.ResetTenantID()
		return nil
	case certificatepermission.FieldCertificateID:
		m.ResetCertificateID()
		return nil
	case certificatepermission.FieldGranteeID:
		m.ResetGranteeID()
		return nil
	case certificatepermission.FieldPermissionType:
		m.ResetPermissionType()
		return nil
	case certificatepermission.FieldGrantedBy:
		m.ResetGrantedBy()
		return nil
	case certificatepermission.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case certificatepermission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case certificatepermission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CertificatePermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertificatePermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.issued_certificate != nil {
		edges = append(edges, certificatepermission.EdgeIssuedCertificate)
	}
	if m.grantee != nil {
		edges = append(edges, certificatepermission.EdgeGrantee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertificatePermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certificatepermission.EdgeIssuedCertificate:
		if id := m.issued_certificate; id != nil {
			return []ent.Value{*id}
		}
	case certificatepermission.EdgeGrantee:
		if id := m.grantee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertificatePermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertificatePermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertificatePermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedissued_certificate {
		edges = append(edges, certificatepermission.EdgeIssuedCertificate)
	}
	if m.clearedgrantee {
		edges = append(edges, certificatepermission.EdgeGrantee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertificatePermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case certificatepermission.EdgeIssuedCertificate:
		return m.clearedissued_certificate
	case certificatepermission.EdgeGrantee:
		return m.clearedgrantee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertificatePermissionMutation) ClearEdge(name string) error {
	switch name {
	case certificatepermission.EdgeIssuedCertificate:
		m.ClearIssuedCertificate()
		return nil
	case certificatepermission.EdgeGrantee:
		m.ClearGrantee()
		return nil
	}
	return fmt.Errorf("unknown CertificatePermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertificatePermissionMutation) ResetEdge(name string) error {
	switch name {
	case certificatepermission.EdgeIssuedCertificate:
		m.ResetIssuedCertificate()
		return nil
	case certificatepermission.EdgeGrantee:
		m.ResetGrantee()
		return nil
	}
	return fmt.Errorf("unknown CertificatePermission edge %s", name)
}

// CertificateRenewalMutation represents an operation that mutates the CertificateRenewal nodes in the graph.
type CertificateRenewalMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	client_id                 *string
	status                    *certificaterenewal.Status
	scheduled_at              *time.Time
	started_at                *time.Time
	completed_at              *time.Time
	attempt_number            *int32
	addattempt_number         *int32
	max_attempts              *int32
	addmax_attempts           *int32
	error_message             *string
	worker_id                 *string
	locked_at                 *time.Time
	lock_expires_at           *time.Time
	renewal_config            *map[string]interface{}
	issuer_name               *string
	domains                   *[]string
	appenddomains             []string
	original_expires_at       *time.Time
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	issued_certificate        *string
	clearedissued_certificate bool
	done                      bool
	oldValue                  func(context.Context) (*CertificateRenewal, error)
	predicates                []predicate.CertificateRenewal
}

var _ ent.Mutation = (*CertificateRenewalMutation)(nil)

// certificaterenewalOption allows management of the mutation configuration using functional options.
type certificaterenewalOption func(*CertificateRenewalMutation)

// newCertificateRenewalMutation creates new mutation for the CertificateRenewal entity.
func newCertificateRenewalMutation(c config, op Op, opts ...certificaterenewalOption) *CertificateRenewalMutation {
	m := &CertificateRenewalMutation{
		config:        c,
		op:            op,
		typ:           TypeCertificateRenewal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificateRenewalID sets the ID field of the mutation.
func withCertificateRenewalID(id int) certificaterenewalOption {
	return func(m *CertificateRenewalMutation) {
		var (
			err   error
			once  sync.Once
			value *CertificateRenewal
		)
		m.oldValue = func(ctx context.Context) (*CertificateRenewal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CertificateRenewal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertificateRenewal sets the old CertificateRenewal of the mutation.
func withCertificateRenewal(node *CertificateRenewal) certificaterenewalOption {
	return func(m *CertificateRenewalMutation) {
		m.oldValue = func(context.Context) (*CertificateRenewal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificateRenewalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificateRenewalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertificateRenewalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertificateRenewalMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CertificateRenewal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCertificateID sets the "certificate_id" field.
func (m *CertificateRenewalMutation) SetCertificateID(s string) {
	m.issued_certificate = &s
}

// CertificateID returns the value of the "certificate_id" field in the mutation.
func (m *CertificateRenewalMutation) CertificateID() (r string, exists bool) {
	v := m.issued_certificate
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateID returns the old "certificate_id" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldCertificateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateID: %w", err)
	}
	return oldValue.CertificateID, nil
}

// ResetCertificateID resets all changes to the "certificate_id" field.
func (m *CertificateRenewalMutation) ResetCertificateID() {
	m.issued_certificate = nil
}

// SetClientID sets the "client_id" field.
func (m *CertificateRenewalMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *CertificateRenewalMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *CertificateRenewalMutation) ResetClientID() {
	m.client_id = nil
}

// SetStatus sets the "status" field.
func (m *CertificateRenewalMutation) SetStatus(c certificaterenewal.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CertificateRenewalMutation) Status() (r certificaterenewal.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldStatus(ctx context.Context) (v certificaterenewal.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CertificateRenewalMutation) ResetStatus() {
	m.status = nil
}

// SetScheduledAt sets the "scheduled_at" field.
func (m *CertificateRenewalMutation) SetScheduledAt(t time.Time) {
	m.scheduled_at = &t
}

// ScheduledAt returns the value of the "scheduled_at" field in the mutation.
func (m *CertificateRenewalMutation) ScheduledAt() (r time.Time, exists bool) {
	v := m.scheduled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledAt returns the old "scheduled_at" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldScheduledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledAt: %w", err)
	}
	return oldValue.ScheduledAt, nil
}

// ResetScheduledAt resets all changes to the "scheduled_at" field.
func (m *CertificateRenewalMutation) ResetScheduledAt() {
	m.scheduled_at = nil
}

// SetStartedAt sets the "started_at" field.
func (m *CertificateRenewalMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *CertificateRenewalMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *CertificateRenewalMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[certificaterenewal.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *CertificateRenewalMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[certificaterenewal.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *CertificateRenewalMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, certificaterenewal.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *CertificateRenewalMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *CertificateRenewalMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *CertificateRenewalMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[certificaterenewal.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *CertificateRenewalMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[certificaterenewal.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *CertificateRenewalMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, certificaterenewal.FieldCompletedAt)
}

// SetAttemptNumber sets the "attempt_number" field.
func (m *CertificateRenewalMutation) SetAttemptNumber(i int32) {
	m.attempt_number = &i
	m.addattempt_number = nil
}

// AttemptNumber returns the value of the "attempt_number" field in the mutation.
func (m *CertificateRenewalMutation) AttemptNumber() (r int32, exists bool) {
	v := m.attempt_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAttemptNumber returns the old "attempt_number" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldAttemptNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttemptNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttemptNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttemptNumber: %w", err)
	}
	return oldValue.AttemptNumber, nil
}

// AddAttemptNumber adds i to the "attempt_number" field.
func (m *CertificateRenewalMutation) AddAttemptNumber(i int32) {
	if m.addattempt_number != nil {
		*m.addattempt_number += i
	} else {
		m.addattempt_number = &i
	}
}

// AddedAttemptNumber returns the value that was added to the "attempt_number" field in this mutation.
func (m *CertificateRenewalMutation) AddedAttemptNumber() (r int32, exists bool) {
	v := m.addattempt_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttemptNumber resets all changes to the "attempt_number" field.
func (m *CertificateRenewalMutation) ResetAttemptNumber() {
	m.attempt_number = nil
	m.addattempt_number = nil
}

// SetMaxAttempts sets the "max_attempts" field.
func (m *CertificateRenewalMutation) SetMaxAttempts(i int32) {
	m.max_attempts = &i
	m.addmax_attempts = nil
}

// MaxAttempts returns the value of the "max_attempts" field in the mutation.
func (m *CertificateRenewalMutation) MaxAttempts() (r int32, exists bool) {
	v := m.max_attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxAttempts returns the old "max_attempts" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldMaxAttempts(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxAttempts: %w", err)
	}
	return oldValue.MaxAttempts, nil
}

// AddMaxAttempts adds i to the "max_attempts" field.
func (m *CertificateRenewalMutation) AddMaxAttempts(i int32) {
	if m.addmax_attempts != nil {
		*m.addmax_attempts += i
	} else {
		m.addmax_attempts = &i
	}
}

// AddedMaxAttempts returns the value that was added to the "max_attempts" field in this mutation.
func (m *CertificateRenewalMutation) AddedMaxAttempts() (r int32, exists bool) {
	v := m.addmax_attempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxAttempts resets all changes to the "max_attempts" field.
func (m *CertificateRenewalMutation) ResetMaxAttempts() {
	m.max_attempts = nil
	m.addmax_attempts = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *CertificateRenewalMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *CertificateRenewalMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *CertificateRenewalMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[certificaterenewal.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *CertificateRenewalMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[certificaterenewal.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *CertificateRenewalMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, certificaterenewal.FieldErrorMessage)
}

// SetWorkerID sets the "worker_id" field.
func (m *CertificateRenewalMutation) SetWorkerID(s string) {
	m.worker_id = &s
}

// WorkerID returns the value of the "worker_id" field in the mutation.
func (m *CertificateRenewalMutation) WorkerID() (r string, exists bool) {
	v := m.worker_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkerID returns the old "worker_id" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldWorkerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkerID: %w", err)
	}
	return oldValue.WorkerID, nil
}

// ClearWorkerID clears the value of the "worker_id" field.
func (m *CertificateRenewalMutation) ClearWorkerID() {
	m.worker_id = nil
	m.clearedFields[certificaterenewal.FieldWorkerID] = struct{}{}
}

// WorkerIDCleared returns if the "worker_id" field was cleared in this mutation.
func (m *CertificateRenewalMutation) WorkerIDCleared() bool {
	_, ok := m.clearedFields[certificaterenewal.FieldWorkerID]
	return ok
}

// ResetWorkerID resets all changes to the "worker_id" field.
func (m *CertificateRenewalMutation) ResetWorkerID() {
	m.worker_id = nil
	delete(m.clearedFields, certificaterenewal.FieldWorkerID)
}

// SetLockedAt sets the "locked_at" field.
func (m *CertificateRenewalMutation) SetLockedAt(t time.Time) {
	m.locked_at = &t
}

// LockedAt returns the value of the "locked_at" field in the mutation.
func (m *CertificateRenewalMutation) LockedAt() (r time.Time, exists bool) {
	v := m.locked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedAt returns the old "locked_at" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldLockedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedAt: %w", err)
	}
	return oldValue.LockedAt, nil
}

// ClearLockedAt clears the value of the "locked_at" field.
func (m *CertificateRenewalMutation) ClearLockedAt() {
	m.locked_at = nil
	m.clearedFields[certificaterenewal.FieldLockedAt] = struct{}{}
}

// LockedAtCleared returns if the "locked_at" field was cleared in this mutation.
func (m *CertificateRenewalMutation) LockedAtCleared() bool {
	_, ok := m.clearedFields[certificaterenewal.FieldLockedAt]
	return ok
}

// ResetLockedAt resets all changes to the "locked_at" field.
func (m *CertificateRenewalMutation) ResetLockedAt() {
	m.locked_at = nil
	delete(m.clearedFields, certificaterenewal.FieldLockedAt)
}

// SetLockExpiresAt sets the "lock_expires_at" field.
func (m *CertificateRenewalMutation) SetLockExpiresAt(t time.Time) {
	m.lock_expires_at = &t
}

// LockExpiresAt returns the value of the "lock_expires_at" field in the mutation.
func (m *CertificateRenewalMutation) LockExpiresAt() (r time.Time, exists bool) {
	v := m.lock_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLockExpiresAt returns the old "lock_expires_at" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldLockExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockExpiresAt: %w", err)
	}
	return oldValue.LockExpiresAt, nil
}

// ClearLockExpiresAt clears the value of the "lock_expires_at" field.
func (m *CertificateRenewalMutation) ClearLockExpiresAt() {
	m.lock_expires_at = nil
	m.clearedFields[certificaterenewal.FieldLockExpiresAt] = struct{}{}
}

// LockExpiresAtCleared returns if the "lock_expires_at" field was cleared in this mutation.
func (m *CertificateRenewalMutation) LockExpiresAtCleared() bool {
	_, ok := m.clearedFields[certificaterenewal.FieldLockExpiresAt]
	return ok
}

// ResetLockExpiresAt resets all changes to the "lock_expires_at" field.
func (m *CertificateRenewalMutation) ResetLockExpiresAt() {
	m.lock_expires_at = nil
	delete(m.clearedFields, certificaterenewal.FieldLockExpiresAt)
}

// SetRenewalConfig sets the "renewal_config" field.
func (m *CertificateRenewalMutation) SetRenewalConfig(value map[string]interface{}) {
	m.renewal_config = &value
}

// RenewalConfig returns the value of the "renewal_config" field in the mutation.
func (m *CertificateRenewalMutation) RenewalConfig() (r map[string]interface{}, exists bool) {
	v := m.renewal_config
	if v == nil {
		return
	}
	return *v, true
}

// OldRenewalConfig returns the old "renewal_config" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldRenewalConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenewalConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenewalConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenewalConfig: %w", err)
	}
	return oldValue.RenewalConfig, nil
}

// ClearRenewalConfig clears the value of the "renewal_config" field.
func (m *CertificateRenewalMutation) ClearRenewalConfig() {
	m.renewal_config = nil
	m.clearedFields[certificaterenewal.FieldRenewalConfig] = struct{}{}
}

// RenewalConfigCleared returns if the "renewal_config" field was cleared in this mutation.
func (m *CertificateRenewalMutation) RenewalConfigCleared() bool {
	_, ok := m.clearedFields[certificaterenewal.FieldRenewalConfig]
	return ok
}

// ResetRenewalConfig resets all changes to the "renewal_config" field.
func (m *CertificateRenewalMutation) ResetRenewalConfig() {
	m.renewal_config = nil
	delete(m.clearedFields, certificaterenewal.FieldRenewalConfig)
}

// SetIssuerName sets the "issuer_name" field.
func (m *CertificateRenewalMutation) SetIssuerName(s string) {
	m.issuer_name = &s
}

// IssuerName returns the value of the "issuer_name" field in the mutation.
func (m *CertificateRenewalMutation) IssuerName() (r string, exists bool) {
	v := m.issuer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerName returns the old "issuer_name" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldIssuerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerName: %w", err)
	}
	return oldValue.IssuerName, nil
}

// ResetIssuerName resets all changes to the "issuer_name" field.
func (m *CertificateRenewalMutation) ResetIssuerName() {
	m.issuer_name = nil
}

// SetDomains sets the "domains" field.
func (m *CertificateRenewalMutation) SetDomains(s []string) {
	m.domains = &s
	m.appenddomains = nil
}

// Domains returns the value of the "domains" field in the mutation.
func (m *CertificateRenewalMutation) Domains() (r []string, exists bool) {
	v := m.domains
	if v == nil {
		return
	}
	return *v, true
}

// OldDomains returns the old "domains" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomains: %w", err)
	}
	return oldValue.Domains, nil
}

// AppendDomains adds s to the "domains" field.
func (m *CertificateRenewalMutation) AppendDomains(s []string) {
	m.appenddomains = append(m.appenddomains, s...)
}

// AppendedDomains returns the list of values that were appended to the "domains" field in this mutation.
func (m *CertificateRenewalMutation) AppendedDomains() ([]string, bool) {
	if len(m.appenddomains) == 0 {
		return nil, false
	}
	return m.appenddomains, true
}

// ResetDomains resets all changes to the "domains" field.
func (m *CertificateRenewalMutation) ResetDomains() {
	m.domains = nil
	m.appenddomains = nil
}

// SetOriginalExpiresAt sets the "original_expires_at" field.
func (m *CertificateRenewalMutation) SetOriginalExpiresAt(t time.Time) {
	m.original_expires_at = &t
}

// OriginalExpiresAt returns the value of the "original_expires_at" field in the mutation.
func (m *CertificateRenewalMutation) OriginalExpiresAt() (r time.Time, exists bool) {
	v := m.original_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalExpiresAt returns the old "original_expires_at" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldOriginalExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalExpiresAt: %w", err)
	}
	return oldValue.OriginalExpiresAt, nil
}

// ResetOriginalExpiresAt resets all changes to the "original_expires_at" field.
func (m *CertificateRenewalMutation) ResetOriginalExpiresAt() {
	m.original_expires_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CertificateRenewalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CertificateRenewalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CertificateRenewalMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CertificateRenewalMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CertificateRenewalMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CertificateRenewal entity.
// If the CertificateRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRenewalMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CertificateRenewalMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIssuedCertificateID sets the "issued_certificate" edge to the IssuedCertificate entity by id.
func (m *CertificateRenewalMutation) SetIssuedCertificateID(id string) {
	m.issued_certificate = &id
}

// ClearIssuedCertificate clears the "issued_certificate" edge to the IssuedCertificate entity.
func (m *CertificateRenewalMutation) ClearIssuedCertificate() {
	m.clearedissued_certificate = true
	m.clearedFields[certificaterenewal.FieldCertificateID] = struct{}{}
}

// IssuedCertificateCleared reports if the "issued_certificate" edge to the IssuedCertificate entity was cleared.
func (m *CertificateRenewalMutation) IssuedCertificateCleared() bool {
	return m.clearedissued_certificate
}

// IssuedCertificateID returns the "issued_certificate" edge ID in the mutation.
func (m *CertificateRenewalMutation) IssuedCertificateID() (id string, exists bool) {
	if m.issued_certificate != nil {
		return *m.issued_certificate, true
	}
	return
}

// IssuedCertificateIDs returns the "issued_certificate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IssuedCertificateID instead. It exists only for internal usage by the builders.
func (m *CertificateRenewalMutation) IssuedCertificateIDs() (ids []string) {
	if id := m.issued_certificate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIssuedCertificate resets all changes to the "issued_certificate" edge.
func (m *CertificateRenewalMutation) ResetIssuedCertificate() {
	m.issued_certificate = nil
	m.clearedissued_certificate = false
}

// Where appends a list predicates to the CertificateRenewalMutation builder.
func (m *CertificateRenewalMutation) Where(ps ...predicate.CertificateRenewal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertificateRenewalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertificateRenewalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CertificateRenewal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertificateRenewalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertificateRenewalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CertificateRenewal).
func (m *CertificateRenewalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertificateRenewalMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.issued_certificate != nil {
		fields = append(fields, certificaterenewal.FieldCertificateID)
	}
	if m.client_id != nil {
		fields = append(fields, certificaterenewal.FieldClientID)
	}
	if m.status != nil {
		fields = append(fields, certificaterenewal.FieldStatus)
	}
	if m.scheduled_at != nil {
		fields = append(fields, certificaterenewal.FieldScheduledAt)
	}
	if m.started_at != nil {
		fields = append(fields, certificaterenewal.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, certificaterenewal.FieldCompletedAt)
	}
	if m.attempt_number != nil {
		fields = append(fields, certificaterenewal.FieldAttemptNumber)
	}
	if m.max_attempts != nil {
		fields = append(fields, certificaterenewal.FieldMaxAttempts)
	}
	if m.error_message != nil {
		fields = append(fields, certificaterenewal.FieldErrorMessage)
	}
	if m.worker_id != nil {
		fields = append(fields, certificaterenewal.FieldWorkerID)
	}
	if m.locked_at != nil {
		fields = append(fields, certificaterenewal.FieldLockedAt)
	}
	if m.lock_expires_at != nil {
		fields = append(fields, certificaterenewal.FieldLockExpiresAt)
	}
	if m.renewal_config != nil {
		fields = append(fields, certificaterenewal.FieldRenewalConfig)
	}
	if m.issuer_name != nil {
		fields = append(fields, certificaterenewal.FieldIssuerName)
	}
	if m.domains != nil {
		fields = append(fields, certificaterenewal.FieldDomains)
	}
	if m.original_expires_at != nil {
		fields = append(fields, certificaterenewal.FieldOriginalExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, certificaterenewal.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, certificaterenewal.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertificateRenewalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certificaterenewal.FieldCertificateID:
		return m.CertificateID()
	case certificaterenewal.FieldClientID:
		return m.ClientID()
	case certificaterenewal.FieldStatus:
		return m.Status()
	case certificaterenewal.FieldScheduledAt:
		return m.ScheduledAt()
	case certificaterenewal.FieldStartedAt:
		return m.StartedAt()
	case certificaterenewal.FieldCompletedAt:
		return m.CompletedAt()
	case certificaterenewal.FieldAttemptNumber:
		return m.AttemptNumber()
	case certificaterenewal.FieldMaxAttempts:
		return m.MaxAttempts()
	case certificaterenewal.FieldErrorMessage:
		return m.ErrorMessage()
	case certificaterenewal.FieldWorkerID:
		return m.WorkerID()
	case certificaterenewal.FieldLockedAt:
		return m.LockedAt()
	case certificaterenewal.FieldLockExpiresAt:
		return m.LockExpiresAt()
	case certificaterenewal.FieldRenewalConfig:
		return m.RenewalConfig()
	case certificaterenewal.FieldIssuerName:
		return m.IssuerName()
	case certificaterenewal.FieldDomains:
		return m.Domains()
	case certificaterenewal.FieldOriginalExpiresAt:
		return m.OriginalExpiresAt()
	case certificaterenewal.FieldCreatedAt:
		return m.CreatedAt()
	case certificaterenewal.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertificateRenewalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certificaterenewal.FieldCertificateID:
		return m.OldCertificateID(ctx)
	case certificaterenewal.FieldClientID:
		return m.OldClientID(ctx)
	case certificaterenewal.FieldStatus:
		return m.OldStatus(ctx)
	case certificaterenewal.FieldScheduledAt:
		return m.OldScheduledAt(ctx)
	case certificaterenewal.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case certificaterenewal.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case certificaterenewal.FieldAttemptNumber:
		return m.OldAttemptNumber(ctx)
	case certificaterenewal.FieldMaxAttempts:
		return m.OldMaxAttempts(ctx)
	case certificaterenewal.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case certificaterenewal.FieldWorkerID:
		return m.OldWorkerID(ctx)
	case certificaterenewal.FieldLockedAt:
		return m.OldLockedAt(ctx)
	case certificaterenewal.FieldLockExpiresAt:
		return m.OldLockExpiresAt(ctx)
	case certificaterenewal.FieldRenewalConfig:
		return m.OldRenewalConfig(ctx)
	case certificaterenewal.FieldIssuerName:
		return m.OldIssuerName(ctx)
	case certificaterenewal.FieldDomains:
		return m.OldDomains(ctx)
	case certificaterenewal.FieldOriginalExpiresAt:
		return m.OldOriginalExpiresAt(ctx)
	case certificaterenewal.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case certificaterenewal.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CertificateRenewal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificateRenewalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certificaterenewal.FieldCertificateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateID(v)
		return nil
	case certificaterenewal.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case certificaterenewal.FieldStatus:
		v, ok := value.(certificaterenewal.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case certificaterenewal.FieldScheduledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledAt(v)
		return nil
	case certificaterenewal.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case certificaterenewal.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case certificaterenewal.FieldAttemptNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttemptNumber(v)
		return nil
	case certificaterenewal.FieldMaxAttempts:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxAttempts(v)
		return nil
	case certificaterenewal.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case certificaterenewal.FieldWorkerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkerID(v)
		return nil
	case certificaterenewal.FieldLockedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedAt(v)
		return nil
	case certificaterenewal.FieldLockExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockExpiresAt(v)
		return nil
	case certificaterenewal.FieldRenewalConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenewalConfig(v)
		return nil
	case certificaterenewal.FieldIssuerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerName(v)
		return nil
	case certificaterenewal.FieldDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomains(v)
		return nil
	case certificaterenewal.FieldOriginalExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalExpiresAt(v)
		return nil
	case certificaterenewal.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case certificaterenewal.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CertificateRenewal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertificateRenewalMutation) AddedFields() []string {
	var fields []string
	if m.addattempt_number != nil {
		fields = append(fields, certificaterenewal.FieldAttemptNumber)
	}
	if m.addmax_attempts != nil {
		fields = append(fields, certificaterenewal.FieldMaxAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertificateRenewalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case certificaterenewal.FieldAttemptNumber:
		return m.AddedAttemptNumber()
	case certificaterenewal.FieldMaxAttempts:
		return m.AddedMaxAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificateRenewalMutation) AddField(name string, value ent.Value) error {
	switch name {
	case certificaterenewal.FieldAttemptNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttemptNumber(v)
		return nil
	case certificaterenewal.FieldMaxAttempts:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown CertificateRenewal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertificateRenewalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certificaterenewal.FieldStartedAt) {
		fields = append(fields, certificaterenewal.FieldStartedAt)
	}
	if m.FieldCleared(certificaterenewal.FieldCompletedAt) {
		fields = append(fields, certificaterenewal.FieldCompletedAt)
	}
	if m.FieldCleared(certificaterenewal.FieldErrorMessage) {
		fields = append(fields, certificaterenewal.FieldErrorMessage)
	}
	if m.FieldCleared(certificaterenewal.FieldWorkerID) {
		fields = append(fields, certificaterenewal.FieldWorkerID)
	}
	if m.FieldCleared(certificaterenewal.FieldLockedAt) {
		fields = append(fields, certificaterenewal.FieldLockedAt)
	}
	if m.FieldCleared(certificaterenewal.FieldLockExpiresAt) {
		fields = append(fields, certificaterenewal.FieldLockExpiresAt)
	}
	if m.FieldCleared(certificaterenewal.FieldRenewalConfig) {
		fields = append(fields, certificaterenewal.FieldRenewalConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertificateRenewalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificateRenewalMutation) ClearField(name string) error {
	switch name {
	case certificaterenewal.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case certificaterenewal.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case certificaterenewal.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case certificaterenewal.FieldWorkerID:
		m.ClearWorkerID()
		return nil
	case certificaterenewal.FieldLockedAt:
		m.ClearLockedAt()
		return nil
	case certificaterenewal.FieldLockExpiresAt:
		m.ClearLockExpiresAt()
		return nil
	case certificaterenewal.FieldRenewalConfig:
		m.ClearRenewalConfig()
		return nil
	}
	return fmt.Errorf("unknown CertificateRenewal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertificateRenewalMutation) ResetField(name string) error {
	switch name {
	case certificaterenewal.FieldCertificateID:
		m.ResetCertificateID()
		return nil
	case certificaterenewal.FieldClientID:
		m.ResetClientID()
		return nil
	case certificaterenewal.FieldStatus:
		m.ResetStatus()
		return nil
	case certificaterenewal.FieldScheduledAt:
		m.ResetScheduledAt()
		return nil
	case certificaterenewal.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case certificaterenewal.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case certificaterenewal.FieldAttemptNumber:
		m.ResetAttemptNumber()
		return nil
	case certificaterenewal.FieldMaxAttempts:
		m.ResetMaxAttempts()
		return nil
	case certificaterenewal.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case certificaterenewal.FieldWorkerID:
		m.ResetWorkerID()
		return nil
	case certificaterenewal.FieldLockedAt:
		m.ResetLockedAt()
		return nil
	case certificaterenewal.FieldLockExpiresAt:
		m.ResetLockExpiresAt()
		return nil
	case certificaterenewal.FieldRenewalConfig:
		m.ResetRenewalConfig()
		return nil
	case certificaterenewal.FieldIssuerName:
		m.ResetIssuerName()
		return nil
	case certificaterenewal.FieldDomains:
		m.ResetDomains()
		return nil
	case certificaterenewal.FieldOriginalExpiresAt:
		m.ResetOriginalExpiresAt()
		return nil
	case certificaterenewal.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case certificaterenewal.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CertificateRenewal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertificateRenewalMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.issued_certificate != nil {
		edges = append(edges, certificaterenewal.EdgeIssuedCertificate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertificateRenewalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certificaterenewal.EdgeIssuedCertificate:
		if id := m.issued_certificate; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertificateRenewalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertificateRenewalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertificateRenewalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedissued_certificate {
		edges = append(edges, certificaterenewal.EdgeIssuedCertificate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertificateRenewalMutation) EdgeCleared(name string) bool {
	switch name {
	case certificaterenewal.EdgeIssuedCertificate:
		return m.clearedissued_certificate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertificateRenewalMutation) ClearEdge(name string) error {
	switch name {
	case certificaterenewal.EdgeIssuedCertificate:
		m.ClearIssuedCertificate()
		return nil
	}
	return fmt.Errorf("unknown CertificateRenewal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertificateRenewalMutation) ResetEdge(name string) error {
	switch name {
	case certificaterenewal.EdgeIssuedCertificate:
		m.ResetIssuedCertificate()
		return nil
	}
	return fmt.Errorf("unknown CertificateRenewal edge %s", name)
}

// CertificateRequestMutation represents an operation that mutates the CertificateRequest nodes in the graph.
type CertificateRequestMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	request_id         *string
	client_id          *string
	issuer_name        *string
	hostname           *string
	public_key         *string
	dns_names          *[]string
	appenddns_names    []string
	ip_addresses       *[]string
	appendip_addresses []string
	metadata           *map[string]string
	status             *certificaterequest.Status
	certificate        *string
	expires_at         *time.Time
	revoked_at         *time.Time
	revoked_by         *string
	revoked_reason     *string
	approved_by        *string
	approved_at        *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	issuer             *uint32
	clearedissuer      bool
	lcm_client         *uint32
	clearedlcm_client  bool
	done               bool
	oldValue           func(context.Context) (*CertificateRequest, error)
	predicates         []predicate.CertificateRequest
}

var _ ent.Mutation = (*CertificateRequestMutation)(nil)

// certificaterequestOption allows management of the mutation configuration using functional options.
type certificaterequestOption func(*CertificateRequestMutation)

// newCertificateRequestMutation creates new mutation for the CertificateRequest entity.
func newCertificateRequestMutation(c config, op Op, opts ...certificaterequestOption) *CertificateRequestMutation {
	m := &CertificateRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeCertificateRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificateRequestID sets the ID field of the mutation.
func withCertificateRequestID(id int) certificaterequestOption {
	return func(m *CertificateRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *CertificateRequest
		)
		m.oldValue = func(ctx context.Context) (*CertificateRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CertificateRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertificateRequest sets the old CertificateRequest of the mutation.
func withCertificateRequest(node *CertificateRequest) certificaterequestOption {
	return func(m *CertificateRequestMutation) {
		m.oldValue = func(context.Context) (*CertificateRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificateRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificateRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertificateRequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertificateRequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CertificateRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestID sets the "request_id" field.
func (m *CertificateRequestMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *CertificateRequestMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *CertificateRequestMutation) ResetRequestID() {
	m.request_id = nil
}

// SetClientID sets the "client_id" field.
func (m *CertificateRequestMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *CertificateRequestMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *CertificateRequestMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[certificaterequest.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *CertificateRequestMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[certificaterequest.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *CertificateRequestMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, certificaterequest.FieldClientID)
}

// SetIssuerName sets the "issuer_name" field.
func (m *CertificateRequestMutation) SetIssuerName(s string) {
	m.issuer_name = &s
}

// IssuerName returns the value of the "issuer_name" field in the mutation.
func (m *CertificateRequestMutation) IssuerName() (r string, exists bool) {
	v := m.issuer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerName returns the old "issuer_name" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldIssuerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerName: %w", err)
	}
	return oldValue.IssuerName, nil
}

// ClearIssuerName clears the value of the "issuer_name" field.
func (m *CertificateRequestMutation) ClearIssuerName() {
	m.issuer_name = nil
	m.clearedFields[certificaterequest.FieldIssuerName] = struct{}{}
}

// IssuerNameCleared returns if the "issuer_name" field was cleared in this mutation.
func (m *CertificateRequestMutation) IssuerNameCleared() bool {
	_, ok := m.clearedFields[certificaterequest.FieldIssuerName]
	return ok
}

// ResetIssuerName resets all changes to the "issuer_name" field.
func (m *CertificateRequestMutation) ResetIssuerName() {
	m.issuer_name = nil
	delete(m.clearedFields, certificaterequest.FieldIssuerName)
}

// SetHostname sets the "hostname" field.
func (m *CertificateRequestMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *CertificateRequestMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *CertificateRequestMutation) ResetHostname() {
	m.hostname = nil
}

// SetPublicKey sets the "public_key" field.
func (m *CertificateRequestMutation) SetPublicKey(s string) {
	m.public_key = &s
}

// PublicKey returns the value of the "public_key" field in the mutation.
func (m *CertificateRequestMutation) PublicKey() (r string, exists bool) {
	v := m.public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "public_key" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldPublicKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "public_key" field.
func (m *CertificateRequestMutation) ResetPublicKey() {
	m.public_key = nil
}

// SetDNSNames sets the "dns_names" field.
func (m *CertificateRequestMutation) SetDNSNames(s []string) {
	m.dns_names = &s
	m.appenddns_names = nil
}

// DNSNames returns the value of the "dns_names" field in the mutation.
func (m *CertificateRequestMutation) DNSNames() (r []string, exists bool) {
	v := m.dns_names
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSNames returns the old "dns_names" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldDNSNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSNames: %w", err)
	}
	return oldValue.DNSNames, nil
}

// AppendDNSNames adds s to the "dns_names" field.
func (m *CertificateRequestMutation) AppendDNSNames(s []string) {
	m.appenddns_names = append(m.appenddns_names, s...)
}

// AppendedDNSNames returns the list of values that were appended to the "dns_names" field in this mutation.
func (m *CertificateRequestMutation) AppendedDNSNames() ([]string, bool) {
	if len(m.appenddns_names) == 0 {
		return nil, false
	}
	return m.appenddns_names, true
}

// ClearDNSNames clears the value of the "dns_names" field.
func (m *CertificateRequestMutation) ClearDNSNames() {
	m.dns_names = nil
	m.appenddns_names = nil
	m.clearedFields[certificaterequest.FieldDNSNames] = struct{}{}
}

// DNSNamesCleared returns if the "dns_names" field was cleared in this mutation.
func (m *CertificateRequestMutation) DNSNamesCleared() bool {
	_, ok := m.clearedFields[certificaterequest.FieldDNSNames]
	return ok
}

// ResetDNSNames resets all changes to the "dns_names" field.
func (m *CertificateRequestMutation) ResetDNSNames() {
	m.dns_names = nil
	m.appenddns_names = nil
	delete(m.clearedFields, certificaterequest.FieldDNSNames)
}

// SetIPAddresses sets the "ip_addresses" field.
func (m *CertificateRequestMutation) SetIPAddresses(s []string) {
	m.ip_addresses = &s
	m.appendip_addresses = nil
}

// IPAddresses returns the value of the "ip_addresses" field in the mutation.
func (m *CertificateRequestMutation) IPAddresses() (r []string, exists bool) {
	v := m.ip_addresses
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddresses returns the old "ip_addresses" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldIPAddresses(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddresses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddresses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddresses: %w", err)
	}
	return oldValue.IPAddresses, nil
}

// AppendIPAddresses adds s to the "ip_addresses" field.
func (m *CertificateRequestMutation) AppendIPAddresses(s []string) {
	m.appendip_addresses = append(m.appendip_addresses, s...)
}

// AppendedIPAddresses returns the list of values that were appended to the "ip_addresses" field in this mutation.
func (m *CertificateRequestMutation) AppendedIPAddresses() ([]string, bool) {
	if len(m.appendip_addresses) == 0 {
		return nil, false
	}
	return m.appendip_addresses, true
}

// ClearIPAddresses clears the value of the "ip_addresses" field.
func (m *CertificateRequestMutation) ClearIPAddresses() {
	m.ip_addresses = nil
	m.appendip_addresses = nil
	m.clearedFields[certificaterequest.FieldIPAddresses] = struct{}{}
}

// IPAddressesCleared returns if the "ip_addresses" field was cleared in this mutation.
func (m *CertificateRequestMutation) IPAddressesCleared() bool {
	_, ok := m.clearedFields[certificaterequest.FieldIPAddresses]
	return ok
}

// ResetIPAddresses resets all changes to the "ip_addresses" field.
func (m *CertificateRequestMutation) ResetIPAddresses() {
	m.ip_addresses = nil
	m.appendip_addresses = nil
	delete(m.clearedFields, certificaterequest.FieldIPAddresses)
}

// SetMetadata sets the "metadata" field.
func (m *CertificateRequestMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *CertificateRequestMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *CertificateRequestMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[certificaterequest.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *CertificateRequestMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[certificaterequest.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *CertificateRequestMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, certificaterequest.FieldMetadata)
}

// SetStatus sets the "status" field.
func (m *CertificateRequestMutation) SetStatus(c certificaterequest.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CertificateRequestMutation) Status() (r certificaterequest.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldStatus(ctx context.Context) (v certificaterequest.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CertificateRequestMutation) ResetStatus() {
	m.status = nil
}

// SetCertificate sets the "certificate" field.
func (m *CertificateRequestMutation) SetCertificate(s string) {
	m.certificate = &s
}

// Certificate returns the value of the "certificate" field in the mutation.
func (m *CertificateRequestMutation) Certificate() (r string, exists bool) {
	v := m.certificate
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificate returns the old "certificate" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldCertificate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificate: %w", err)
	}
	return oldValue.Certificate, nil
}

// ClearCertificate clears the value of the "certificate" field.
func (m *CertificateRequestMutation) ClearCertificate() {
	m.certificate = nil
	m.clearedFields[certificaterequest.FieldCertificate] = struct{}{}
}

// CertificateCleared returns if the "certificate" field was cleared in this mutation.
func (m *CertificateRequestMutation) CertificateCleared() bool {
	_, ok := m.clearedFields[certificaterequest.FieldCertificate]
	return ok
}

// ResetCertificate resets all changes to the "certificate" field.
func (m *CertificateRequestMutation) ResetCertificate() {
	m.certificate = nil
	delete(m.clearedFields, certificaterequest.FieldCertificate)
}

// SetExpiresAt sets the "expires_at" field.
func (m *CertificateRequestMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *CertificateRequestMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *CertificateRequestMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[certificaterequest.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *CertificateRequestMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[certificaterequest.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *CertificateRequestMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, certificaterequest.FieldExpiresAt)
}

// SetRevokedAt sets the "revoked_at" field.
func (m *CertificateRequestMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *CertificateRequestMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldRevokedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *CertificateRequestMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[certificaterequest.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *CertificateRequestMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[certificaterequest.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *CertificateRequestMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, certificaterequest.FieldRevokedAt)
}

// SetRevokedBy sets the "revoked_by" field.
func (m *CertificateRequestMutation) SetRevokedBy(s string) {
	m.revoked_by = &s
}

// RevokedBy returns the value of the "revoked_by" field in the mutation.
func (m *CertificateRequestMutation) RevokedBy() (r string, exists bool) {
	v := m.revoked_by
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedBy returns the old "revoked_by" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldRevokedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedBy: %w", err)
	}
	return oldValue.RevokedBy, nil
}

// ClearRevokedBy clears the value of the "revoked_by" field.
func (m *CertificateRequestMutation) ClearRevokedBy() {
	m.revoked_by = nil
	m.clearedFields[certificaterequest.FieldRevokedBy] = struct{}{}
}

// RevokedByCleared returns if the "revoked_by" field was cleared in this mutation.
func (m *CertificateRequestMutation) RevokedByCleared() bool {
	_, ok := m.clearedFields[certificaterequest.FieldRevokedBy]
	return ok
}

// ResetRevokedBy resets all changes to the "revoked_by" field.
func (m *CertificateRequestMutation) ResetRevokedBy() {
	m.revoked_by = nil
	delete(m.clearedFields, certificaterequest.FieldRevokedBy)
}

// SetRevokedReason sets the "revoked_reason" field.
func (m *CertificateRequestMutation) SetRevokedReason(s string) {
	m.revoked_reason = &s
}

// RevokedReason returns the value of the "revoked_reason" field in the mutation.
func (m *CertificateRequestMutation) RevokedReason() (r string, exists bool) {
	v := m.revoked_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedReason returns the old "revoked_reason" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldRevokedReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedReason: %w", err)
	}
	return oldValue.RevokedReason, nil
}

// ClearRevokedReason clears the value of the "revoked_reason" field.
func (m *CertificateRequestMutation) ClearRevokedReason() {
	m.revoked_reason = nil
	m.clearedFields[certificaterequest.FieldRevokedReason] = struct{}{}
}

// RevokedReasonCleared returns if the "revoked_reason" field was cleared in this mutation.
func (m *CertificateRequestMutation) RevokedReasonCleared() bool {
	_, ok := m.clearedFields[certificaterequest.FieldRevokedReason]
	return ok
}

// ResetRevokedReason resets all changes to the "revoked_reason" field.
func (m *CertificateRequestMutation) ResetRevokedReason() {
	m.revoked_reason = nil
	delete(m.clearedFields, certificaterequest.FieldRevokedReason)
}

// SetApprovedBy sets the "approved_by" field.
func (m *CertificateRequestMutation) SetApprovedBy(s string) {
	m.approved_by = &s
}

// ApprovedBy returns the value of the "approved_by" field in the mutation.
func (m *CertificateRequestMutation) ApprovedBy() (r string, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedBy returns the old "approved_by" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldApprovedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedBy: %w", err)
	}
	return oldValue.ApprovedBy, nil
}

// ClearApprovedBy clears the value of the "approved_by" field.
func (m *CertificateRequestMutation) ClearApprovedBy() {
	m.approved_by = nil
	m.clearedFields[certificaterequest.FieldApprovedBy] = struct{}{}
}

// ApprovedByCleared returns if the "approved_by" field was cleared in this mutation.
func (m *CertificateRequestMutation) ApprovedByCleared() bool {
	_, ok := m.clearedFields[certificaterequest.FieldApprovedBy]
	return ok
}

// ResetApprovedBy resets all changes to the "approved_by" field.
func (m *CertificateRequestMutation) ResetApprovedBy() {
	m.approved_by = nil
	delete(m.clearedFields, certificaterequest.FieldApprovedBy)
}

// SetApprovedAt sets the "approved_at" field.
func (m *CertificateRequestMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *CertificateRequestMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldApprovedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *CertificateRequestMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[certificaterequest.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *CertificateRequestMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[certificaterequest.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *CertificateRequestMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, certificaterequest.FieldApprovedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *CertificateRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CertificateRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CertificateRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CertificateRequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CertificateRequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CertificateRequest entity.
// If the CertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateRequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CertificateRequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIssuerID sets the "issuer" edge to the Issuer entity by id.
func (m *CertificateRequestMutation) SetIssuerID(id uint32) {
	m.issuer = &id
}

// ClearIssuer clears the "issuer" edge to the Issuer entity.
func (m *CertificateRequestMutation) ClearIssuer() {
	m.clearedissuer = true
}

// IssuerCleared reports if the "issuer" edge to the Issuer entity was cleared.
func (m *CertificateRequestMutation) IssuerCleared() bool {
	return m.clearedissuer
}

// IssuerID returns the "issuer" edge ID in the mutation.
func (m *CertificateRequestMutation) IssuerID() (id uint32, exists bool) {
	if m.issuer != nil {
		return *m.issuer, true
	}
	return
}

// IssuerIDs returns the "issuer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IssuerID instead. It exists only for internal usage by the builders.
func (m *CertificateRequestMutation) IssuerIDs() (ids []uint32) {
	if id := m.issuer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIssuer resets all changes to the "issuer" edge.
func (m *CertificateRequestMutation) ResetIssuer() {
	m.issuer = nil
	m.clearedissuer = false
}

// SetLcmClientID sets the "lcm_client" edge to the LcmClient entity by id.
func (m *CertificateRequestMutation) SetLcmClientID(id uint32) {
	m.lcm_client = &id
}

// ClearLcmClient clears the "lcm_client" edge to the LcmClient entity.
func (m *CertificateRequestMutation) ClearLcmClient() {
	m.clearedlcm_client = true
}

// LcmClientCleared reports if the "lcm_client" edge to the LcmClient entity was cleared.
func (m *CertificateRequestMutation) LcmClientCleared() bool {
	return m.clearedlcm_client
}

// LcmClientID returns the "lcm_client" edge ID in the mutation.
func (m *CertificateRequestMutation) LcmClientID() (id uint32, exists bool) {
	if m.lcm_client != nil {
		return *m.lcm_client, true
	}
	return
}

// LcmClientIDs returns the "lcm_client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LcmClientID instead. It exists only for internal usage by the builders.
func (m *CertificateRequestMutation) LcmClientIDs() (ids []uint32) {
	if id := m.lcm_client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLcmClient resets all changes to the "lcm_client" edge.
func (m *CertificateRequestMutation) ResetLcmClient() {
	m.lcm_client = nil
	m.clearedlcm_client = false
}

// Where appends a list predicates to the CertificateRequestMutation builder.
func (m *CertificateRequestMutation) Where(ps ...predicate.CertificateRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertificateRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertificateRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CertificateRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertificateRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertificateRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CertificateRequest).
func (m *CertificateRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertificateRequestMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.request_id != nil {
		fields = append(fields, certificaterequest.FieldRequestID)
	}
	if m.client_id != nil {
		fields = append(fields, certificaterequest.FieldClientID)
	}
	if m.issuer_name != nil {
		fields = append(fields, certificaterequest.FieldIssuerName)
	}
	if m.hostname != nil {
		fields = append(fields, certificaterequest.FieldHostname)
	}
	if m.public_key != nil {
		fields = append(fields, certificaterequest.FieldPublicKey)
	}
	if m.dns_names != nil {
		fields = append(fields, certificaterequest.FieldDNSNames)
	}
	if m.ip_addresses != nil {
		fields = append(fields, certificaterequest.FieldIPAddresses)
	}
	if m.metadata != nil {
		fields = append(fields, certificaterequest.FieldMetadata)
	}
	if m.status != nil {
		fields = append(fields, certificaterequest.FieldStatus)
	}
	if m.certificate != nil {
		fields = append(fields, certificaterequest.FieldCertificate)
	}
	if m.expires_at != nil {
		fields = append(fields, certificaterequest.FieldExpiresAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, certificaterequest.FieldRevokedAt)
	}
	if m.revoked_by != nil {
		fields = append(fields, certificaterequest.FieldRevokedBy)
	}
	if m.revoked_reason != nil {
		fields = append(fields, certificaterequest.FieldRevokedReason)
	}
	if m.approved_by != nil {
		fields = append(fields, certificaterequest.FieldApprovedBy)
	}
	if m.approved_at != nil {
		fields = append(fields, certificaterequest.FieldApprovedAt)
	}
	if m.created_at != nil {
		fields = append(fields, certificaterequest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, certificaterequest.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertificateRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certificaterequest.FieldRequestID:
		return m.RequestID()
	case certificaterequest.FieldClientID:
		return m.ClientID()
	case certificaterequest.FieldIssuerName:
		return m.IssuerName()
	case certificaterequest.FieldHostname:
		return m.Hostname()
	case certificaterequest.FieldPublicKey:
		return m.PublicKey()
	case certificaterequest.FieldDNSNames:
		return m.DNSNames()
	case certificaterequest.FieldIPAddresses:
		return m.IPAddresses()
	case certificaterequest.FieldMetadata:
		return m.Metadata()
	case certificaterequest.FieldStatus:
		return m.Status()
	case certificaterequest.FieldCertificate:
		return m.Certificate()
	case certificaterequest.FieldExpiresAt:
		return m.ExpiresAt()
	case certificaterequest.FieldRevokedAt:
		return m.RevokedAt()
	case certificaterequest.FieldRevokedBy:
		return m.RevokedBy()
	case certificaterequest.FieldRevokedReason:
		return m.RevokedReason()
	case certificaterequest.FieldApprovedBy:
		return m.ApprovedBy()
	case certificaterequest.FieldApprovedAt:
		return m.ApprovedAt()
	case certificaterequest.FieldCreatedAt:
		return m.CreatedAt()
	case certificaterequest.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertificateRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certificaterequest.FieldRequestID:
		return m.OldRequestID(ctx)
	case certificaterequest.FieldClientID:
		return m.OldClientID(ctx)
	case certificaterequest.FieldIssuerName:
		return m.OldIssuerName(ctx)
	case certificaterequest.FieldHostname:
		return m.OldHostname(ctx)
	case certificaterequest.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case certificaterequest.FieldDNSNames:
		return m.OldDNSNames(ctx)
	case certificaterequest.FieldIPAddresses:
		return m.OldIPAddresses(ctx)
	case certificaterequest.FieldMetadata:
		return m.OldMetadata(ctx)
	case certificaterequest.FieldStatus:
		return m.OldStatus(ctx)
	case certificaterequest.FieldCertificate:
		return m.OldCertificate(ctx)
	case certificaterequest.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case certificaterequest.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case certificaterequest.FieldRevokedBy:
		return m.OldRevokedBy(ctx)
	case certificaterequest.FieldRevokedReason:
		return m.OldRevokedReason(ctx)
	case certificaterequest.FieldApprovedBy:
		return m.OldApprovedBy(ctx)
	case certificaterequest.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case certificaterequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case certificaterequest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CertificateRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificateRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certificaterequest.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case certificaterequest.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case certificaterequest.FieldIssuerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerName(v)
		return nil
	case certificaterequest.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case certificaterequest.FieldPublicKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case certificaterequest.FieldDNSNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSNames(v)
		return nil
	case certificaterequest.FieldIPAddresses:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddresses(v)
		return nil
	case certificaterequest.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case certificaterequest.FieldStatus:
		v, ok := value.(certificaterequest.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case certificaterequest.FieldCertificate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificate(v)
		return nil
	case certificaterequest.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case certificaterequest.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case certificaterequest.FieldRevokedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedBy(v)
		return nil
	case certificaterequest.FieldRevokedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedReason(v)
		return nil
	case certificaterequest.FieldApprovedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedBy(v)
		return nil
	case certificaterequest.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case certificaterequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case certificaterequest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CertificateRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertificateRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertificateRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificateRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CertificateRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertificateRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certificaterequest.FieldClientID) {
		fields = append(fields, certificaterequest.FieldClientID)
	}
	if m.FieldCleared(certificaterequest.FieldIssuerName) {
		fields = append(fields, certificaterequest.FieldIssuerName)
	}
	if m.FieldCleared(certificaterequest.FieldDNSNames) {
		fields = append(fields, certificaterequest.FieldDNSNames)
	}
	if m.FieldCleared(certificaterequest.FieldIPAddresses) {
		fields = append(fields, certificaterequest.FieldIPAddresses)
	}
	if m.FieldCleared(certificaterequest.FieldMetadata) {
		fields = append(fields, certificaterequest.FieldMetadata)
	}
	if m.FieldCleared(certificaterequest.FieldCertificate) {
		fields = append(fields, certificaterequest.FieldCertificate)
	}
	if m.FieldCleared(certificaterequest.FieldExpiresAt) {
		fields = append(fields, certificaterequest.FieldExpiresAt)
	}
	if m.FieldCleared(certificaterequest.FieldRevokedAt) {
		fields = append(fields, certificaterequest.FieldRevokedAt)
	}
	if m.FieldCleared(certificaterequest.FieldRevokedBy) {
		fields = append(fields, certificaterequest.FieldRevokedBy)
	}
	if m.FieldCleared(certificaterequest.FieldRevokedReason) {
		fields = append(fields, certificaterequest.FieldRevokedReason)
	}
	if m.FieldCleared(certificaterequest.FieldApprovedBy) {
		fields = append(fields, certificaterequest.FieldApprovedBy)
	}
	if m.FieldCleared(certificaterequest.FieldApprovedAt) {
		fields = append(fields, certificaterequest.FieldApprovedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertificateRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificateRequestMutation) ClearField(name string) error {
	switch name {
	case certificaterequest.FieldClientID:
		m.ClearClientID()
		return nil
	case certificaterequest.FieldIssuerName:
		m.ClearIssuerName()
		return nil
	case certificaterequest.FieldDNSNames:
		m.ClearDNSNames()
		return nil
	case certificaterequest.FieldIPAddresses:
		m.ClearIPAddresses()
		return nil
	case certificaterequest.FieldMetadata:
		m.ClearMetadata()
		return nil
	case certificaterequest.FieldCertificate:
		m.ClearCertificate()
		return nil
	case certificaterequest.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case certificaterequest.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case certificaterequest.FieldRevokedBy:
		m.ClearRevokedBy()
		return nil
	case certificaterequest.FieldRevokedReason:
		m.ClearRevokedReason()
		return nil
	case certificaterequest.FieldApprovedBy:
		m.ClearApprovedBy()
		return nil
	case certificaterequest.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	}
	return fmt.Errorf("unknown CertificateRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertificateRequestMutation) ResetField(name string) error {
	switch name {
	case certificaterequest.FieldRequestID:
		m.ResetRequestID()
		return nil
	case certificaterequest.FieldClientID:
		m.ResetClientID()
		return nil
	case certificaterequest.FieldIssuerName:
		m.ResetIssuerName()
		return nil
	case certificaterequest.FieldHostname:
		m.ResetHostname()
		return nil
	case certificaterequest.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case certificaterequest.FieldDNSNames:
		m.ResetDNSNames()
		return nil
	case certificaterequest.FieldIPAddresses:
		m.ResetIPAddresses()
		return nil
	case certificaterequest.FieldMetadata:
		m.ResetMetadata()
		return nil
	case certificaterequest.FieldStatus:
		m.ResetStatus()
		return nil
	case certificaterequest.FieldCertificate:
		m.ResetCertificate()
		return nil
	case certificaterequest.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case certificaterequest.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case certificaterequest.FieldRevokedBy:
		m.ResetRevokedBy()
		return nil
	case certificaterequest.FieldRevokedReason:
		m.ResetRevokedReason()
		return nil
	case certificaterequest.FieldApprovedBy:
		m.ResetApprovedBy()
		return nil
	case certificaterequest.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case certificaterequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case certificaterequest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CertificateRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertificateRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.issuer != nil {
		edges = append(edges, certificaterequest.EdgeIssuer)
	}
	if m.lcm_client != nil {
		edges = append(edges, certificaterequest.EdgeLcmClient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertificateRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certificaterequest.EdgeIssuer:
		if id := m.issuer; id != nil {
			return []ent.Value{*id}
		}
	case certificaterequest.EdgeLcmClient:
		if id := m.lcm_client; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertificateRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertificateRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertificateRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedissuer {
		edges = append(edges, certificaterequest.EdgeIssuer)
	}
	if m.clearedlcm_client {
		edges = append(edges, certificaterequest.EdgeLcmClient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertificateRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case certificaterequest.EdgeIssuer:
		return m.clearedissuer
	case certificaterequest.EdgeLcmClient:
		return m.clearedlcm_client
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertificateRequestMutation) ClearEdge(name string) error {
	switch name {
	case certificaterequest.EdgeIssuer:
		m.ClearIssuer()
		return nil
	case certificaterequest.EdgeLcmClient:
		m.ClearLcmClient()
		return nil
	}
	return fmt.Errorf("unknown CertificateRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertificateRequestMutation) ResetEdge(name string) error {
	switch name {
	case certificaterequest.EdgeIssuer:
		m.ResetIssuer()
		return nil
	case certificaterequest.EdgeLcmClient:
		m.ResetLcmClient()
		return nil
	}
	return fmt.Errorf("unknown CertificateRequest edge %s", name)
}

// ClientIssuerMutation represents an operation that mutates the ClientIssuer nodes in the graph.
type ClientIssuerMutation struct {
	config
	op                Op
	typ               string
	id                *int
	client_id         *string
	issuer_name       *string
	is_default        *bool
	priority          *int
	addpriority       *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	issuer            *uint32
	clearedissuer     bool
	lcm_client        *uint32
	clearedlcm_client bool
	done              bool
	oldValue          func(context.Context) (*ClientIssuer, error)
	predicates        []predicate.ClientIssuer
}

var _ ent.Mutation = (*ClientIssuerMutation)(nil)

// clientissuerOption allows management of the mutation configuration using functional options.
type clientissuerOption func(*ClientIssuerMutation)

// newClientIssuerMutation creates new mutation for the ClientIssuer entity.
func newClientIssuerMutation(c config, op Op, opts ...clientissuerOption) *ClientIssuerMutation {
	m := &ClientIssuerMutation{
		config:        c,
		op:            op,
		typ:           TypeClientIssuer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClientIssuerID sets the ID field of the mutation.
func withClientIssuerID(id int) clientissuerOption {
	return func(m *ClientIssuerMutation) {
		var (
			err   error
			once  sync.Once
			value *ClientIssuer
		)
		m.oldValue = func(ctx context.Context) (*ClientIssuer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClientIssuer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClientIssuer sets the old ClientIssuer of the mutation.
func withClientIssuer(node *ClientIssuer) clientissuerOption {
	return func(m *ClientIssuerMutation) {
		m.oldValue = func(context.Context) (*ClientIssuer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClientIssuerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClientIssuerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClientIssuerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClientIssuerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClientIssuer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "client_id" field.
func (m *ClientIssuerMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *ClientIssuerMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the ClientIssuer entity.
// If the ClientIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientIssuerMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *ClientIssuerMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[clientissuer.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *ClientIssuerMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[clientissuer.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *ClientIssuerMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, clientissuer.FieldClientID)
}

// SetIssuerName sets the "issuer_name" field.
func (m *ClientIssuerMutation) SetIssuerName(s string) {
	m.issuer_name = &s
}

// IssuerName returns the value of the "issuer_name" field in the mutation.
func (m *ClientIssuerMutation) IssuerName() (r string, exists bool) {
	v := m.issuer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerName returns the old "issuer_name" field's value of the ClientIssuer entity.
// If the ClientIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientIssuerMutation) OldIssuerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerName: %w", err)
	}
	return oldValue.IssuerName, nil
}

// ResetIssuerName resets all changes to the "issuer_name" field.
func (m *ClientIssuerMutation) ResetIssuerName() {
	m.issuer_name = nil
}

// SetIsDefault sets the "is_default" field.
func (m *ClientIssuerMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *ClientIssuerMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the ClientIssuer entity.
// If the ClientIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientIssuerMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *ClientIssuerMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetPriority sets the "priority" field.
func (m *ClientIssuerMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ClientIssuerMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the ClientIssuer entity.
// If the ClientIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientIssuerMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *ClientIssuerMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *ClientIssuerMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *ClientIssuerMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ClientIssuerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClientIssuerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ClientIssuer entity.
// If the ClientIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientIssuerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClientIssuerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClientIssuerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClientIssuerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ClientIssuer entity.
// If the ClientIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientIssuerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClientIssuerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIssuerID sets the "issuer" edge to the Issuer entity by id.
func (m *ClientIssuerMutation) SetIssuerID(id uint32) {
	m.issuer = &id
}

// ClearIssuer clears the "issuer" edge to the Issuer entity.
func (m *ClientIssuerMutation) ClearIssuer() {
	m.clearedissuer = true
}

// IssuerCleared reports if the "issuer" edge to the Issuer entity was cleared.
func (m *ClientIssuerMutation) IssuerCleared() bool {
	return m.clearedissuer
}

// IssuerID returns the "issuer" edge ID in the mutation.
func (m *ClientIssuerMutation) IssuerID() (id uint32, exists bool) {
	if m.issuer != nil {
		return *m.issuer, true
	}
	return
}

// IssuerIDs returns the "issuer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IssuerID instead. It exists only for internal usage by the builders.
func (m *ClientIssuerMutation) IssuerIDs() (ids []uint32) {
	if id := m.issuer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIssuer resets all changes to the "issuer" edge.
func (m *ClientIssuerMutation) ResetIssuer() {
	m.issuer = nil
	m.clearedissuer = false
}

// SetLcmClientID sets the "lcm_client" edge to the LcmClient entity by id.
func (m *ClientIssuerMutation) SetLcmClientID(id uint32) {
	m.lcm_client = &id
}

// ClearLcmClient clears the "lcm_client" edge to the LcmClient entity.
func (m *ClientIssuerMutation) ClearLcmClient() {
	m.clearedlcm_client = true
}

// LcmClientCleared reports if the "lcm_client" edge to the LcmClient entity was cleared.
func (m *ClientIssuerMutation) LcmClientCleared() bool {
	return m.clearedlcm_client
}

// LcmClientID returns the "lcm_client" edge ID in the mutation.
func (m *ClientIssuerMutation) LcmClientID() (id uint32, exists bool) {
	if m.lcm_client != nil {
		return *m.lcm_client, true
	}
	return
}

// LcmClientIDs returns the "lcm_client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LcmClientID instead. It exists only for internal usage by the builders.
func (m *ClientIssuerMutation) LcmClientIDs() (ids []uint32) {
	if id := m.lcm_client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLcmClient resets all changes to the "lcm_client" edge.
func (m *ClientIssuerMutation) ResetLcmClient() {
	m.lcm_client = nil
	m.clearedlcm_client = false
}

// Where appends a list predicates to the ClientIssuerMutation builder.
func (m *ClientIssuerMutation) Where(ps ...predicate.ClientIssuer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClientIssuerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClientIssuerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ClientIssuer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClientIssuerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClientIssuerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ClientIssuer).
func (m *ClientIssuerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClientIssuerMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.client_id != nil {
		fields = append(fields, clientissuer.FieldClientID)
	}
	if m.issuer_name != nil {
		fields = append(fields, clientissuer.FieldIssuerName)
	}
	if m.is_default != nil {
		fields = append(fields, clientissuer.FieldIsDefault)
	}
	if m.priority != nil {
		fields = append(fields, clientissuer.FieldPriority)
	}
	if m.created_at != nil {
		fields = append(fields, clientissuer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, clientissuer.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClientIssuerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clientissuer.FieldClientID:
		return m.ClientID()
	case clientissuer.FieldIssuerName:
		return m.IssuerName()
	case clientissuer.FieldIsDefault:
		return m.IsDefault()
	case clientissuer.FieldPriority:
		return m.Priority()
	case clientissuer.FieldCreatedAt:
		return m.CreatedAt()
	case clientissuer.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClientIssuerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clientissuer.FieldClientID:
		return m.OldClientID(ctx)
	case clientissuer.FieldIssuerName:
		return m.OldIssuerName(ctx)
	case clientissuer.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case clientissuer.FieldPriority:
		return m.OldPriority(ctx)
	case clientissuer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case clientissuer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ClientIssuer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClientIssuerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clientissuer.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case clientissuer.FieldIssuerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerName(v)
		return nil
	case clientissuer.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case clientissuer.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case clientissuer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case clientissuer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ClientIssuer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClientIssuerMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, clientissuer.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClientIssuerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case clientissuer.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClientIssuerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case clientissuer.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown ClientIssuer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClientIssuerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(clientissuer.FieldClientID) {
		fields = append(fields, clientissuer.FieldClientID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClientIssuerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClientIssuerMutation) ClearField(name string) error {
	switch name {
	case clientissuer.FieldClientID:
		m.ClearClientID()
		return nil
	}
	return fmt.Errorf("unknown ClientIssuer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClientIssuerMutation) ResetField(name string) error {
	switch name {
	case clientissuer.FieldClientID:
		m.ResetClientID()
		return nil
	case clientissuer.FieldIssuerName:
		m.ResetIssuerName()
		return nil
	case clientissuer.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case clientissuer.FieldPriority:
		m.ResetPriority()
		return nil
	case clientissuer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case clientissuer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ClientIssuer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClientIssuerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.issuer != nil {
		edges = append(edges, clientissuer.EdgeIssuer)
	}
	if m.lcm_client != nil {
		edges = append(edges, clientissuer.EdgeLcmClient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClientIssuerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clientissuer.EdgeIssuer:
		if id := m.issuer; id != nil {
			return []ent.Value{*id}
		}
	case clientissuer.EdgeLcmClient:
		if id := m.lcm_client; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClientIssuerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClientIssuerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClientIssuerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedissuer {
		edges = append(edges, clientissuer.EdgeIssuer)
	}
	if m.clearedlcm_client {
		edges = append(edges, clientissuer.EdgeLcmClient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClientIssuerMutation) EdgeCleared(name string) bool {
	switch name {
	case clientissuer.EdgeIssuer:
		return m.clearedissuer
	case clientissuer.EdgeLcmClient:
		return m.clearedlcm_client
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClientIssuerMutation) ClearEdge(name string) error {
	switch name {
	case clientissuer.EdgeIssuer:
		m.ClearIssuer()
		return nil
	case clientissuer.EdgeLcmClient:
		m.ClearLcmClient()
		return nil
	}
	return fmt.Errorf("unknown ClientIssuer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClientIssuerMutation) ResetEdge(name string) error {
	switch name {
	case clientissuer.EdgeIssuer:
		m.ResetIssuer()
		return nil
	case clientissuer.EdgeLcmClient:
		m.ResetLcmClient()
		return nil
	}
	return fmt.Errorf("unknown ClientIssuer edge %s", name)
}

// IssuedCertificateMutation represents an operation that mutates the IssuedCertificate nodes in the graph.
type IssuedCertificateMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *string
	client_id                            *string
	issuer_name                          *string
	issuer_type                          *string
	tenant_id                            *uint32
	addtenant_id                         *int32
	common_name                          *string
	domains                              *[]string
	appenddomains                        []string
	ip_addresses                         *[]string
	appendip_addresses                   []string
	status                               *issuedcertificate.Status
	cert_pem                             *string
	private_key_pem                      *string
	server_generated_key                 *bool
	ca_cert_pem                          *string
	csr_pem                              *string
	certificate_fingerprint              *string
	error_message                        *string
	key_type                             *issuedcertificate.KeyType
	key_size                             *int32
	addkey_size                          *int32
	auto_renew_enabled                   *bool
	auto_renew_days_before_expiry        *int32
	addauto_renew_days_before_expiry     *int32
	auto_renew_max_attempts              *int32
	addauto_renew_max_attempts           *int32
	auto_renew_retry_interval_seconds    *int64
	addauto_renew_retry_interval_seconds *int64
	last_renewal_at                      *time.Time
	renewal_attempts                     *int32
	addrenewal_attempts                  *int32
	expires_at                           *time.Time
	revoked_at                           *time.Time
	revoked_reason                       *string
	created_at                           *time.Time
	updated_at                           *time.Time
	clearedFields                        map[string]struct{}
	lcm_client                           *uint32
	clearedlcm_client                    bool
	certificate_details                  *uint32
	clearedcertificate_details           bool
	permissions                          map[uint32]struct{}
	removedpermissions                   map[uint32]struct{}
	clearedpermissions                   bool
	done                                 bool
	oldValue                             func(context.Context) (*IssuedCertificate, error)
	predicates                           []predicate.IssuedCertificate
}

var _ ent.Mutation = (*IssuedCertificateMutation)(nil)

// issuedcertificateOption allows management of the mutation configuration using functional options.
type issuedcertificateOption func(*IssuedCertificateMutation)

// newIssuedCertificateMutation creates new mutation for the IssuedCertificate entity.
func newIssuedCertificateMutation(c config, op Op, opts ...issuedcertificateOption) *IssuedCertificateMutation {
	m := &IssuedCertificateMutation{
		config:        c,
		op:            op,
		typ:           TypeIssuedCertificate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIssuedCertificateID sets the ID field of the mutation.
func withIssuedCertificateID(id string) issuedcertificateOption {
	return func(m *IssuedCertificateMutation) {
		var (
			err   error
			once  sync.Once
			value *IssuedCertificate
		)
		m.oldValue = func(ctx context.Context) (*IssuedCertificate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IssuedCertificate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIssuedCertificate sets the old IssuedCertificate of the mutation.
func withIssuedCertificate(node *IssuedCertificate) issuedcertificateOption {
	return func(m *IssuedCertificateMutation) {
		m.oldValue = func(context.Context) (*IssuedCertificate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IssuedCertificateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IssuedCertificateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IssuedCertificate entities.
func (m *IssuedCertificateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IssuedCertificateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IssuedCertificateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IssuedCertificate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "client_id" field.
func (m *IssuedCertificateMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *IssuedCertificateMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *IssuedCertificateMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[issuedcertificate.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *IssuedCertificateMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *IssuedCertificateMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, issuedcertificate.FieldClientID)
}

// SetIssuerName sets the "issuer_name" field.
func (m *IssuedCertificateMutation) SetIssuerName(s string) {
	m.issuer_name = &s
}

// IssuerName returns the value of the "issuer_name" field in the mutation.
func (m *IssuedCertificateMutation) IssuerName() (r string, exists bool) {
	v := m.issuer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerName returns the old "issuer_name" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldIssuerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerName: %w", err)
	}
	return oldValue.IssuerName, nil
}

// ResetIssuerName resets all changes to the "issuer_name" field.
func (m *IssuedCertificateMutation) ResetIssuerName() {
	m.issuer_name = nil
}

// SetIssuerType sets the "issuer_type" field.
func (m *IssuedCertificateMutation) SetIssuerType(s string) {
	m.issuer_type = &s
}

// IssuerType returns the value of the "issuer_type" field in the mutation.
func (m *IssuedCertificateMutation) IssuerType() (r string, exists bool) {
	v := m.issuer_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerType returns the old "issuer_type" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldIssuerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerType: %w", err)
	}
	return oldValue.IssuerType, nil
}

// ClearIssuerType clears the value of the "issuer_type" field.
func (m *IssuedCertificateMutation) ClearIssuerType() {
	m.issuer_type = nil
	m.clearedFields[issuedcertificate.FieldIssuerType] = struct{}{}
}

// IssuerTypeCleared returns if the "issuer_type" field was cleared in this mutation.
func (m *IssuedCertificateMutation) IssuerTypeCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldIssuerType]
	return ok
}

// ResetIssuerType resets all changes to the "issuer_type" field.
func (m *IssuedCertificateMutation) ResetIssuerType() {
	m.issuer_type = nil
	delete(m.clearedFields, issuedcertificate.FieldIssuerType)
}

// SetTenantID sets the "tenant_id" field.
func (m *IssuedCertificateMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IssuedCertificateMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldTenantID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *IssuedCertificateMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *IssuedCertificateMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *IssuedCertificateMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[issuedcertificate.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *IssuedCertificateMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IssuedCertificateMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, issuedcertificate.FieldTenantID)
}

// SetCommonName sets the "common_name" field.
func (m *IssuedCertificateMutation) SetCommonName(s string) {
	m.common_name = &s
}

// CommonName returns the value of the "common_name" field in the mutation.
func (m *IssuedCertificateMutation) CommonName() (r string, exists bool) {
	v := m.common_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCommonName returns the old "common_name" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldCommonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommonName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommonName: %w", err)
	}
	return oldValue.CommonName, nil
}

// ClearCommonName clears the value of the "common_name" field.
func (m *IssuedCertificateMutation) ClearCommonName() {
	m.common_name = nil
	m.clearedFields[issuedcertificate.FieldCommonName] = struct{}{}
}

// CommonNameCleared returns if the "common_name" field was cleared in this mutation.
func (m *IssuedCertificateMutation) CommonNameCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldCommonName]
	return ok
}

// ResetCommonName resets all changes to the "common_name" field.
func (m *IssuedCertificateMutation) ResetCommonName() {
	m.common_name = nil
	delete(m.clearedFields, issuedcertificate.FieldCommonName)
}

// SetDomains sets the "domains" field.
func (m *IssuedCertificateMutation) SetDomains(s []string) {
	m.domains = &s
	m.appenddomains = nil
}

// Domains returns the value of the "domains" field in the mutation.
func (m *IssuedCertificateMutation) Domains() (r []string, exists bool) {
	v := m.domains
	if v == nil {
		return
	}
	return *v, true
}

// OldDomains returns the old "domains" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomains: %w", err)
	}
	return oldValue.Domains, nil
}

// AppendDomains adds s to the "domains" field.
func (m *IssuedCertificateMutation) AppendDomains(s []string) {
	m.appenddomains = append(m.appenddomains, s...)
}

// AppendedDomains returns the list of values that were appended to the "domains" field in this mutation.
func (m *IssuedCertificateMutation) AppendedDomains() ([]string, bool) {
	if len(m.appenddomains) == 0 {
		return nil, false
	}
	return m.appenddomains, true
}

// ResetDomains resets all changes to the "domains" field.
func (m *IssuedCertificateMutation) ResetDomains() {
	m.domains = nil
	m.appenddomains = nil
}

// SetIPAddresses sets the "ip_addresses" field.
func (m *IssuedCertificateMutation) SetIPAddresses(s []string) {
	m.ip_addresses = &s
	m.appendip_addresses = nil
}

// IPAddresses returns the value of the "ip_addresses" field in the mutation.
func (m *IssuedCertificateMutation) IPAddresses() (r []string, exists bool) {
	v := m.ip_addresses
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddresses returns the old "ip_addresses" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldIPAddresses(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddresses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddresses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddresses: %w", err)
	}
	return oldValue.IPAddresses, nil
}

// AppendIPAddresses adds s to the "ip_addresses" field.
func (m *IssuedCertificateMutation) AppendIPAddresses(s []string) {
	m.appendip_addresses = append(m.appendip_addresses, s...)
}

// AppendedIPAddresses returns the list of values that were appended to the "ip_addresses" field in this mutation.
func (m *IssuedCertificateMutation) AppendedIPAddresses() ([]string, bool) {
	if len(m.appendip_addresses) == 0 {
		return nil, false
	}
	return m.appendip_addresses, true
}

// ClearIPAddresses clears the value of the "ip_addresses" field.
func (m *IssuedCertificateMutation) ClearIPAddresses() {
	m.ip_addresses = nil
	m.appendip_addresses = nil
	m.clearedFields[issuedcertificate.FieldIPAddresses] = struct{}{}
}

// IPAddressesCleared returns if the "ip_addresses" field was cleared in this mutation.
func (m *IssuedCertificateMutation) IPAddressesCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldIPAddresses]
	return ok
}

// ResetIPAddresses resets all changes to the "ip_addresses" field.
func (m *IssuedCertificateMutation) ResetIPAddresses() {
	m.ip_addresses = nil
	m.appendip_addresses = nil
	delete(m.clearedFields, issuedcertificate.FieldIPAddresses)
}

// SetStatus sets the "status" field.
func (m *IssuedCertificateMutation) SetStatus(i issuedcertificate.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *IssuedCertificateMutation) Status() (r issuedcertificate.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldStatus(ctx context.Context) (v issuedcertificate.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IssuedCertificateMutation) ResetStatus() {
	m.status = nil
}

// SetCertPem sets the "cert_pem" field.
func (m *IssuedCertificateMutation) SetCertPem(s string) {
	m.cert_pem = &s
}

// CertPem returns the value of the "cert_pem" field in the mutation.
func (m *IssuedCertificateMutation) CertPem() (r string, exists bool) {
	v := m.cert_pem
	if v == nil {
		return
	}
	return *v, true
}

// OldCertPem returns the old "cert_pem" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldCertPem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertPem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertPem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertPem: %w", err)
	}
	return oldValue.CertPem, nil
}

// ClearCertPem clears the value of the "cert_pem" field.
func (m *IssuedCertificateMutation) ClearCertPem() {
	m.cert_pem = nil
	m.clearedFields[issuedcertificate.FieldCertPem] = struct{}{}
}

// CertPemCleared returns if the "cert_pem" field was cleared in this mutation.
func (m *IssuedCertificateMutation) CertPemCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldCertPem]
	return ok
}

// ResetCertPem resets all changes to the "cert_pem" field.
func (m *IssuedCertificateMutation) ResetCertPem() {
	m.cert_pem = nil
	delete(m.clearedFields, issuedcertificate.FieldCertPem)
}

// SetPrivateKeyPem sets the "private_key_pem" field.
func (m *IssuedCertificateMutation) SetPrivateKeyPem(s string) {
	m.private_key_pem = &s
}

// PrivateKeyPem returns the value of the "private_key_pem" field in the mutation.
func (m *IssuedCertificateMutation) PrivateKeyPem() (r string, exists bool) {
	v := m.private_key_pem
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKeyPem returns the old "private_key_pem" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldPrivateKeyPem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateKeyPem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateKeyPem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKeyPem: %w", err)
	}
	return oldValue.PrivateKeyPem, nil
}

// ClearPrivateKeyPem clears the value of the "private_key_pem" field.
func (m *IssuedCertificateMutation) ClearPrivateKeyPem() {
	m.private_key_pem = nil
	m.clearedFields[issuedcertificate.FieldPrivateKeyPem] = struct{}{}
}

// PrivateKeyPemCleared returns if the "private_key_pem" field was cleared in this mutation.
func (m *IssuedCertificateMutation) PrivateKeyPemCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldPrivateKeyPem]
	return ok
}

// ResetPrivateKeyPem resets all changes to the "private_key_pem" field.
func (m *IssuedCertificateMutation) ResetPrivateKeyPem() {
	m.private_key_pem = nil
	delete(m.clearedFields, issuedcertificate.FieldPrivateKeyPem)
}

// SetServerGeneratedKey sets the "server_generated_key" field.
func (m *IssuedCertificateMutation) SetServerGeneratedKey(b bool) {
	m.server_generated_key = &b
}

// ServerGeneratedKey returns the value of the "server_generated_key" field in the mutation.
func (m *IssuedCertificateMutation) ServerGeneratedKey() (r bool, exists bool) {
	v := m.server_generated_key
	if v == nil {
		return
	}
	return *v, true
}

// OldServerGeneratedKey returns the old "server_generated_key" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldServerGeneratedKey(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerGeneratedKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerGeneratedKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerGeneratedKey: %w", err)
	}
	return oldValue.ServerGeneratedKey, nil
}

// ResetServerGeneratedKey resets all changes to the "server_generated_key" field.
func (m *IssuedCertificateMutation) ResetServerGeneratedKey() {
	m.server_generated_key = nil
}

// SetCaCertPem sets the "ca_cert_pem" field.
func (m *IssuedCertificateMutation) SetCaCertPem(s string) {
	m.ca_cert_pem = &s
}

// CaCertPem returns the value of the "ca_cert_pem" field in the mutation.
func (m *IssuedCertificateMutation) CaCertPem() (r string, exists bool) {
	v := m.ca_cert_pem
	if v == nil {
		return
	}
	return *v, true
}

// OldCaCertPem returns the old "ca_cert_pem" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldCaCertPem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaCertPem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaCertPem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaCertPem: %w", err)
	}
	return oldValue.CaCertPem, nil
}

// ClearCaCertPem clears the value of the "ca_cert_pem" field.
func (m *IssuedCertificateMutation) ClearCaCertPem() {
	m.ca_cert_pem = nil
	m.clearedFields[issuedcertificate.FieldCaCertPem] = struct{}{}
}

// CaCertPemCleared returns if the "ca_cert_pem" field was cleared in this mutation.
func (m *IssuedCertificateMutation) CaCertPemCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldCaCertPem]
	return ok
}

// ResetCaCertPem resets all changes to the "ca_cert_pem" field.
func (m *IssuedCertificateMutation) ResetCaCertPem() {
	m.ca_cert_pem = nil
	delete(m.clearedFields, issuedcertificate.FieldCaCertPem)
}

// SetCsrPem sets the "csr_pem" field.
func (m *IssuedCertificateMutation) SetCsrPem(s string) {
	m.csr_pem = &s
}

// CsrPem returns the value of the "csr_pem" field in the mutation.
func (m *IssuedCertificateMutation) CsrPem() (r string, exists bool) {
	v := m.csr_pem
	if v == nil {
		return
	}
	return *v, true
}

// OldCsrPem returns the old "csr_pem" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldCsrPem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCsrPem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCsrPem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCsrPem: %w", err)
	}
	return oldValue.CsrPem, nil
}

// ClearCsrPem clears the value of the "csr_pem" field.
func (m *IssuedCertificateMutation) ClearCsrPem() {
	m.csr_pem = nil
	m.clearedFields[issuedcertificate.FieldCsrPem] = struct{}{}
}

// CsrPemCleared returns if the "csr_pem" field was cleared in this mutation.
func (m *IssuedCertificateMutation) CsrPemCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldCsrPem]
	return ok
}

// ResetCsrPem resets all changes to the "csr_pem" field.
func (m *IssuedCertificateMutation) ResetCsrPem() {
	m.csr_pem = nil
	delete(m.clearedFields, issuedcertificate.FieldCsrPem)
}

// SetCertificateFingerprint sets the "certificate_fingerprint" field.
func (m *IssuedCertificateMutation) SetCertificateFingerprint(s string) {
	m.certificate_fingerprint = &s
}

// CertificateFingerprint returns the value of the "certificate_fingerprint" field in the mutation.
func (m *IssuedCertificateMutation) CertificateFingerprint() (r string, exists bool) {
	v := m.certificate_fingerprint
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateFingerprint returns the old "certificate_fingerprint" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldCertificateFingerprint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateFingerprint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateFingerprint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateFingerprint: %w", err)
	}
	return oldValue.CertificateFingerprint, nil
}

// ClearCertificateFingerprint clears the value of the "certificate_fingerprint" field.
func (m *IssuedCertificateMutation) ClearCertificateFingerprint() {
	m.certificate_fingerprint = nil
	m.clearedFields[issuedcertificate.FieldCertificateFingerprint] = struct{}{}
}

// CertificateFingerprintCleared returns if the "certificate_fingerprint" field was cleared in this mutation.
func (m *IssuedCertificateMutation) CertificateFingerprintCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldCertificateFingerprint]
	return ok
}

// ResetCertificateFingerprint resets all changes to the "certificate_fingerprint" field.
func (m *IssuedCertificateMutation) ResetCertificateFingerprint() {
	m.certificate_fingerprint = nil
	delete(m.clearedFields, issuedcertificate.FieldCertificateFingerprint)
}

// SetErrorMessage sets the "error_message" field.
func (m *IssuedCertificateMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *IssuedCertificateMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *IssuedCertificateMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[issuedcertificate.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *IssuedCertificateMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *IssuedCertificateMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, issuedcertificate.FieldErrorMessage)
}

// SetKeyType sets the "key_type" field.
func (m *IssuedCertificateMutation) SetKeyType(it issuedcertificate.KeyType) {
	m.key_type = &it
}

// KeyType returns the value of the "key_type" field in the mutation.
func (m *IssuedCertificateMutation) KeyType() (r issuedcertificate.KeyType, exists bool) {
	v := m.key_type
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyType returns the old "key_type" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldKeyType(ctx context.Context) (v issuedcertificate.KeyType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyType: %w", err)
	}
	return oldValue.KeyType, nil
}

// ClearKeyType clears the value of the "key_type" field.
func (m *IssuedCertificateMutation) ClearKeyType() {
	m.key_type = nil
	m.clearedFields[issuedcertificate.FieldKeyType] = struct{}{}
}

// KeyTypeCleared returns if the "key_type" field was cleared in this mutation.
func (m *IssuedCertificateMutation) KeyTypeCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldKeyType]
	return ok
}

// ResetKeyType resets all changes to the "key_type" field.
func (m *IssuedCertificateMutation) ResetKeyType() {
	m.key_type = nil
	delete(m.clearedFields, issuedcertificate.FieldKeyType)
}

// SetKeySize sets the "key_size" field.
func (m *IssuedCertificateMutation) SetKeySize(i int32) {
	m.key_size = &i
	m.addkey_size = nil
}

// KeySize returns the value of the "key_size" field in the mutation.
func (m *IssuedCertificateMutation) KeySize() (r int32, exists bool) {
	v := m.key_size
	if v == nil {
		return
	}
	return *v, true
}

// OldKeySize returns the old "key_size" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldKeySize(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeySize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeySize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeySize: %w", err)
	}
	return oldValue.KeySize, nil
}

// AddKeySize adds i to the "key_size" field.
func (m *IssuedCertificateMutation) AddKeySize(i int32) {
	if m.addkey_size != nil {
		*m.addkey_size += i
	} else {
		m.addkey_size = &i
	}
}

// AddedKeySize returns the value that was added to the "key_size" field in this mutation.
func (m *IssuedCertificateMutation) AddedKeySize() (r int32, exists bool) {
	v := m.addkey_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearKeySize clears the value of the "key_size" field.
func (m *IssuedCertificateMutation) ClearKeySize() {
	m.key_size = nil
	m.addkey_size = nil
	m.clearedFields[issuedcertificate.FieldKeySize] = struct{}{}
}

// KeySizeCleared returns if the "key_size" field was cleared in this mutation.
func (m *IssuedCertificateMutation) KeySizeCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldKeySize]
	return ok
}

// ResetKeySize resets all changes to the "key_size" field.
func (m *IssuedCertificateMutation) ResetKeySize() {
	m.key_size = nil
	m.addkey_size = nil
	delete(m.clearedFields, issuedcertificate.FieldKeySize)
}

// SetAutoRenewEnabled sets the "auto_renew_enabled" field.
func (m *IssuedCertificateMutation) SetAutoRenewEnabled(b bool) {
	m.auto_renew_enabled = &b
}

// AutoRenewEnabled returns the value of the "auto_renew_enabled" field in the mutation.
func (m *IssuedCertificateMutation) AutoRenewEnabled() (r bool, exists bool) {
	v := m.auto_renew_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoRenewEnabled returns the old "auto_renew_enabled" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldAutoRenewEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoRenewEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoRenewEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoRenewEnabled: %w", err)
	}
	return oldValue.AutoRenewEnabled, nil
}

// ResetAutoRenewEnabled resets all changes to the "auto_renew_enabled" field.
func (m *IssuedCertificateMutation) ResetAutoRenewEnabled() {
	m.auto_renew_enabled = nil
}

// SetAutoRenewDaysBeforeExpiry sets the "auto_renew_days_before_expiry" field.
func (m *IssuedCertificateMutation) SetAutoRenewDaysBeforeExpiry(i int32) {
	m.auto_renew_days_before_expiry = &i
	m.addauto_renew_days_before_expiry = nil
}

// AutoRenewDaysBeforeExpiry returns the value of the "auto_renew_days_before_expiry" field in the mutation.
func (m *IssuedCertificateMutation) AutoRenewDaysBeforeExpiry() (r int32, exists bool) {
	v := m.auto_renew_days_before_expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoRenewDaysBeforeExpiry returns the old "auto_renew_days_before_expiry" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldAutoRenewDaysBeforeExpiry(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoRenewDaysBeforeExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoRenewDaysBeforeExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoRenewDaysBeforeExpiry: %w", err)
	}
	return oldValue.AutoRenewDaysBeforeExpiry, nil
}

// AddAutoRenewDaysBeforeExpiry adds i to the "auto_renew_days_before_expiry" field.
func (m *IssuedCertificateMutation) AddAutoRenewDaysBeforeExpiry(i int32) {
	if m.addauto_renew_days_before_expiry != nil {
		*m.addauto_renew_days_before_expiry += i
	} else {
		m.addauto_renew_days_before_expiry = &i
	}
}

// AddedAutoRenewDaysBeforeExpiry returns the value that was added to the "auto_renew_days_before_expiry" field in this mutation.
func (m *IssuedCertificateMutation) AddedAutoRenewDaysBeforeExpiry() (r int32, exists bool) {
	v := m.addauto_renew_days_before_expiry
	if v == nil {
		return
	}
	return *v, true
}

// ClearAutoRenewDaysBeforeExpiry clears the value of the "auto_renew_days_before_expiry" field.
func (m *IssuedCertificateMutation) ClearAutoRenewDaysBeforeExpiry() {
	m.auto_renew_days_before_expiry = nil
	m.addauto_renew_days_before_expiry = nil
	m.clearedFields[issuedcertificate.FieldAutoRenewDaysBeforeExpiry] = struct{}{}
}

// AutoRenewDaysBeforeExpiryCleared returns if the "auto_renew_days_before_expiry" field was cleared in this mutation.
func (m *IssuedCertificateMutation) AutoRenewDaysBeforeExpiryCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldAutoRenewDaysBeforeExpiry]
	return ok
}

// ResetAutoRenewDaysBeforeExpiry resets all changes to the "auto_renew_days_before_expiry" field.
func (m *IssuedCertificateMutation) ResetAutoRenewDaysBeforeExpiry() {
	m.auto_renew_days_before_expiry = nil
	m.addauto_renew_days_before_expiry = nil
	delete(m.clearedFields, issuedcertificate.FieldAutoRenewDaysBeforeExpiry)
}

// SetAutoRenewMaxAttempts sets the "auto_renew_max_attempts" field.
func (m *IssuedCertificateMutation) SetAutoRenewMaxAttempts(i int32) {
	m.auto_renew_max_attempts = &i
	m.addauto_renew_max_attempts = nil
}

// AutoRenewMaxAttempts returns the value of the "auto_renew_max_attempts" field in the mutation.
func (m *IssuedCertificateMutation) AutoRenewMaxAttempts() (r int32, exists bool) {
	v := m.auto_renew_max_attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoRenewMaxAttempts returns the old "auto_renew_max_attempts" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldAutoRenewMaxAttempts(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoRenewMaxAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoRenewMaxAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoRenewMaxAttempts: %w", err)
	}
	return oldValue.AutoRenewMaxAttempts, nil
}

// AddAutoRenewMaxAttempts adds i to the "auto_renew_max_attempts" field.
func (m *IssuedCertificateMutation) AddAutoRenewMaxAttempts(i int32) {
	if m.addauto_renew_max_attempts != nil {
		*m.addauto_renew_max_attempts += i
	} else {
		m.addauto_renew_max_attempts = &i
	}
}

// AddedAutoRenewMaxAttempts returns the value that was added to the "auto_renew_max_attempts" field in this mutation.
func (m *IssuedCertificateMutation) AddedAutoRenewMaxAttempts() (r int32, exists bool) {
	v := m.addauto_renew_max_attempts
	if v == nil {
		return
	}
	return *v, true
}

// ClearAutoRenewMaxAttempts clears the value of the "auto_renew_max_attempts" field.
func (m *IssuedCertificateMutation) ClearAutoRenewMaxAttempts() {
	m.auto_renew_max_attempts = nil
	m.addauto_renew_max_attempts = nil
	m.clearedFields[issuedcertificate.FieldAutoRenewMaxAttempts] = struct{}{}
}

// AutoRenewMaxAttemptsCleared returns if the "auto_renew_max_attempts" field was cleared in this mutation.
func (m *IssuedCertificateMutation) AutoRenewMaxAttemptsCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldAutoRenewMaxAttempts]
	return ok
}

// ResetAutoRenewMaxAttempts resets all changes to the "auto_renew_max_attempts" field.
func (m *IssuedCertificateMutation) ResetAutoRenewMaxAttempts() {
	m.auto_renew_max_attempts = nil
	m.addauto_renew_max_attempts = nil
	delete(m.clearedFields, issuedcertificate.FieldAutoRenewMaxAttempts)
}

// SetAutoRenewRetryIntervalSeconds sets the "auto_renew_retry_interval_seconds" field.
func (m *IssuedCertificateMutation) SetAutoRenewRetryIntervalSeconds(i int64) {
	m.auto_renew_retry_interval_seconds = &i
	m.addauto_renew_retry_interval_seconds = nil
}

// AutoRenewRetryIntervalSeconds returns the value of the "auto_renew_retry_interval_seconds" field in the mutation.
func (m *IssuedCertificateMutation) AutoRenewRetryIntervalSeconds() (r int64, exists bool) {
	v := m.auto_renew_retry_interval_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoRenewRetryIntervalSeconds returns the old "auto_renew_retry_interval_seconds" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldAutoRenewRetryIntervalSeconds(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoRenewRetryIntervalSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoRenewRetryIntervalSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoRenewRetryIntervalSeconds: %w", err)
	}
	return oldValue.AutoRenewRetryIntervalSeconds, nil
}

// AddAutoRenewRetryIntervalSeconds adds i to the "auto_renew_retry_interval_seconds" field.
func (m *IssuedCertificateMutation) AddAutoRenewRetryIntervalSeconds(i int64) {
	if m.addauto_renew_retry_interval_seconds != nil {
		*m.addauto_renew_retry_interval_seconds += i
	} else {
		m.addauto_renew_retry_interval_seconds = &i
	}
}

// AddedAutoRenewRetryIntervalSeconds returns the value that was added to the "auto_renew_retry_interval_seconds" field in this mutation.
func (m *IssuedCertificateMutation) AddedAutoRenewRetryIntervalSeconds() (r int64, exists bool) {
	v := m.addauto_renew_retry_interval_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearAutoRenewRetryIntervalSeconds clears the value of the "auto_renew_retry_interval_seconds" field.
func (m *IssuedCertificateMutation) ClearAutoRenewRetryIntervalSeconds() {
	m.auto_renew_retry_interval_seconds = nil
	m.addauto_renew_retry_interval_seconds = nil
	m.clearedFields[issuedcertificate.FieldAutoRenewRetryIntervalSeconds] = struct{}{}
}

// AutoRenewRetryIntervalSecondsCleared returns if the "auto_renew_retry_interval_seconds" field was cleared in this mutation.
func (m *IssuedCertificateMutation) AutoRenewRetryIntervalSecondsCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldAutoRenewRetryIntervalSeconds]
	return ok
}

// ResetAutoRenewRetryIntervalSeconds resets all changes to the "auto_renew_retry_interval_seconds" field.
func (m *IssuedCertificateMutation) ResetAutoRenewRetryIntervalSeconds() {
	m.auto_renew_retry_interval_seconds = nil
	m.addauto_renew_retry_interval_seconds = nil
	delete(m.clearedFields, issuedcertificate.FieldAutoRenewRetryIntervalSeconds)
}

// SetLastRenewalAt sets the "last_renewal_at" field.
func (m *IssuedCertificateMutation) SetLastRenewalAt(t time.Time) {
	m.last_renewal_at = &t
}

// LastRenewalAt returns the value of the "last_renewal_at" field in the mutation.
func (m *IssuedCertificateMutation) LastRenewalAt() (r time.Time, exists bool) {
	v := m.last_renewal_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRenewalAt returns the old "last_renewal_at" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldLastRenewalAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRenewalAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRenewalAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRenewalAt: %w", err)
	}
	return oldValue.LastRenewalAt, nil
}

// ClearLastRenewalAt clears the value of the "last_renewal_at" field.
func (m *IssuedCertificateMutation) ClearLastRenewalAt() {
	m.last_renewal_at = nil
	m.clearedFields[issuedcertificate.FieldLastRenewalAt] = struct{}{}
}

// LastRenewalAtCleared returns if the "last_renewal_at" field was cleared in this mutation.
func (m *IssuedCertificateMutation) LastRenewalAtCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldLastRenewalAt]
	return ok
}

// ResetLastRenewalAt resets all changes to the "last_renewal_at" field.
func (m *IssuedCertificateMutation) ResetLastRenewalAt() {
	m.last_renewal_at = nil
	delete(m.clearedFields, issuedcertificate.FieldLastRenewalAt)
}

// SetRenewalAttempts sets the "renewal_attempts" field.
func (m *IssuedCertificateMutation) SetRenewalAttempts(i int32) {
	m.renewal_attempts = &i
	m.addrenewal_attempts = nil
}

// RenewalAttempts returns the value of the "renewal_attempts" field in the mutation.
func (m *IssuedCertificateMutation) RenewalAttempts() (r int32, exists bool) {
	v := m.renewal_attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldRenewalAttempts returns the old "renewal_attempts" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldRenewalAttempts(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenewalAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenewalAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenewalAttempts: %w", err)
	}
	return oldValue.RenewalAttempts, nil
}

// AddRenewalAttempts adds i to the "renewal_attempts" field.
func (m *IssuedCertificateMutation) AddRenewalAttempts(i int32) {
	if m.addrenewal_attempts != nil {
		*m.addrenewal_attempts += i
	} else {
		m.addrenewal_attempts = &i
	}
}

// AddedRenewalAttempts returns the value that was added to the "renewal_attempts" field in this mutation.
func (m *IssuedCertificateMutation) AddedRenewalAttempts() (r int32, exists bool) {
	v := m.addrenewal_attempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetRenewalAttempts resets all changes to the "renewal_attempts" field.
func (m *IssuedCertificateMutation) ResetRenewalAttempts() {
	m.renewal_attempts = nil
	m.addrenewal_attempts = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *IssuedCertificateMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *IssuedCertificateMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *IssuedCertificateMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[issuedcertificate.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *IssuedCertificateMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *IssuedCertificateMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, issuedcertificate.FieldExpiresAt)
}

// SetRevokedAt sets the "revoked_at" field.
func (m *IssuedCertificateMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *IssuedCertificateMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldRevokedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *IssuedCertificateMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[issuedcertificate.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *IssuedCertificateMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *IssuedCertificateMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, issuedcertificate.FieldRevokedAt)
}

// SetRevokedReason sets the "revoked_reason" field.
func (m *IssuedCertificateMutation) SetRevokedReason(s string) {
	m.revoked_reason = &s
}

// RevokedReason returns the value of the "revoked_reason" field in the mutation.
func (m *IssuedCertificateMutation) RevokedReason() (r string, exists bool) {
	v := m.revoked_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedReason returns the old "revoked_reason" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldRevokedReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedReason: %w", err)
	}
	return oldValue.RevokedReason, nil
}

// ClearRevokedReason clears the value of the "revoked_reason" field.
func (m *IssuedCertificateMutation) ClearRevokedReason() {
	m.revoked_reason = nil
	m.clearedFields[issuedcertificate.FieldRevokedReason] = struct{}{}
}

// RevokedReasonCleared returns if the "revoked_reason" field was cleared in this mutation.
func (m *IssuedCertificateMutation) RevokedReasonCleared() bool {
	_, ok := m.clearedFields[issuedcertificate.FieldRevokedReason]
	return ok
}

// ResetRevokedReason resets all changes to the "revoked_reason" field.
func (m *IssuedCertificateMutation) ResetRevokedReason() {
	m.revoked_reason = nil
	delete(m.clearedFields, issuedcertificate.FieldRevokedReason)
}

// SetCreatedAt sets the "created_at" field.
func (m *IssuedCertificateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IssuedCertificateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IssuedCertificateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IssuedCertificateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IssuedCertificateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IssuedCertificate entity.
// If the IssuedCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuedCertificateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IssuedCertificateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLcmClientID sets the "lcm_client" edge to the LcmClient entity by id.
func (m *IssuedCertificateMutation) SetLcmClientID(id uint32) {
	m.lcm_client = &id
}

// ClearLcmClient clears the "lcm_client" edge to the LcmClient entity.
func (m *IssuedCertificateMutation) ClearLcmClient() {
	m.clearedlcm_client = true
}

// LcmClientCleared reports if the "lcm_client" edge to the LcmClient entity was cleared.
func (m *IssuedCertificateMutation) LcmClientCleared() bool {
	return m.clearedlcm_client
}

// LcmClientID returns the "lcm_client" edge ID in the mutation.
func (m *IssuedCertificateMutation) LcmClientID() (id uint32, exists bool) {
	if m.lcm_client != nil {
		return *m.lcm_client, true
	}
	return
}

// LcmClientIDs returns the "lcm_client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LcmClientID instead. It exists only for internal usage by the builders.
func (m *IssuedCertificateMutation) LcmClientIDs() (ids []uint32) {
	if id := m.lcm_client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLcmClient resets all changes to the "lcm_client" edge.
func (m *IssuedCertificateMutation) ResetLcmClient() {
	m.lcm_client = nil
	m.clearedlcm_client = false
}

// SetCertificateDetailsID sets the "certificate_details" edge to the CertificateDetails entity by id.
func (m *IssuedCertificateMutation) SetCertificateDetailsID(id uint32) {
	m.certificate_details = &id
}

// ClearCertificateDetails clears the "certificate_details" edge to the CertificateDetails entity.
func (m *IssuedCertificateMutation) ClearCertificateDetails() {
	m.clearedcertificate_details = true
}

// CertificateDetailsCleared reports if the "certificate_details" edge to the CertificateDetails entity was cleared.
func (m *IssuedCertificateMutation) CertificateDetailsCleared() bool {
	return m.clearedcertificate_details
}

// CertificateDetailsID returns the "certificate_details" edge ID in the mutation.
func (m *IssuedCertificateMutation) CertificateDetailsID() (id uint32, exists bool) {
	if m.certificate_details != nil {
		return *m.certificate_details, true
	}
	return
}

// CertificateDetailsIDs returns the "certificate_details" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CertificateDetailsID instead. It exists only for internal usage by the builders.
func (m *IssuedCertificateMutation) CertificateDetailsIDs() (ids []uint32) {
	if id := m.certificate_details; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCertificateDetails resets all changes to the "certificate_details" edge.
func (m *IssuedCertificateMutation) ResetCertificateDetails() {
	m.certificate_details = nil
	m.clearedcertificate_details = false
}

// AddPermissionIDs adds the "permissions" edge to the CertificatePermission entity by ids.
func (m *IssuedCertificateMutation) AddPermissionIDs(ids ...uint32) {
	if m.permissions == nil {
		m.permissions = make(map[uint32]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the CertificatePermission entity.
func (m *IssuedCertificateMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the CertificatePermission entity was cleared.
func (m *IssuedCertificateMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the CertificatePermission entity by IDs.
func (m *IssuedCertificateMutation) RemovePermissionIDs(ids ...uint32) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the CertificatePermission entity.
func (m *IssuedCertificateMutation) RemovedPermissionsIDs() (ids []uint32) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *IssuedCertificateMutation) PermissionsIDs() (ids []uint32) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *IssuedCertificateMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// Where appends a list predicates to the IssuedCertificateMutation builder.
func (m *IssuedCertificateMutation) Where(ps ...predicate.IssuedCertificate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IssuedCertificateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IssuedCertificateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IssuedCertificate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IssuedCertificateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IssuedCertificateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IssuedCertificate).
func (m *IssuedCertificateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IssuedCertificateMutation) Fields() []string {
	fields := make([]string, 0, 28)
	if m.client_id != nil {
		fields = append(fields, issuedcertificate.FieldClientID)
	}
	if m.issuer_name != nil {
		fields = append(fields, issuedcertificate.FieldIssuerName)
	}
	if m.issuer_type != nil {
		fields = append(fields, issuedcertificate.FieldIssuerType)
	}
	if m.tenant_id != nil {
		fields = append(fields, issuedcertificate.FieldTenantID)
	}
	if m.common_name != nil {
		fields = append(fields, issuedcertificate.FieldCommonName)
	}
	if m.domains != nil {
		fields = append(fields, issuedcertificate.FieldDomains)
	}
	if m.ip_addresses != nil {
		fields = append(fields, issuedcertificate.FieldIPAddresses)
	}
	if m.status != nil {
		fields = append(fields, issuedcertificate.FieldStatus)
	}
	if m.cert_pem != nil {
		fields = append(fields, issuedcertificate.FieldCertPem)
	}
	if m.private_key_pem != nil {
		fields = append(fields, issuedcertificate.FieldPrivateKeyPem)
	}
	if m.server_generated_key != nil {
		fields = append(fields, issuedcertificate.FieldServerGeneratedKey)
	}
	if m.ca_cert_pem != nil {
		fields = append(fields, issuedcertificate.FieldCaCertPem)
	}
	if m.csr_pem != nil {
		fields = append(fields, issuedcertificate.FieldCsrPem)
	}
	if m.certificate_fingerprint != nil {
		fields = append(fields, issuedcertificate.FieldCertificateFingerprint)
	}
	if m.error_message != nil {
		fields = append(fields, issuedcertificate.FieldErrorMessage)
	}
	if m.key_type != nil {
		fields = append(fields, issuedcertificate.FieldKeyType)
	}
	if m.key_size != nil {
		fields = append(fields, issuedcertificate.FieldKeySize)
	}
	if m.auto_renew_enabled != nil {
		fields = append(fields, issuedcertificate.FieldAutoRenewEnabled)
	}
	if m.auto_renew_days_before_expiry != nil {
		fields = append(fields, issuedcertificate.FieldAutoRenewDaysBeforeExpiry)
	}
	if m.auto_renew_max_attempts != nil {
		fields = append(fields, issuedcertificate.FieldAutoRenewMaxAttempts)
	}
	if m.auto_renew_retry_interval_seconds != nil {
		fields = append(fields, issuedcertificate.FieldAutoRenewRetryIntervalSeconds)
	}
	if m.last_renewal_at != nil {
		fields = append(fields, issuedcertificate.FieldLastRenewalAt)
	}
	if m.renewal_attempts != nil {
		fields = append(fields, issuedcertificate.FieldRenewalAttempts)
	}
	if m.expires_at != nil {
		fields = append(fields, issuedcertificate.FieldExpiresAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, issuedcertificate.FieldRevokedAt)
	}
	if m.revoked_reason != nil {
		fields = append(fields, issuedcertificate.FieldRevokedReason)
	}
	if m.created_at != nil {
		fields = append(fields, issuedcertificate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, issuedcertificate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IssuedCertificateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case issuedcertificate.FieldClientID:
		return m.ClientID()
	case issuedcertificate.FieldIssuerName:
		return m.IssuerName()
	case issuedcertificate.FieldIssuerType:
		return m.IssuerType()
	case issuedcertificate.FieldTenantID:
		return m.TenantID()
	case issuedcertificate.FieldCommonName:
		return m.CommonName()
	case issuedcertificate.FieldDomains:
		return m.Domains()
	case issuedcertificate.FieldIPAddresses:
		return m.IPAddresses()
	case issuedcertificate.FieldStatus:
		return m.Status()
	case issuedcertificate.FieldCertPem:
		return m.CertPem()
	case issuedcertificate.FieldPrivateKeyPem:
		return m.PrivateKeyPem()
	case issuedcertificate.FieldServerGeneratedKey:
		return m.ServerGeneratedKey()
	case issuedcertificate.FieldCaCertPem:
		return m.CaCertPem()
	case issuedcertificate.FieldCsrPem:
		return m.CsrPem()
	case issuedcertificate.FieldCertificateFingerprint:
		return m.CertificateFingerprint()
	case issuedcertificate.FieldErrorMessage:
		return m.ErrorMessage()
	case issuedcertificate.FieldKeyType:
		return m.KeyType()
	case issuedcertificate.FieldKeySize:
		return m.KeySize()
	case issuedcertificate.FieldAutoRenewEnabled:
		return m.AutoRenewEnabled()
	case issuedcertificate.FieldAutoRenewDaysBeforeExpiry:
		return m.AutoRenewDaysBeforeExpiry()
	case issuedcertificate.FieldAutoRenewMaxAttempts:
		return m.AutoRenewMaxAttempts()
	case issuedcertificate.FieldAutoRenewRetryIntervalSeconds:
		return m.AutoRenewRetryIntervalSeconds()
	case issuedcertificate.FieldLastRenewalAt:
		return m.LastRenewalAt()
	case issuedcertificate.FieldRenewalAttempts:
		return m.RenewalAttempts()
	case issuedcertificate.FieldExpiresAt:
		return m.ExpiresAt()
	case issuedcertificate.FieldRevokedAt:
		return m.RevokedAt()
	case issuedcertificate.FieldRevokedReason:
		return m.RevokedReason()
	case issuedcertificate.FieldCreatedAt:
		return m.CreatedAt()
	case issuedcertificate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IssuedCertificateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case issuedcertificate.FieldClientID:
		return m.OldClientID(ctx)
	case issuedcertificate.FieldIssuerName:
		return m.OldIssuerName(ctx)
	case issuedcertificate.FieldIssuerType:
		return m.OldIssuerType(ctx)
	case issuedcertificate.FieldTenantID:
		return m.OldTenantID(ctx)
	case issuedcertificate.FieldCommonName:
		return m.OldCommonName(ctx)
	case issuedcertificate.FieldDomains:
		return m.OldDomains(ctx)
	case issuedcertificate.FieldIPAddresses:
		return m.OldIPAddresses(ctx)
	case issuedcertificate.FieldStatus:
		return m.OldStatus(ctx)
	case issuedcertificate.FieldCertPem:
		return m.OldCertPem(ctx)
	case issuedcertificate.FieldPrivateKeyPem:
		return m.OldPrivateKeyPem(ctx)
	case issuedcertificate.FieldServerGeneratedKey:
		return m.OldServerGeneratedKey(ctx)
	case issuedcertificate.FieldCaCertPem:
		return m.OldCaCertPem(ctx)
	case issuedcertificate.FieldCsrPem:
		return m.OldCsrPem(ctx)
	case issuedcertificate.FieldCertificateFingerprint:
		return m.OldCertificateFingerprint(ctx)
	case issuedcertificate.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case issuedcertificate.FieldKeyType:
		return m.OldKeyType(ctx)
	case issuedcertificate.FieldKeySize:
		return m.OldKeySize(ctx)
	case issuedcertificate.FieldAutoRenewEnabled:
		return m.OldAutoRenewEnabled(ctx)
	case issuedcertificate.FieldAutoRenewDaysBeforeExpiry:
		return m.OldAutoRenewDaysBeforeExpiry(ctx)
	case issuedcertificate.FieldAutoRenewMaxAttempts:
		return m.OldAutoRenewMaxAttempts(ctx)
	case issuedcertificate.FieldAutoRenewRetryIntervalSeconds:
		return m.OldAutoRenewRetryIntervalSeconds(ctx)
	case issuedcertificate.FieldLastRenewalAt:
		return m.OldLastRenewalAt(ctx)
	case issuedcertificate.FieldRenewalAttempts:
		return m.OldRenewalAttempts(ctx)
	case issuedcertificate.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case issuedcertificate.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case issuedcertificate.FieldRevokedReason:
		return m.OldRevokedReason(ctx)
	case issuedcertificate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case issuedcertificate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IssuedCertificate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssuedCertificateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case issuedcertificate.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case issuedcertificate.FieldIssuerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerName(v)
		return nil
	case issuedcertificate.FieldIssuerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerType(v)
		return nil
	case issuedcertificate.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case issuedcertificate.FieldCommonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommonName(v)
		return nil
	case issuedcertificate.FieldDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomains(v)
		return nil
	case issuedcertificate.FieldIPAddresses:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddresses(v)
		return nil
	case issuedcertificate.FieldStatus:
		v, ok := value.(issuedcertificate.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case issuedcertificate.FieldCertPem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertPem(v)
		return nil
	case issuedcertificate.FieldPrivateKeyPem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKeyPem(v)
		return nil
	case issuedcertificate.FieldServerGeneratedKey:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerGeneratedKey(v)
		return nil
	case issuedcertificate.FieldCaCertPem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaCertPem(v)
		return nil
	case issuedcertificate.FieldCsrPem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCsrPem(v)
		return nil
	case issuedcertificate.FieldCertificateFingerprint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateFingerprint(v)
		return nil
	case issuedcertificate.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case issuedcertificate.FieldKeyType:
		v, ok := value.(issuedcertificate.KeyType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyType(v)
		return nil
	case issuedcertificate.FieldKeySize:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeySize(v)
		return nil
	case issuedcertificate.FieldAutoRenewEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoRenewEnabled(v)
		return nil
	case issuedcertificate.FieldAutoRenewDaysBeforeExpiry:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoRenewDaysBeforeExpiry(v)
		return nil
	case issuedcertificate.FieldAutoRenewMaxAttempts:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoRenewMaxAttempts(v)
		return nil
	case issuedcertificate.FieldAutoRenewRetryIntervalSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoRenewRetryIntervalSeconds(v)
		return nil
	case issuedcertificate.FieldLastRenewalAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRenewalAt(v)
		return nil
	case issuedcertificate.FieldRenewalAttempts:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenewalAttempts(v)
		return nil
	case issuedcertificate.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case issuedcertificate.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case issuedcertificate.FieldRevokedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedReason(v)
		return nil
	case issuedcertificate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case issuedcertificate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IssuedCertificate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IssuedCertificateMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, issuedcertificate.FieldTenantID)
	}
	if m.addkey_size != nil {
		fields = append(fields, issuedcertificate.FieldKeySize)
	}
	if m.addauto_renew_days_before_expiry != nil {
		fields = append(fields, issuedcertificate.FieldAutoRenewDaysBeforeExpiry)
	}
	if m.addauto_renew_max_attempts != nil {
		fields = append(fields, issuedcertificate.FieldAutoRenewMaxAttempts)
	}
	if m.addauto_renew_retry_interval_seconds != nil {
		fields = append(fields, issuedcertificate.FieldAutoRenewRetryIntervalSeconds)
	}
	if m.addrenewal_attempts != nil {
		fields = append(fields, issuedcertificate.FieldRenewalAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IssuedCertificateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case issuedcertificate.FieldTenantID:
		return m.AddedTenantID()
	case issuedcertificate.FieldKeySize:
		return m.AddedKeySize()
	case issuedcertificate.FieldAutoRenewDaysBeforeExpiry:
		return m.AddedAutoRenewDaysBeforeExpiry()
	case issuedcertificate.FieldAutoRenewMaxAttempts:
		return m.AddedAutoRenewMaxAttempts()
	case issuedcertificate.FieldAutoRenewRetryIntervalSeconds:
		return m.AddedAutoRenewRetryIntervalSeconds()
	case issuedcertificate.FieldRenewalAttempts:
		return m.AddedRenewalAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssuedCertificateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case issuedcertificate.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case issuedcertificate.FieldKeySize:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKeySize(v)
		return nil
	case issuedcertificate.FieldAutoRenewDaysBeforeExpiry:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAutoRenewDaysBeforeExpiry(v)
		return nil
	case issuedcertificate.FieldAutoRenewMaxAttempts:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAutoRenewMaxAttempts(v)
		return nil
	case issuedcertificate.FieldAutoRenewRetryIntervalSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAutoRenewRetryIntervalSeconds(v)
		return nil
	case issuedcertificate.FieldRenewalAttempts:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRenewalAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown IssuedCertificate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IssuedCertificateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(issuedcertificate.FieldClientID) {
		fields = append(fields, issuedcertificate.FieldClientID)
	}
	if m.FieldCleared(issuedcertificate.FieldIssuerType) {
		fields = append(fields, issuedcertificate.FieldIssuerType)
	}
	if m.FieldCleared(issuedcertificate.FieldTenantID) {
		fields = append(fields, issuedcertificate.FieldTenantID)
	}
	if m.FieldCleared(issuedcertificate.FieldCommonName) {
		fields = append(fields, issuedcertificate.FieldCommonName)
	}
	if m.FieldCleared(issuedcertificate.FieldIPAddresses) {
		fields = append(fields, issuedcertificate.FieldIPAddresses)
	}
	if m.FieldCleared(issuedcertificate.FieldCertPem) {
		fields = append(fields, issuedcertificate.FieldCertPem)
	}
	if m.FieldCleared(issuedcertificate.FieldPrivateKeyPem) {
		fields = append(fields, issuedcertificate.FieldPrivateKeyPem)
	}
	if m.FieldCleared(issuedcertificate.FieldCaCertPem) {
		fields = append(fields, issuedcertificate.FieldCaCertPem)
	}
	if m.FieldCleared(issuedcertificate.FieldCsrPem) {
		fields = append(fields, issuedcertificate.FieldCsrPem)
	}
	if m.FieldCleared(issuedcertificate.FieldCertificateFingerprint) {
		fields = append(fields, issuedcertificate.FieldCertificateFingerprint)
	}
	if m.FieldCleared(issuedcertificate.FieldErrorMessage) {
		fields = append(fields, issuedcertificate.FieldErrorMessage)
	}
	if m.FieldCleared(issuedcertificate.FieldKeyType) {
		fields = append(fields, issuedcertificate.FieldKeyType)
	}
	if m.FieldCleared(issuedcertificate.FieldKeySize) {
		fields = append(fields, issuedcertificate.FieldKeySize)
	}
	if m.FieldCleared(issuedcertificate.FieldAutoRenewDaysBeforeExpiry) {
		fields = append(fields, issuedcertificate.FieldAutoRenewDaysBeforeExpiry)
	}
	if m.FieldCleared(issuedcertificate.FieldAutoRenewMaxAttempts) {
		fields = append(fields, issuedcertificate.FieldAutoRenewMaxAttempts)
	}
	if m.FieldCleared(issuedcertificate.FieldAutoRenewRetryIntervalSeconds) {
		fields = append(fields, issuedcertificate.FieldAutoRenewRetryIntervalSeconds)
	}
	if m.FieldCleared(issuedcertificate.FieldLastRenewalAt) {
		fields = append(fields, issuedcertificate.FieldLastRenewalAt)
	}
	if m.FieldCleared(issuedcertificate.FieldExpiresAt) {
		fields = append(fields, issuedcertificate.FieldExpiresAt)
	}
	if m.FieldCleared(issuedcertificate.FieldRevokedAt) {
		fields = append(fields, issuedcertificate.FieldRevokedAt)
	}
	if m.FieldCleared(issuedcertificate.FieldRevokedReason) {
		fields = append(fields, issuedcertificate.FieldRevokedReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IssuedCertificateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IssuedCertificateMutation) ClearField(name string) error {
	switch name {
	case issuedcertificate.FieldClientID:
		m.ClearClientID()
		return nil
	case issuedcertificate.FieldIssuerType:
		m.ClearIssuerType()
		return nil
	case issuedcertificate.FieldTenantID:
		m.ClearTenantID()
		return nil
	case issuedcertificate.FieldCommonName:
		m.ClearCommonName()
		return nil
	case issuedcertificate.FieldIPAddresses:
		m.ClearIPAddresses()
		return nil
	case issuedcertificate.FieldCertPem:
		m.ClearCertPem()
		return nil
	case issuedcertificate.FieldPrivateKeyPem:
		m.ClearPrivateKeyPem()
		return nil
	case issuedcertificate.FieldCaCertPem:
		m.ClearCaCertPem()
		return nil
	case issuedcertificate.FieldCsrPem:
		m.ClearCsrPem()
		return nil
	case issuedcertificate.FieldCertificateFingerprint:
		m.ClearCertificateFingerprint()
		return nil
	case issuedcertificate.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case issuedcertificate.FieldKeyType:
		m.ClearKeyType()
		return nil
	case issuedcertificate.FieldKeySize:
		m.ClearKeySize()
		return nil
	case issuedcertificate.FieldAutoRenewDaysBeforeExpiry:
		m.ClearAutoRenewDaysBeforeExpiry()
		return nil
	case issuedcertificate.FieldAutoRenewMaxAttempts:
		m.ClearAutoRenewMaxAttempts()
		return nil
	case issuedcertificate.FieldAutoRenewRetryIntervalSeconds:
		m.ClearAutoRenewRetryIntervalSeconds()
		return nil
	case issuedcertificate.FieldLastRenewalAt:
		m.ClearLastRenewalAt()
		return nil
	case issuedcertificate.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case issuedcertificate.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case issuedcertificate.FieldRevokedReason:
		m.ClearRevokedReason()
		return nil
	}
	return fmt.Errorf("unknown IssuedCertificate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IssuedCertificateMutation) ResetField(name string) error {
	switch name {
	case issuedcertificate.FieldClientID:
		m.ResetClientID()
		return nil
	case issuedcertificate.FieldIssuerName:
		m.ResetIssuerName()
		return nil
	case issuedcertificate.FieldIssuerType:
		m.ResetIssuerType()
		return nil
	case issuedcertificate.FieldTenantID:
		m.ResetTenantID()
		return nil
	case issuedcertificate.FieldCommonName:
		m.ResetCommonName()
		return nil
	case issuedcertificate.FieldDomains:
		m.ResetDomains()
		return nil
	case issuedcertificate.FieldIPAddresses:
		m.ResetIPAddresses()
		return nil
	case issuedcertificate.FieldStatus:
		m.ResetStatus()
		return nil
	case issuedcertificate.FieldCertPem:
		m.ResetCertPem()
		return nil
	case issuedcertificate.FieldPrivateKeyPem:
		m.ResetPrivateKeyPem()
		return nil
	case issuedcertificate.FieldServerGeneratedKey:
		m.ResetServerGeneratedKey()
		return nil
	case issuedcertificate.FieldCaCertPem:
		m.ResetCaCertPem()
		return nil
	case issuedcertificate.FieldCsrPem:
		m.ResetCsrPem()
		return nil
	case issuedcertificate.FieldCertificateFingerprint:
		m.ResetCertificateFingerprint()
		return nil
	case issuedcertificate.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case issuedcertificate.FieldKeyType:
		m.ResetKeyType()
		return nil
	case issuedcertificate.FieldKeySize:
		m.ResetKeySize()
		return nil
	case issuedcertificate.FieldAutoRenewEnabled:
		m.ResetAutoRenewEnabled()
		return nil
	case issuedcertificate.FieldAutoRenewDaysBeforeExpiry:
		m.ResetAutoRenewDaysBeforeExpiry()
		return nil
	case issuedcertificate.FieldAutoRenewMaxAttempts:
		m.ResetAutoRenewMaxAttempts()
		return nil
	case issuedcertificate.FieldAutoRenewRetryIntervalSeconds:
		m.ResetAutoRenewRetryIntervalSeconds()
		return nil
	case issuedcertificate.FieldLastRenewalAt:
		m.ResetLastRenewalAt()
		return nil
	case issuedcertificate.FieldRenewalAttempts:
		m.ResetRenewalAttempts()
		return nil
	case issuedcertificate.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case issuedcertificate.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case issuedcertificate.FieldRevokedReason:
		m.ResetRevokedReason()
		return nil
	case issuedcertificate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case issuedcertificate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown IssuedCertificate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IssuedCertificateMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.lcm_client != nil {
		edges = append(edges, issuedcertificate.EdgeLcmClient)
	}
	if m.certificate_details != nil {
		edges = append(edges, issuedcertificate.EdgeCertificateDetails)
	}
	if m.permissions != nil {
		edges = append(edges, issuedcertificate.EdgePermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IssuedCertificateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case issuedcertificate.EdgeLcmClient:
		if id := m.lcm_client; id != nil {
			return []ent.Value{*id}
		}
	case issuedcertificate.EdgeCertificateDetails:
		if id := m.certificate_details; id != nil {
			return []ent.Value{*id}
		}
	case issuedcertificate.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IssuedCertificateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpermissions != nil {
		edges = append(edges, issuedcertificate.EdgePermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IssuedCertificateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case issuedcertificate.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IssuedCertificateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedlcm_client {
		edges = append(edges, issuedcertificate.EdgeLcmClient)
	}
	if m.clearedcertificate_details {
		edges = append(edges, issuedcertificate.EdgeCertificateDetails)
	}
	if m.clearedpermissions {
		edges = append(edges, issuedcertificate.EdgePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IssuedCertificateMutation) EdgeCleared(name string) bool {
	switch name {
	case issuedcertificate.EdgeLcmClient:
		return m.clearedlcm_client
	case issuedcertificate.EdgeCertificateDetails:
		return m.clearedcertificate_details
	case issuedcertificate.EdgePermissions:
		return m.clearedpermissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IssuedCertificateMutation) ClearEdge(name string) error {
	switch name {
	case issuedcertificate.EdgeLcmClient:
		m.ClearLcmClient()
		return nil
	case issuedcertificate.EdgeCertificateDetails:
		m.ClearCertificateDetails()
		return nil
	}
	return fmt.Errorf("unknown IssuedCertificate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IssuedCertificateMutation) ResetEdge(name string) error {
	switch name {
	case issuedcertificate.EdgeLcmClient:
		m.ResetLcmClient()
		return nil
	case issuedcertificate.EdgeCertificateDetails:
		m.ResetCertificateDetails()
		return nil
	case issuedcertificate.EdgePermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown IssuedCertificate edge %s", name)
}

// IssuerMutation represents an operation that mutates the Issuer nodes in the graph.
type IssuerMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uint32
	create_by                   *uint32
	addcreate_by                *int32
	update_by                   *uint32
	addupdate_by                *int32
	create_time                 *time.Time
	update_time                 *time.Time
	delete_time                 *time.Time
	tenant_id                   *uint32
	addtenant_id                *int32
	name                        *string
	_type                       *issuer.Type
	description                 *string
	_config                     *map[string]string
	client_id                   *string
	status                      *issuer.Status
	clearedFields               map[string]struct{}
	self_signed_configs         map[int]struct{}
	removedself_signed_configs  map[int]struct{}
	clearedself_signed_configs  bool
	acme_configs                map[int]struct{}
	removedacme_configs         map[int]struct{}
	clearedacme_configs         bool
	certificate_requests        map[int]struct{}
	removedcertificate_requests map[int]struct{}
	clearedcertificate_requests bool
	client_associations         map[int]struct{}
	removedclient_associations  map[int]struct{}
	clearedclient_associations  bool
	lcm_client                  *uint32
	clearedlcm_client           bool
	done                        bool
	oldValue                    func(context.Context) (*Issuer, error)
	predicates                  []predicate.Issuer
}

var _ ent.Mutation = (*IssuerMutation)(nil)

// issuerOption allows management of the mutation configuration using functional options.
type issuerOption func(*IssuerMutation)

// newIssuerMutation creates new mutation for the Issuer entity.
func newIssuerMutation(c config, op Op, opts ...issuerOption) *IssuerMutation {
	m := &IssuerMutation{
		config:        c,
		op:            op,
		typ:           TypeIssuer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIssuerID sets the ID field of the mutation.
func withIssuerID(id uint32) issuerOption {
	return func(m *IssuerMutation) {
		var (
			err   error
			once  sync.Once
			value *Issuer
		)
		m.oldValue = func(ctx context.Context) (*Issuer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Issuer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIssuer sets the old Issuer of the mutation.
func withIssuer(node *Issuer) issuerOption {
	return func(m *IssuerMutation) {
		m.oldValue = func(context.Context) (*Issuer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IssuerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IssuerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Issuer entities.
func (m *IssuerMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IssuerMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IssuerMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Issuer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *IssuerMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *IssuerMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the Issuer entity.
// If the Issuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuerMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *IssuerMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *IssuerMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *IssuerMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[issuer.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *IssuerMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[issuer.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *IssuerMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, issuer.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *IssuerMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *IssuerMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the Issuer entity.
// If the Issuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuerMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *IssuerMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *IssuerMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *IssuerMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[issuer.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *IssuerMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[issuer.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *IssuerMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, issuer.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *IssuerMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *IssuerMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Issuer entity.
// If the Issuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuerMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *IssuerMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[issuer.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *IssuerMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[issuer.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *IssuerMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, issuer.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *IssuerMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *IssuerMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Issuer entity.
// If the Issuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuerMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *IssuerMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[issuer.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *IssuerMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[issuer.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *IssuerMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, issuer.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *IssuerMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *IssuerMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Issuer entity.
// If the Issuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuerMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *IssuerMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[issuer.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *IssuerMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[issuer.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *IssuerMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, issuer.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *IssuerMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IssuerMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Issuer entity.
// If the Issuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuerMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *IssuerMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *IssuerMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *IssuerMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[issuer.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *IssuerMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[issuer.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IssuerMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, issuer.FieldTenantID)
}

// SetName sets the "name" field.
func (m *IssuerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IssuerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Issuer entity.
// If the Issuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IssuerMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *IssuerMutation) SetType(i issuer.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *IssuerMutation) GetType() (r issuer.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Issuer entity.
// If the Issuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuerMutation) OldType(ctx context.Context) (v issuer.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *IssuerMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *IssuerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IssuerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Issuer entity.
// If the Issuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IssuerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[issuer.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IssuerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[issuer.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IssuerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, issuer.FieldDescription)
}

// SetConfig sets the "config" field.
func (m *IssuerMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *IssuerMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Issuer entity.
// If the Issuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuerMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *IssuerMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[issuer.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *IssuerMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[issuer.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *IssuerMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, issuer.FieldConfig)
}

// SetClientID sets the "client_id" field.
func (m *IssuerMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *IssuerMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the Issuer entity.
// If the Issuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuerMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *IssuerMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[issuer.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *IssuerMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[issuer.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *IssuerMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, issuer.FieldClientID)
}

// SetStatus sets the "status" field.
func (m *IssuerMutation) SetStatus(i issuer.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *IssuerMutation) Status() (r issuer.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Issuer entity.
// If the Issuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuerMutation) OldStatus(ctx context.Context) (v *issuer.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *IssuerMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[issuer.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *IssuerMutation) StatusCleared() bool {
	_, ok := m.clearedFields[issuer.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *IssuerMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, issuer.FieldStatus)
}

// AddSelfSignedConfigIDs adds the "self_signed_configs" edge to the SelfSignedIssuer entity by ids.
func (m *IssuerMutation) AddSelfSignedConfigIDs(ids ...int) {
	if m.self_signed_configs == nil {
		m.self_signed_configs = make(map[int]struct{})
	}
	for i := range ids {
		m.self_signed_configs[ids[i]] = struct{}{}
	}
}

// ClearSelfSignedConfigs clears the "self_signed_configs" edge to the SelfSignedIssuer entity.
func (m *IssuerMutation) ClearSelfSignedConfigs() {
	m.clearedself_signed_configs = true
}

// SelfSignedConfigsCleared reports if the "self_signed_configs" edge to the SelfSignedIssuer entity was cleared.
func (m *IssuerMutation) SelfSignedConfigsCleared() bool {
	return m.clearedself_signed_configs
}

// RemoveSelfSignedConfigIDs removes the "self_signed_configs" edge to the SelfSignedIssuer entity by IDs.
func (m *IssuerMutation) RemoveSelfSignedConfigIDs(ids ...int) {
	if m.removedself_signed_configs == nil {
		m.removedself_signed_configs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.self_signed_configs, ids[i])
		m.removedself_signed_configs[ids[i]] = struct{}{}
	}
}

// RemovedSelfSignedConfigs returns the removed IDs of the "self_signed_configs" edge to the SelfSignedIssuer entity.
func (m *IssuerMutation) RemovedSelfSignedConfigsIDs() (ids []int) {
	for id := range m.removedself_signed_configs {
		ids = append(ids, id)
	}
	return
}

// SelfSignedConfigsIDs returns the "self_signed_configs" edge IDs in the mutation.
func (m *IssuerMutation) SelfSignedConfigsIDs() (ids []int) {
	for id := range m.self_signed_configs {
		ids = append(ids, id)
	}
	return
}

// ResetSelfSignedConfigs resets all changes to the "self_signed_configs" edge.
func (m *IssuerMutation) ResetSelfSignedConfigs() {
	m.self_signed_configs = nil
	m.clearedself_signed_configs = false
	m.removedself_signed_configs = nil
}

// AddAcmeConfigIDs adds the "acme_configs" edge to the AcmeIssuer entity by ids.
func (m *IssuerMutation) AddAcmeConfigIDs(ids ...int) {
	if m.acme_configs == nil {
		m.acme_configs = make(map[int]struct{})
	}
	for i := range ids {
		m.acme_configs[ids[i]] = struct{}{}
	}
}

// ClearAcmeConfigs clears the "acme_configs" edge to the AcmeIssuer entity.
func (m *IssuerMutation) ClearAcmeConfigs() {
	m.clearedacme_configs = true
}

// AcmeConfigsCleared reports if the "acme_configs" edge to the AcmeIssuer entity was cleared.
func (m *IssuerMutation) AcmeConfigsCleared() bool {
	return m.clearedacme_configs
}

// RemoveAcmeConfigIDs removes the "acme_configs" edge to the AcmeIssuer entity by IDs.
func (m *IssuerMutation) RemoveAcmeConfigIDs(ids ...int) {
	if m.removedacme_configs == nil {
		m.removedacme_configs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.acme_configs, ids[i])
		m.removedacme_configs[ids[i]] = struct{}{}
	}
}

// RemovedAcmeConfigs returns the removed IDs of the "acme_configs" edge to the AcmeIssuer entity.
func (m *IssuerMutation) RemovedAcmeConfigsIDs() (ids []int) {
	for id := range m.removedacme_configs {
		ids = append(ids, id)
	}
	return
}

// AcmeConfigsIDs returns the "acme_configs" edge IDs in the mutation.
func (m *IssuerMutation) AcmeConfigsIDs() (ids []int) {
	for id := range m.acme_configs {
		ids = append(ids, id)
	}
	return
}

// ResetAcmeConfigs resets all changes to the "acme_configs" edge.
func (m *IssuerMutation) ResetAcmeConfigs() {
	m.acme_configs = nil
	m.clearedacme_configs = false
	m.removedacme_configs = nil
}

// AddCertificateRequestIDs adds the "certificate_requests" edge to the CertificateRequest entity by ids.
func (m *IssuerMutation) AddCertificateRequestIDs(ids ...int) {
	if m.certificate_requests == nil {
		m.certificate_requests = make(map[int]struct{})
	}
	for i := range ids {
		m.certificate_requests[ids[i]] = struct{}{}
	}
}

// ClearCertificateRequests clears the "certificate_requests" edge to the CertificateRequest entity.
func (m *IssuerMutation) ClearCertificateRequests() {
	m.clearedcertificate_requests = true
}

// CertificateRequestsCleared reports if the "certificate_requests" edge to the CertificateRequest entity was cleared.
func (m *IssuerMutation) CertificateRequestsCleared() bool {
	return m.clearedcertificate_requests
}

// RemoveCertificateRequestIDs removes the "certificate_requests" edge to the CertificateRequest entity by IDs.
func (m *IssuerMutation) RemoveCertificateRequestIDs(ids ...int) {
	if m.removedcertificate_requests == nil {
		m.removedcertificate_requests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.certificate_requests, ids[i])
		m.removedcertificate_requests[ids[i]] = struct{}{}
	}
}

// RemovedCertificateRequests returns the removed IDs of the "certificate_requests" edge to the CertificateRequest entity.
func (m *IssuerMutation) RemovedCertificateRequestsIDs() (ids []int) {
	for id := range m.removedcertificate_requests {
		ids = append(ids, id)
	}
	return
}

// CertificateRequestsIDs returns the "certificate_requests" edge IDs in the mutation.
func (m *IssuerMutation) CertificateRequestsIDs() (ids []int) {
	for id := range m.certificate_requests {
		ids = append(ids, id)
	}
	return
}

// ResetCertificateRequests resets all changes to the "certificate_requests" edge.
func (m *IssuerMutation) ResetCertificateRequests() {
	m.certificate_requests = nil
	m.clearedcertificate_requests = false
	m.removedcertificate_requests = nil
}

// AddClientAssociationIDs adds the "client_associations" edge to the ClientIssuer entity by ids.
func (m *IssuerMutation) AddClientAssociationIDs(ids ...int) {
	if m.client_associations == nil {
		m.client_associations = make(map[int]struct{})
	}
	for i := range ids {
		m.client_associations[ids[i]] = struct{}{}
	}
}

// ClearClientAssociations clears the "client_associations" edge to the ClientIssuer entity.
func (m *IssuerMutation) ClearClientAssociations() {
	m.clearedclient_associations = true
}

// ClientAssociationsCleared reports if the "client_associations" edge to the ClientIssuer entity was cleared.
func (m *IssuerMutation) ClientAssociationsCleared() bool {
	return m.clearedclient_associations
}

// RemoveClientAssociationIDs removes the "client_associations" edge to the ClientIssuer entity by IDs.
func (m *IssuerMutation) RemoveClientAssociationIDs(ids ...int) {
	if m.removedclient_associations == nil {
		m.removedclient_associations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.client_associations, ids[i])
		m.removedclient_associations[ids[i]] = struct{}{}
	}
}

// RemovedClientAssociations returns the removed IDs of the "client_associations" edge to the ClientIssuer entity.
func (m *IssuerMutation) RemovedClientAssociationsIDs() (ids []int) {
	for id := range m.removedclient_associations {
		ids = append(ids, id)
	}
	return
}

// ClientAssociationsIDs returns the "client_associations" edge IDs in the mutation.
func (m *IssuerMutation) ClientAssociationsIDs() (ids []int) {
	for id := range m.client_associations {
		ids = append(ids, id)
	}
	return
}

// ResetClientAssociations resets all changes to the "client_associations" edge.
func (m *IssuerMutation) ResetClientAssociations() {
	m.client_associations = nil
	m.clearedclient_associations = false
	m.removedclient_associations = nil
}

// SetLcmClientID sets the "lcm_client" edge to the LcmClient entity by id.
func (m *IssuerMutation) SetLcmClientID(id uint32) {
	m.lcm_client = &id
}

// ClearLcmClient clears the "lcm_client" edge to the LcmClient entity.
func (m *IssuerMutation) ClearLcmClient() {
	m.clearedlcm_client = true
}

// LcmClientCleared reports if the "lcm_client" edge to the LcmClient entity was cleared.
func (m *IssuerMutation) LcmClientCleared() bool {
	return m.clearedlcm_client
}

// LcmClientID returns the "lcm_client" edge ID in the mutation.
func (m *IssuerMutation) LcmClientID() (id uint32, exists bool) {
	if m.lcm_client != nil {
		return *m.lcm_client, true
	}
	return
}

// LcmClientIDs returns the "lcm_client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LcmClientID instead. It exists only for internal usage by the builders.
func (m *IssuerMutation) LcmClientIDs() (ids []uint32) {
	if id := m.lcm_client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLcmClient resets all changes to the "lcm_client" edge.
func (m *IssuerMutation) ResetLcmClient() {
	m.lcm_client = nil
	m.clearedlcm_client = false
}

// Where appends a list predicates to the IssuerMutation builder.
func (m *IssuerMutation) Where(ps ...predicate.Issuer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IssuerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IssuerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Issuer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IssuerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IssuerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Issuer).
func (m *IssuerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IssuerMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_by != nil {
		fields = append(fields, issuer.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, issuer.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, issuer.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, issuer.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, issuer.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, issuer.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, issuer.FieldName)
	}
	if m._type != nil {
		fields = append(fields, issuer.FieldType)
	}
	if m.description != nil {
		fields = append(fields, issuer.FieldDescription)
	}
	if m._config != nil {
		fields = append(fields, issuer.FieldConfig)
	}
	if m.client_id != nil {
		fields = append(fields, issuer.FieldClientID)
	}
	if m.status != nil {
		fields = append(fields, issuer.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IssuerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case issuer.FieldCreateBy:
		return m.CreateBy()
	case issuer.FieldUpdateBy:
		return m.UpdateBy()
	case issuer.FieldCreateTime:
		return m.CreateTime()
	case issuer.FieldUpdateTime:
		return m.UpdateTime()
	case issuer.FieldDeleteTime:
		return m.DeleteTime()
	case issuer.FieldTenantID:
		return m.TenantID()
	case issuer.FieldName:
		return m.Name()
	case issuer.FieldType:
		return m.GetType()
	case issuer.FieldDescription:
		return m.Description()
	case issuer.FieldConfig:
		return m.Config()
	case issuer.FieldClientID:
		return m.ClientID()
	case issuer.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IssuerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case issuer.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case issuer.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case issuer.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case issuer.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case issuer.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case issuer.FieldTenantID:
		return m.OldTenantID(ctx)
	case issuer.FieldName:
		return m.OldName(ctx)
	case issuer.FieldType:
		return m.OldType(ctx)
	case issuer.FieldDescription:
		return m.OldDescription(ctx)
	case issuer.FieldConfig:
		return m.OldConfig(ctx)
	case issuer.FieldClientID:
		return m.OldClientID(ctx)
	case issuer.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Issuer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssuerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case issuer.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case issuer.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case issuer.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case issuer.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case issuer.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case issuer.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case issuer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case issuer.FieldType:
		v, ok := value.(issuer.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case issuer.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case issuer.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case issuer.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case issuer.FieldStatus:
		v, ok := value.(issuer.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Issuer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IssuerMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, issuer.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, issuer.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, issuer.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IssuerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case issuer.FieldCreateBy:
		return m.AddedCreateBy()
	case issuer.FieldUpdateBy:
		return m.AddedUpdateBy()
	case issuer.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssuerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case issuer.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case issuer.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case issuer.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Issuer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IssuerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(issuer.FieldCreateBy) {
		fields = append(fields, issuer.FieldCreateBy)
	}
	if m.FieldCleared(issuer.FieldUpdateBy) {
		fields = append(fields, issuer.FieldUpdateBy)
	}
	if m.FieldCleared(issuer.FieldCreateTime) {
		fields = append(fields, issuer.FieldCreateTime)
	}
	if m.FieldCleared(issuer.FieldUpdateTime) {
		fields = append(fields, issuer.FieldUpdateTime)
	}
	if m.FieldCleared(issuer.FieldDeleteTime) {
		fields = append(fields, issuer.FieldDeleteTime)
	}
	if m.FieldCleared(issuer.FieldTenantID) {
		fields = append(fields, issuer.FieldTenantID)
	}
	if m.FieldCleared(issuer.FieldDescription) {
		fields = append(fields, issuer.FieldDescription)
	}
	if m.FieldCleared(issuer.FieldConfig) {
		fields = append(fields, issuer.FieldConfig)
	}
	if m.FieldCleared(issuer.FieldClientID) {
		fields = append(fields, issuer.FieldClientID)
	}
	if m.FieldCleared(issuer.FieldStatus) {
		fields = append(fields, issuer.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IssuerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IssuerMutation) ClearField(name string) error {
	switch name {
	case issuer.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case issuer.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case issuer.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case issuer.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case issuer.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case issuer.FieldTenantID:
		m.ClearTenantID()
		return nil
	case issuer.FieldDescription:
		m.ClearDescription()
		return nil
	case issuer.FieldConfig:
		m.ClearConfig()
		return nil
	case issuer.FieldClientID:
		m.ClearClientID()
		return nil
	case issuer.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Issuer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IssuerMutation) ResetField(name string) error {
	switch name {
	case issuer.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case issuer.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case issuer.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case issuer.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case issuer.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case issuer.FieldTenantID:
		m.ResetTenantID()
		return nil
	case issuer.FieldName:
		m.ResetName()
		return nil
	case issuer.FieldType:
		m.ResetType()
		return nil
	case issuer.FieldDescription:
		m.ResetDescription()
		return nil
	case issuer.FieldConfig:
		m.ResetConfig()
		return nil
	case issuer.FieldClientID:
		m.ResetClientID()
		return nil
	case issuer.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Issuer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IssuerMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.self_signed_configs != nil {
		edges = append(edges, issuer.EdgeSelfSignedConfigs)
	}
	if m.acme_configs != nil {
		edges = append(edges, issuer.EdgeAcmeConfigs)
	}
	if m.certificate_requests != nil {
		edges = append(edges, issuer.EdgeCertificateRequests)
	}
	if m.client_associations != nil {
		edges = append(edges, issuer.EdgeClientAssociations)
	}
	if m.lcm_client != nil {
		edges = append(edges, issuer.EdgeLcmClient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IssuerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case issuer.EdgeSelfSignedConfigs:
		ids := make([]ent.Value, 0, len(m.self_signed_configs))
		for id := range m.self_signed_configs {
			ids = append(ids, id)
		}
		return ids
	case issuer.EdgeAcmeConfigs:
		ids := make([]ent.Value, 0, len(m.acme_configs))
		for id := range m.acme_configs {
			ids = append(ids, id)
		}
		return ids
	case issuer.EdgeCertificateRequests:
		ids := make([]ent.Value, 0, len(m.certificate_requests))
		for id := range m.certificate_requests {
			ids = append(ids, id)
		}
		return ids
	case issuer.EdgeClientAssociations:
		ids := make([]ent.Value, 0, len(m.client_associations))
		for id := range m.client_associations {
			ids = append(ids, id)
		}
		return ids
	case issuer.EdgeLcmClient:
		if id := m.lcm_client; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IssuerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedself_signed_configs != nil {
		edges = append(edges, issuer.EdgeSelfSignedConfigs)
	}
	if m.removedacme_configs != nil {
		edges = append(edges, issuer.EdgeAcmeConfigs)
	}
	if m.removedcertificate_requests != nil {
		edges = append(edges, issuer.EdgeCertificateRequests)
	}
	if m.removedclient_associations != nil {
		edges = append(edges, issuer.EdgeClientAssociations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IssuerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case issuer.EdgeSelfSignedConfigs:
		ids := make([]ent.Value, 0, len(m.removedself_signed_configs))
		for id := range m.removedself_signed_configs {
			ids = append(ids, id)
		}
		return ids
	case issuer.EdgeAcmeConfigs:
		ids := make([]ent.Value, 0, len(m.removedacme_configs))
		for id := range m.removedacme_configs {
			ids = append(ids, id)
		}
		return ids
	case issuer.EdgeCertificateRequests:
		ids := make([]ent.Value, 0, len(m.removedcertificate_requests))
		for id := range m.removedcertificate_requests {
			ids = append(ids, id)
		}
		return ids
	case issuer.EdgeClientAssociations:
		ids := make([]ent.Value, 0, len(m.removedclient_associations))
		for id := range m.removedclient_associations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IssuerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedself_signed_configs {
		edges = append(edges, issuer.EdgeSelfSignedConfigs)
	}
	if m.clearedacme_configs {
		edges = append(edges, issuer.EdgeAcmeConfigs)
	}
	if m.clearedcertificate_requests {
		edges = append(edges, issuer.EdgeCertificateRequests)
	}
	if m.clearedclient_associations {
		edges = append(edges, issuer.EdgeClientAssociations)
	}
	if m.clearedlcm_client {
		edges = append(edges, issuer.EdgeLcmClient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IssuerMutation) EdgeCleared(name string) bool {
	switch name {
	case issuer.EdgeSelfSignedConfigs:
		return m.clearedself_signed_configs
	case issuer.EdgeAcmeConfigs:
		return m.clearedacme_configs
	case issuer.EdgeCertificateRequests:
		return m.clearedcertificate_requests
	case issuer.EdgeClientAssociations:
		return m.clearedclient_associations
	case issuer.EdgeLcmClient:
		return m.clearedlcm_client
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IssuerMutation) ClearEdge(name string) error {
	switch name {
	case issuer.EdgeLcmClient:
		m.ClearLcmClient()
		return nil
	}
	return fmt.Errorf("unknown Issuer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IssuerMutation) ResetEdge(name string) error {
	switch name {
	case issuer.EdgeSelfSignedConfigs:
		m.ResetSelfSignedConfigs()
		return nil
	case issuer.EdgeAcmeConfigs:
		m.ResetAcmeConfigs()
		return nil
	case issuer.EdgeCertificateRequests:
		m.ResetCertificateRequests()
		return nil
	case issuer.EdgeClientAssociations:
		m.ResetClientAssociations()
		return nil
	case issuer.EdgeLcmClient:
		m.ResetLcmClient()
		return nil
	}
	return fmt.Errorf("unknown Issuer edge %s", name)
}

// LcmCaMutation represents an operation that mutates the LcmCa nodes in the graph.
type LcmCaMutation struct {
	config
	op                Op
	typ               string
	id                *uint32
	create_by         *uint32
	addcreate_by      *int32
	update_by         *uint32
	addupdate_by      *int32
	create_time       *time.Time
	update_time       *time.Time
	delete_time       *time.Time
	tenant_id         *uint32
	addtenant_id      *int32
	key_pem           *string
	certificate_pem   *string
	fingerprint       *string
	subject           *string
	serial            *string
	not_before        *time.Time
	not_after         *time.Time
	clearedFields     map[string]struct{}
	lcm_client        *uint32
	clearedlcm_client bool
	done              bool
	oldValue          func(context.Context) (*LcmCa, error)
	predicates        []predicate.LcmCa
}

var _ ent.Mutation = (*LcmCaMutation)(nil)

// lcmcaOption allows management of the mutation configuration using functional options.
type lcmcaOption func(*LcmCaMutation)

// newLcmCaMutation creates new mutation for the LcmCa entity.
func newLcmCaMutation(c config, op Op, opts ...lcmcaOption) *LcmCaMutation {
	m := &LcmCaMutation{
		config:        c,
		op:            op,
		typ:           TypeLcmCa,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLcmCaID sets the ID field of the mutation.
func withLcmCaID(id uint32) lcmcaOption {
	return func(m *LcmCaMutation) {
		var (
			err   error
			once  sync.Once
			value *LcmCa
		)
		m.oldValue = func(ctx context.Context) (*LcmCa, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LcmCa.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLcmCa sets the old LcmCa of the mutation.
func withLcmCa(node *LcmCa) lcmcaOption {
	return func(m *LcmCaMutation) {
		m.oldValue = func(context.Context) (*LcmCa, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LcmCaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LcmCaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LcmCa entities.
func (m *LcmCaMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LcmCaMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LcmCaMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LcmCa.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *LcmCaMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *LcmCaMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the LcmCa entity.
// If the LcmCa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmCaMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *LcmCaMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *LcmCaMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *LcmCaMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[lcmca.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *LcmCaMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[lcmca.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *LcmCaMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, lcmca.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *LcmCaMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *LcmCaMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the LcmCa entity.
// If the LcmCa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmCaMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *LcmCaMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *LcmCaMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *LcmCaMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[lcmca.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *LcmCaMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[lcmca.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *LcmCaMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, lcmca.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *LcmCaMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *LcmCaMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the LcmCa entity.
// If the LcmCa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmCaMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *LcmCaMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[lcmca.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *LcmCaMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[lcmca.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *LcmCaMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, lcmca.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *LcmCaMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *LcmCaMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the LcmCa entity.
// If the LcmCa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmCaMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *LcmCaMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[lcmca.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *LcmCaMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[lcmca.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *LcmCaMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, lcmca.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *LcmCaMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *LcmCaMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the LcmCa entity.
// If the LcmCa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmCaMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *LcmCaMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[lcmca.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *LcmCaMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[lcmca.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *LcmCaMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, lcmca.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *LcmCaMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *LcmCaMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the LcmCa entity.
// If the LcmCa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmCaMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *LcmCaMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *LcmCaMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *LcmCaMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[lcmca.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *LcmCaMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[lcmca.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *LcmCaMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, lcmca.FieldTenantID)
}

// SetKeyPem sets the "key_pem" field.
func (m *LcmCaMutation) SetKeyPem(s string) {
	m.key_pem = &s
}

// KeyPem returns the value of the "key_pem" field in the mutation.
func (m *LcmCaMutation) KeyPem() (r string, exists bool) {
	v := m.key_pem
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyPem returns the old "key_pem" field's value of the LcmCa entity.
// If the LcmCa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmCaMutation) OldKeyPem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyPem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyPem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyPem: %w", err)
	}
	return oldValue.KeyPem, nil
}

// ResetKeyPem resets all changes to the "key_pem" field.
func (m *LcmCaMutation) ResetKeyPem() {
	m.key_pem = nil
}

// SetCertificatePem sets the "certificate_pem" field.
func (m *LcmCaMutation) SetCertificatePem(s string) {
	m.certificate_pem = &s
}

// CertificatePem returns the value of the "certificate_pem" field in the mutation.
func (m *LcmCaMutation) CertificatePem() (r string, exists bool) {
	v := m.certificate_pem
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificatePem returns the old "certificate_pem" field's value of the LcmCa entity.
// If the LcmCa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmCaMutation) OldCertificatePem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificatePem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificatePem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificatePem: %w", err)
	}
	return oldValue.CertificatePem, nil
}

// ClearCertificatePem clears the value of the "certificate_pem" field.
func (m *LcmCaMutation) ClearCertificatePem() {
	m.certificate_pem = nil
	m.clearedFields[lcmca.FieldCertificatePem] = struct{}{}
}

// CertificatePemCleared returns if the "certificate_pem" field was cleared in this mutation.
func (m *LcmCaMutation) CertificatePemCleared() bool {
	_, ok := m.clearedFields[lcmca.FieldCertificatePem]
	return ok
}

// ResetCertificatePem resets all changes to the "certificate_pem" field.
func (m *LcmCaMutation) ResetCertificatePem() {
	m.certificate_pem = nil
	delete(m.clearedFields, lcmca.FieldCertificatePem)
}

// SetFingerprint sets the "fingerprint" field.
func (m *LcmCaMutation) SetFingerprint(s string) {
	m.fingerprint = &s
}

// Fingerprint returns the value of the "fingerprint" field in the mutation.
func (m *LcmCaMutation) Fingerprint() (r string, exists bool) {
	v := m.fingerprint
	if v == nil {
		return
	}
	return *v, true
}

// OldFingerprint returns the old "fingerprint" field's value of the LcmCa entity.
// If the LcmCa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmCaMutation) OldFingerprint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFingerprint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFingerprint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFingerprint: %w", err)
	}
	return oldValue.Fingerprint, nil
}

// ClearFingerprint clears the value of the "fingerprint" field.
func (m *LcmCaMutation) ClearFingerprint() {
	m.fingerprint = nil
	m.clearedFields[lcmca.FieldFingerprint] = struct{}{}
}

// FingerprintCleared returns if the "fingerprint" field was cleared in this mutation.
func (m *LcmCaMutation) FingerprintCleared() bool {
	_, ok := m.clearedFields[lcmca.FieldFingerprint]
	return ok
}

// ResetFingerprint resets all changes to the "fingerprint" field.
func (m *LcmCaMutation) ResetFingerprint() {
	m.fingerprint = nil
	delete(m.clearedFields, lcmca.FieldFingerprint)
}

// SetSubject sets the "subject" field.
func (m *LcmCaMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *LcmCaMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the LcmCa entity.
// If the LcmCa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmCaMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ClearSubject clears the value of the "subject" field.
func (m *LcmCaMutation) ClearSubject() {
	m.subject = nil
	m.clearedFields[lcmca.FieldSubject] = struct{}{}
}

// SubjectCleared returns if the "subject" field was cleared in this mutation.
func (m *LcmCaMutation) SubjectCleared() bool {
	_, ok := m.clearedFields[lcmca.FieldSubject]
	return ok
}

// ResetSubject resets all changes to the "subject" field.
func (m *LcmCaMutation) ResetSubject() {
	m.subject = nil
	delete(m.clearedFields, lcmca.FieldSubject)
}

// SetSerial sets the "serial" field.
func (m *LcmCaMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *LcmCaMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the LcmCa entity.
// If the LcmCa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmCaMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ClearSerial clears the value of the "serial" field.
func (m *LcmCaMutation) ClearSerial() {
	m.serial = nil
	m.clearedFields[lcmca.FieldSerial] = struct{}{}
}

// SerialCleared returns if the "serial" field was cleared in this mutation.
func (m *LcmCaMutation) SerialCleared() bool {
	_, ok := m.clearedFields[lcmca.FieldSerial]
	return ok
}

// ResetSerial resets all changes to the "serial" field.
func (m *LcmCaMutation) ResetSerial() {
	m.serial = nil
	delete(m.clearedFields, lcmca.FieldSerial)
}

// SetNotBefore sets the "not_before" field.
func (m *LcmCaMutation) SetNotBefore(t time.Time) {
	m.not_before = &t
}

// NotBefore returns the value of the "not_before" field in the mutation.
func (m *LcmCaMutation) NotBefore() (r time.Time, exists bool) {
	v := m.not_before
	if v == nil {
		return
	}
	return *v, true
}

// OldNotBefore returns the old "not_before" field's value of the LcmCa entity.
// If the LcmCa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmCaMutation) OldNotBefore(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotBefore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotBefore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotBefore: %w", err)
	}
	return oldValue.NotBefore, nil
}

// ClearNotBefore clears the value of the "not_before" field.
func (m *LcmCaMutation) ClearNotBefore() {
	m.not_before = nil
	m.clearedFields[lcmca.FieldNotBefore] = struct{}{}
}

// NotBeforeCleared returns if the "not_before" field was cleared in this mutation.
func (m *LcmCaMutation) NotBeforeCleared() bool {
	_, ok := m.clearedFields[lcmca.FieldNotBefore]
	return ok
}

// ResetNotBefore resets all changes to the "not_before" field.
func (m *LcmCaMutation) ResetNotBefore() {
	m.not_before = nil
	delete(m.clearedFields, lcmca.FieldNotBefore)
}

// SetNotAfter sets the "not_after" field.
func (m *LcmCaMutation) SetNotAfter(t time.Time) {
	m.not_after = &t
}

// NotAfter returns the value of the "not_after" field in the mutation.
func (m *LcmCaMutation) NotAfter() (r time.Time, exists bool) {
	v := m.not_after
	if v == nil {
		return
	}
	return *v, true
}

// OldNotAfter returns the old "not_after" field's value of the LcmCa entity.
// If the LcmCa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmCaMutation) OldNotAfter(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotAfter: %w", err)
	}
	return oldValue.NotAfter, nil
}

// ClearNotAfter clears the value of the "not_after" field.
func (m *LcmCaMutation) ClearNotAfter() {
	m.not_after = nil
	m.clearedFields[lcmca.FieldNotAfter] = struct{}{}
}

// NotAfterCleared returns if the "not_after" field was cleared in this mutation.
func (m *LcmCaMutation) NotAfterCleared() bool {
	_, ok := m.clearedFields[lcmca.FieldNotAfter]
	return ok
}

// ResetNotAfter resets all changes to the "not_after" field.
func (m *LcmCaMutation) ResetNotAfter() {
	m.not_after = nil
	delete(m.clearedFields, lcmca.FieldNotAfter)
}

// SetLcmClientID sets the "lcm_client" edge to the LcmClient entity by id.
func (m *LcmCaMutation) SetLcmClientID(id uint32) {
	m.lcm_client = &id
}

// ClearLcmClient clears the "lcm_client" edge to the LcmClient entity.
func (m *LcmCaMutation) ClearLcmClient() {
	m.clearedlcm_client = true
}

// LcmClientCleared reports if the "lcm_client" edge to the LcmClient entity was cleared.
func (m *LcmCaMutation) LcmClientCleared() bool {
	return m.clearedlcm_client
}

// LcmClientID returns the "lcm_client" edge ID in the mutation.
func (m *LcmCaMutation) LcmClientID() (id uint32, exists bool) {
	if m.lcm_client != nil {
		return *m.lcm_client, true
	}
	return
}

// LcmClientIDs returns the "lcm_client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LcmClientID instead. It exists only for internal usage by the builders.
func (m *LcmCaMutation) LcmClientIDs() (ids []uint32) {
	if id := m.lcm_client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLcmClient resets all changes to the "lcm_client" edge.
func (m *LcmCaMutation) ResetLcmClient() {
	m.lcm_client = nil
	m.clearedlcm_client = false
}

// Where appends a list predicates to the LcmCaMutation builder.
func (m *LcmCaMutation) Where(ps ...predicate.LcmCa) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LcmCaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LcmCaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LcmCa, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LcmCaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LcmCaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LcmCa).
func (m *LcmCaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LcmCaMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.create_by != nil {
		fields = append(fields, lcmca.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, lcmca.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, lcmca.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, lcmca.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, lcmca.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, lcmca.FieldTenantID)
	}
	if m.key_pem != nil {
		fields = append(fields, lcmca.FieldKeyPem)
	}
	if m.certificate_pem != nil {
		fields = append(fields, lcmca.FieldCertificatePem)
	}
	if m.fingerprint != nil {
		fields = append(fields, lcmca.FieldFingerprint)
	}
	if m.subject != nil {
		fields = append(fields, lcmca.FieldSubject)
	}
	if m.serial != nil {
		fields = append(fields, lcmca.FieldSerial)
	}
	if m.not_before != nil {
		fields = append(fields, lcmca.FieldNotBefore)
	}
	if m.not_after != nil {
		fields = append(fields, lcmca.FieldNotAfter)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LcmCaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lcmca.FieldCreateBy:
		return m.CreateBy()
	case lcmca.FieldUpdateBy:
		return m.UpdateBy()
	case lcmca.FieldCreateTime:
		return m.CreateTime()
	case lcmca.FieldUpdateTime:
		return m.UpdateTime()
	case lcmca.FieldDeleteTime:
		return m.DeleteTime()
	case lcmca.FieldTenantID:
		return m.TenantID()
	case lcmca.FieldKeyPem:
		return m.KeyPem()
	case lcmca.FieldCertificatePem:
		return m.CertificatePem()
	case lcmca.FieldFingerprint:
		return m.Fingerprint()
	case lcmca.FieldSubject:
		return m.Subject()
	case lcmca.FieldSerial:
		return m.Serial()
	case lcmca.FieldNotBefore:
		return m.NotBefore()
	case lcmca.FieldNotAfter:
		return m.NotAfter()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LcmCaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lcmca.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case lcmca.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case lcmca.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case lcmca.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case lcmca.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case lcmca.FieldTenantID:
		return m.OldTenantID(ctx)
	case lcmca.FieldKeyPem:
		return m.OldKeyPem(ctx)
	case lcmca.FieldCertificatePem:
		return m.OldCertificatePem(ctx)
	case lcmca.FieldFingerprint:
		return m.OldFingerprint(ctx)
	case lcmca.FieldSubject:
		return m.OldSubject(ctx)
	case lcmca.FieldSerial:
		return m.OldSerial(ctx)
	case lcmca.FieldNotBefore:
		return m.OldNotBefore(ctx)
	case lcmca.FieldNotAfter:
		return m.OldNotAfter(ctx)
	}
	return nil, fmt.Errorf("unknown LcmCa field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LcmCaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lcmca.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case lcmca.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case lcmca.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case lcmca.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case lcmca.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case lcmca.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case lcmca.FieldKeyPem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyPem(v)
		return nil
	case lcmca.FieldCertificatePem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificatePem(v)
		return nil
	case lcmca.FieldFingerprint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFingerprint(v)
		return nil
	case lcmca.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case lcmca.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case lcmca.FieldNotBefore:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotBefore(v)
		return nil
	case lcmca.FieldNotAfter:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotAfter(v)
		return nil
	}
	return fmt.Errorf("unknown LcmCa field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LcmCaMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, lcmca.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, lcmca.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, lcmca.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LcmCaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lcmca.FieldCreateBy:
		return m.AddedCreateBy()
	case lcmca.FieldUpdateBy:
		return m.AddedUpdateBy()
	case lcmca.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LcmCaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lcmca.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case lcmca.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case lcmca.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown LcmCa numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LcmCaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lcmca.FieldCreateBy) {
		fields = append(fields, lcmca.FieldCreateBy)
	}
	if m.FieldCleared(lcmca.FieldUpdateBy) {
		fields = append(fields, lcmca.FieldUpdateBy)
	}
	if m.FieldCleared(lcmca.FieldCreateTime) {
		fields = append(fields, lcmca.FieldCreateTime)
	}
	if m.FieldCleared(lcmca.FieldUpdateTime) {
		fields = append(fields, lcmca.FieldUpdateTime)
	}
	if m.FieldCleared(lcmca.FieldDeleteTime) {
		fields = append(fields, lcmca.FieldDeleteTime)
	}
	if m.FieldCleared(lcmca.FieldTenantID) {
		fields = append(fields, lcmca.FieldTenantID)
	}
	if m.FieldCleared(lcmca.FieldCertificatePem) {
		fields = append(fields, lcmca.FieldCertificatePem)
	}
	if m.FieldCleared(lcmca.FieldFingerprint) {
		fields = append(fields, lcmca.FieldFingerprint)
	}
	if m.FieldCleared(lcmca.FieldSubject) {
		fields = append(fields, lcmca.FieldSubject)
	}
	if m.FieldCleared(lcmca.FieldSerial) {
		fields = append(fields, lcmca.FieldSerial)
	}
	if m.FieldCleared(lcmca.FieldNotBefore) {
		fields = append(fields, lcmca.FieldNotBefore)
	}
	if m.FieldCleared(lcmca.FieldNotAfter) {
		fields = append(fields, lcmca.FieldNotAfter)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LcmCaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LcmCaMutation) ClearField(name string) error {
	switch name {
	case lcmca.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case lcmca.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case lcmca.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case lcmca.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case lcmca.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case lcmca.FieldTenantID:
		m.ClearTenantID()
		return nil
	case lcmca.FieldCertificatePem:
		m.ClearCertificatePem()
		return nil
	case lcmca.FieldFingerprint:
		m.ClearFingerprint()
		return nil
	case lcmca.FieldSubject:
		m.ClearSubject()
		return nil
	case lcmca.FieldSerial:
		m.ClearSerial()
		return nil
	case lcmca.FieldNotBefore:
		m.ClearNotBefore()
		return nil
	case lcmca.FieldNotAfter:
		m.ClearNotAfter()
		return nil
	}
	return fmt.Errorf("unknown LcmCa nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LcmCaMutation) ResetField(name string) error {
	switch name {
	case lcmca.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case lcmca.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case lcmca.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case lcmca.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case lcmca.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case lcmca.FieldTenantID:
		m.ResetTenantID()
		return nil
	case lcmca.FieldKeyPem:
		m.ResetKeyPem()
		return nil
	case lcmca.FieldCertificatePem:
		m.ResetCertificatePem()
		return nil
	case lcmca.FieldFingerprint:
		m.ResetFingerprint()
		return nil
	case lcmca.FieldSubject:
		m.ResetSubject()
		return nil
	case lcmca.FieldSerial:
		m.ResetSerial()
		return nil
	case lcmca.FieldNotBefore:
		m.ResetNotBefore()
		return nil
	case lcmca.FieldNotAfter:
		m.ResetNotAfter()
		return nil
	}
	return fmt.Errorf("unknown LcmCa field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LcmCaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.lcm_client != nil {
		edges = append(edges, lcmca.EdgeLcmClient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LcmCaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lcmca.EdgeLcmClient:
		if id := m.lcm_client; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LcmCaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LcmCaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LcmCaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlcm_client {
		edges = append(edges, lcmca.EdgeLcmClient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LcmCaMutation) EdgeCleared(name string) bool {
	switch name {
	case lcmca.EdgeLcmClient:
		return m.clearedlcm_client
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LcmCaMutation) ClearEdge(name string) error {
	switch name {
	case lcmca.EdgeLcmClient:
		m.ClearLcmClient()
		return nil
	}
	return fmt.Errorf("unknown LcmCa unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LcmCaMutation) ResetEdge(name string) error {
	switch name {
	case lcmca.EdgeLcmClient:
		m.ResetLcmClient()
		return nil
	}
	return fmt.Errorf("unknown LcmCa edge %s", name)
}

// LcmClientMutation represents an operation that mutates the LcmClient nodes in the graph.
type LcmClientMutation struct {
	config
	op                                Op
	typ                               string
	id                                *uint32
	create_by                         *uint32
	addcreate_by                      *int32
	update_by                         *uint32
	addupdate_by                      *int32
	create_time                       *time.Time
	update_time                       *time.Time
	delete_time                       *time.Time
	tenant_id                         *uint32
	addtenant_id                      *int32
	client_id                         *string
	description                       *string
	organization                      *string
	contact_email                     *string
	metadata                          *map[string]string
	status                            *lcmclient.Status
	clearedFields                     map[string]struct{}
	mtls_certificates                 map[uint32]struct{}
	removedmtls_certificates          map[uint32]struct{}
	clearedmtls_certificates          bool
	mtls_certificate_requests         map[uint32]struct{}
	removedmtls_certificate_requests  map[uint32]struct{}
	clearedmtls_certificate_requests  bool
	owned_issuers                     map[uint32]struct{}
	removedowned_issuers              map[uint32]struct{}
	clearedowned_issuers              bool
	certificate_requests              map[int]struct{}
	removedcertificate_requests       map[int]struct{}
	clearedcertificate_requests       bool
	issued_certificates               map[string]struct{}
	removedissued_certificates        map[string]struct{}
	clearedissued_certificates        bool
	client_issuer_associations        map[int]struct{}
	removedclient_issuer_associations map[int]struct{}
	clearedclient_issuer_associations bool
	lcm_ca                            *uint32
	clearedlcm_ca                     bool
	certificate_grants                map[uint32]struct{}
	removedcertificate_grants         map[uint32]struct{}
	clearedcertificate_grants         bool
	done                              bool
	oldValue                          func(context.Context) (*LcmClient, error)
	predicates                        []predicate.LcmClient
}

var _ ent.Mutation = (*LcmClientMutation)(nil)

// lcmclientOption allows management of the mutation configuration using functional options.
type lcmclientOption func(*LcmClientMutation)

// newLcmClientMutation creates new mutation for the LcmClient entity.
func newLcmClientMutation(c config, op Op, opts ...lcmclientOption) *LcmClientMutation {
	m := &LcmClientMutation{
		config:        c,
		op:            op,
		typ:           TypeLcmClient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLcmClientID sets the ID field of the mutation.
func withLcmClientID(id uint32) lcmclientOption {
	return func(m *LcmClientMutation) {
		var (
			err   error
			once  sync.Once
			value *LcmClient
		)
		m.oldValue = func(ctx context.Context) (*LcmClient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LcmClient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLcmClient sets the old LcmClient of the mutation.
func withLcmClient(node *LcmClient) lcmclientOption {
	return func(m *LcmClientMutation) {
		m.oldValue = func(context.Context) (*LcmClient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LcmClientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LcmClientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LcmClient entities.
func (m *LcmClientMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LcmClientMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LcmClientMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LcmClient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *LcmClientMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *LcmClientMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the LcmClient entity.
// If the LcmClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmClientMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *LcmClientMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *LcmClientMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *LcmClientMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[lcmclient.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *LcmClientMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[lcmclient.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *LcmClientMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, lcmclient.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *LcmClientMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *LcmClientMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the LcmClient entity.
// If the LcmClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmClientMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *LcmClientMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *LcmClientMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *LcmClientMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[lcmclient.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *LcmClientMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[lcmclient.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *LcmClientMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, lcmclient.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *LcmClientMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *LcmClientMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the LcmClient entity.
// If the LcmClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmClientMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *LcmClientMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[lcmclient.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *LcmClientMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[lcmclient.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *LcmClientMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, lcmclient.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *LcmClientMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *LcmClientMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the LcmClient entity.
// If the LcmClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmClientMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *LcmClientMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[lcmclient.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *LcmClientMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[lcmclient.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *LcmClientMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, lcmclient.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *LcmClientMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *LcmClientMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the LcmClient entity.
// If the LcmClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmClientMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *LcmClientMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[lcmclient.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *LcmClientMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[lcmclient.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *LcmClientMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, lcmclient.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *LcmClientMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *LcmClientMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the LcmClient entity.
// If the LcmClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmClientMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *LcmClientMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *LcmClientMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *LcmClientMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[lcmclient.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *LcmClientMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[lcmclient.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *LcmClientMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, lcmclient.FieldTenantID)
}

// SetClientID sets the "client_id" field.
func (m *LcmClientMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *LcmClientMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the LcmClient entity.
// If the LcmClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmClientMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *LcmClientMutation) ResetClientID() {
	m.client_id = nil
}

// SetDescription sets the "description" field.
func (m *LcmClientMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LcmClientMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the LcmClient entity.
// If the LcmClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmClientMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LcmClientMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[lcmclient.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LcmClientMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[lcmclient.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LcmClientMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, lcmclient.FieldDescription)
}

// SetOrganization sets the "organization" field.
func (m *LcmClientMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *LcmClientMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the LcmClient entity.
// If the LcmClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmClientMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ClearOrganization clears the value of the "organization" field.
func (m *LcmClientMutation) ClearOrganization() {
	m.organization = nil
	m.clearedFields[lcmclient.FieldOrganization] = struct{}{}
}

// OrganizationCleared returns if the "organization" field was cleared in this mutation.
func (m *LcmClientMutation) OrganizationCleared() bool {
	_, ok := m.clearedFields[lcmclient.FieldOrganization]
	return ok
}

// ResetOrganization resets all changes to the "organization" field.
func (m *LcmClientMutation) ResetOrganization() {
	m.organization = nil
	delete(m.clearedFields, lcmclient.FieldOrganization)
}

// SetContactEmail sets the "contact_email" field.
func (m *LcmClientMutation) SetContactEmail(s string) {
	m.contact_email = &s
}

// ContactEmail returns the value of the "contact_email" field in the mutation.
func (m *LcmClientMutation) ContactEmail() (r string, exists bool) {
	v := m.contact_email
	if v == nil {
		return
	}
	return *v, true
}

// OldContactEmail returns the old "contact_email" field's value of the LcmClient entity.
// If the LcmClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmClientMutation) OldContactEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactEmail: %w", err)
	}
	return oldValue.ContactEmail, nil
}

// ClearContactEmail clears the value of the "contact_email" field.
func (m *LcmClientMutation) ClearContactEmail() {
	m.contact_email = nil
	m.clearedFields[lcmclient.FieldContactEmail] = struct{}{}
}

// ContactEmailCleared returns if the "contact_email" field was cleared in this mutation.
func (m *LcmClientMutation) ContactEmailCleared() bool {
	_, ok := m.clearedFields[lcmclient.FieldContactEmail]
	return ok
}

// ResetContactEmail resets all changes to the "contact_email" field.
func (m *LcmClientMutation) ResetContactEmail() {
	m.contact_email = nil
	delete(m.clearedFields, lcmclient.FieldContactEmail)
}

// SetMetadata sets the "metadata" field.
func (m *LcmClientMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *LcmClientMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the LcmClient entity.
// If the LcmClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmClientMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *LcmClientMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[lcmclient.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *LcmClientMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[lcmclient.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *LcmClientMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, lcmclient.FieldMetadata)
}

// SetStatus sets the "status" field.
func (m *LcmClientMutation) SetStatus(l lcmclient.Status) {
	m.status = &l
}

// Status returns the value of the "status" field in the mutation.
func (m *LcmClientMutation) Status() (r lcmclient.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the LcmClient entity.
// If the LcmClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LcmClientMutation) OldStatus(ctx context.Context) (v *lcmclient.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *LcmClientMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[lcmclient.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *LcmClientMutation) StatusCleared() bool {
	_, ok := m.clearedFields[lcmclient.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *LcmClientMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, lcmclient.FieldStatus)
}

// AddMtlsCertificateIDs adds the "mtls_certificates" edge to the MtlsCertificate entity by ids.
func (m *LcmClientMutation) AddMtlsCertificateIDs(ids ...uint32) {
	if m.mtls_certificates == nil {
		m.mtls_certificates = make(map[uint32]struct{})
	}
	for i := range ids {
		m.mtls_certificates[ids[i]] = struct{}{}
	}
}

// ClearMtlsCertificates clears the "mtls_certificates" edge to the MtlsCertificate entity.
func (m *LcmClientMutation) ClearMtlsCertificates() {
	m.clearedmtls_certificates = true
}

// MtlsCertificatesCleared reports if the "mtls_certificates" edge to the MtlsCertificate entity was cleared.
func (m *LcmClientMutation) MtlsCertificatesCleared() bool {
	return m.clearedmtls_certificates
}

// RemoveMtlsCertificateIDs removes the "mtls_certificates" edge to the MtlsCertificate entity by IDs.
func (m *LcmClientMutation) RemoveMtlsCertificateIDs(ids ...uint32) {
	if m.removedmtls_certificates == nil {
		m.removedmtls_certificates = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.mtls_certificates, ids[i])
		m.removedmtls_certificates[ids[i]] = struct{}{}
	}
}

// RemovedMtlsCertificates returns the removed IDs of the "mtls_certificates" edge to the MtlsCertificate entity.
func (m *LcmClientMutation) RemovedMtlsCertificatesIDs() (ids []uint32) {
	for id := range m.removedmtls_certificates {
		ids = append(ids, id)
	}
	return
}

// MtlsCertificatesIDs returns the "mtls_certificates" edge IDs in the mutation.
func (m *LcmClientMutation) MtlsCertificatesIDs() (ids []uint32) {
	for id := range m.mtls_certificates {
		ids = append(ids, id)
	}
	return
}

// ResetMtlsCertificates resets all changes to the "mtls_certificates" edge.
func (m *LcmClientMutation) ResetMtlsCertificates() {
	m.mtls_certificates = nil
	m.clearedmtls_certificates = false
	m.removedmtls_certificates = nil
}

// AddMtlsCertificateRequestIDs adds the "mtls_certificate_requests" edge to the MtlsCertificateRequest entity by ids.
func (m *LcmClientMutation) AddMtlsCertificateRequestIDs(ids ...uint32) {
	if m.mtls_certificate_requests == nil {
		m.mtls_certificate_requests = make(map[uint32]struct{})
	}
	for i := range ids {
		m.mtls_certificate_requests[ids[i]] = struct{}{}
	}
}

// ClearMtlsCertificateRequests clears the "mtls_certificate_requests" edge to the MtlsCertificateRequest entity.
func (m *LcmClientMutation) ClearMtlsCertificateRequests() {
	m.clearedmtls_certificate_requests = true
}

// MtlsCertificateRequestsCleared reports if the "mtls_certificate_requests" edge to the MtlsCertificateRequest entity was cleared.
func (m *LcmClientMutation) MtlsCertificateRequestsCleared() bool {
	return m.clearedmtls_certificate_requests
}

// RemoveMtlsCertificateRequestIDs removes the "mtls_certificate_requests" edge to the MtlsCertificateRequest entity by IDs.
func (m *LcmClientMutation) RemoveMtlsCertificateRequestIDs(ids ...uint32) {
	if m.removedmtls_certificate_requests == nil {
		m.removedmtls_certificate_requests = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.mtls_certificate_requests, ids[i])
		m.removedmtls_certificate_requests[ids[i]] = struct{}{}
	}
}

// RemovedMtlsCertificateRequests returns the removed IDs of the "mtls_certificate_requests" edge to the MtlsCertificateRequest entity.
func (m *LcmClientMutation) RemovedMtlsCertificateRequestsIDs() (ids []uint32) {
	for id := range m.removedmtls_certificate_requests {
		ids = append(ids, id)
	}
	return
}

// MtlsCertificateRequestsIDs returns the "mtls_certificate_requests" edge IDs in the mutation.
func (m *LcmClientMutation) MtlsCertificateRequestsIDs() (ids []uint32) {
	for id := range m.mtls_certificate_requests {
		ids = append(ids, id)
	}
	return
}

// ResetMtlsCertificateRequests resets all changes to the "mtls_certificate_requests" edge.
func (m *LcmClientMutation) ResetMtlsCertificateRequests() {
	m.mtls_certificate_requests = nil
	m.clearedmtls_certificate_requests = false
	m.removedmtls_certificate_requests = nil
}

// AddOwnedIssuerIDs adds the "owned_issuers" edge to the Issuer entity by ids.
func (m *LcmClientMutation) AddOwnedIssuerIDs(ids ...uint32) {
	if m.owned_issuers == nil {
		m.owned_issuers = make(map[uint32]struct{})
	}
	for i := range ids {
		m.owned_issuers[ids[i]] = struct{}{}
	}
}

// ClearOwnedIssuers clears the "owned_issuers" edge to the Issuer entity.
func (m *LcmClientMutation) ClearOwnedIssuers() {
	m.clearedowned_issuers = true
}

// OwnedIssuersCleared reports if the "owned_issuers" edge to the Issuer entity was cleared.
func (m *LcmClientMutation) OwnedIssuersCleared() bool {
	return m.clearedowned_issuers
}

// RemoveOwnedIssuerIDs removes the "owned_issuers" edge to the Issuer entity by IDs.
func (m *LcmClientMutation) RemoveOwnedIssuerIDs(ids ...uint32) {
	if m.removedowned_issuers == nil {
		m.removedowned_issuers = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.owned_issuers, ids[i])
		m.removedowned_issuers[ids[i]] = struct{}{}
	}
}

// RemovedOwnedIssuers returns the removed IDs of the "owned_issuers" edge to the Issuer entity.
func (m *LcmClientMutation) RemovedOwnedIssuersIDs() (ids []uint32) {
	for id := range m.removedowned_issuers {
		ids = append(ids, id)
	}
	return
}

// OwnedIssuersIDs returns the "owned_issuers" edge IDs in the mutation.
func (m *LcmClientMutation) OwnedIssuersIDs() (ids []uint32) {
	for id := range m.owned_issuers {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedIssuers resets all changes to the "owned_issuers" edge.
func (m *LcmClientMutation) ResetOwnedIssuers() {
	m.owned_issuers = nil
	m.clearedowned_issuers = false
	m.removedowned_issuers = nil
}

// AddCertificateRequestIDs adds the "certificate_requests" edge to the CertificateRequest entity by ids.
func (m *LcmClientMutation) AddCertificateRequestIDs(ids ...int) {
	if m.certificate_requests == nil {
		m.certificate_requests = make(map[int]struct{})
	}
	for i := range ids {
		m.certificate_requests[ids[i]] = struct{}{}
	}
}

// ClearCertificateRequests clears the "certificate_requests" edge to the CertificateRequest entity.
func (m *LcmClientMutation) ClearCertificateRequests() {
	m.clearedcertificate_requests = true
}

// CertificateRequestsCleared reports if the "certificate_requests" edge to the CertificateRequest entity was cleared.
func (m *LcmClientMutation) CertificateRequestsCleared() bool {
	return m.clearedcertificate_requests
}

// RemoveCertificateRequestIDs removes the "certificate_requests" edge to the CertificateRequest entity by IDs.
func (m *LcmClientMutation) RemoveCertificateRequestIDs(ids ...int) {
	if m.removedcertificate_requests == nil {
		m.removedcertificate_requests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.certificate_requests, ids[i])
		m.removedcertificate_requests[ids[i]] = struct{}{}
	}
}

// RemovedCertificateRequests returns the removed IDs of the "certificate_requests" edge to the CertificateRequest entity.
func (m *LcmClientMutation) RemovedCertificateRequestsIDs() (ids []int) {
	for id := range m.removedcertificate_requests {
		ids = append(ids, id)
	}
	return
}

// CertificateRequestsIDs returns the "certificate_requests" edge IDs in the mutation.
func (m *LcmClientMutation) CertificateRequestsIDs() (ids []int) {
	for id := range m.certificate_requests {
		ids = append(ids, id)
	}
	return
}

// ResetCertificateRequests resets all changes to the "certificate_requests" edge.
func (m *LcmClientMutation) ResetCertificateRequests() {
	m.certificate_requests = nil
	m.clearedcertificate_requests = false
	m.removedcertificate_requests = nil
}

// AddIssuedCertificateIDs adds the "issued_certificates" edge to the IssuedCertificate entity by ids.
func (m *LcmClientMutation) AddIssuedCertificateIDs(ids ...string) {
	if m.issued_certificates == nil {
		m.issued_certificates = make(map[string]struct{})
	}
	for i := range ids {
		m.issued_certificates[ids[i]] = struct{}{}
	}
}

// ClearIssuedCertificates clears the "issued_certificates" edge to the IssuedCertificate entity.
func (m *LcmClientMutation) ClearIssuedCertificates() {
	m.clearedissued_certificates = true
}

// IssuedCertificatesCleared reports if the "issued_certificates" edge to the IssuedCertificate entity was cleared.
func (m *LcmClientMutation) IssuedCertificatesCleared() bool {
	return m.clearedissued_certificates
}

// RemoveIssuedCertificateIDs removes the "issued_certificates" edge to the IssuedCertificate entity by IDs.
func (m *LcmClientMutation) RemoveIssuedCertificateIDs(ids ...string) {
	if m.removedissued_certificates == nil {
		m.removedissued_certificates = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.issued_certificates, ids[i])
		m.removedissued_certificates[ids[i]] = struct{}{}
	}
}

// RemovedIssuedCertificates returns the removed IDs of the "issued_certificates" edge to the IssuedCertificate entity.
func (m *LcmClientMutation) RemovedIssuedCertificatesIDs() (ids []string) {
	for id := range m.removedissued_certificates {
		ids = append(ids, id)
	}
	return
}

// IssuedCertificatesIDs returns the "issued_certificates" edge IDs in the mutation.
func (m *LcmClientMutation) IssuedCertificatesIDs() (ids []string) {
	for id := range m.issued_certificates {
		ids = append(ids, id)
	}
	return
}

// ResetIssuedCertificates resets all changes to the "issued_certificates" edge.
func (m *LcmClientMutation) ResetIssuedCertificates() {
	m.issued_certificates = nil
	m.clearedissued_certificates = false
	m.removedissued_certificates = nil
}

// AddClientIssuerAssociationIDs adds the "client_issuer_associations" edge to the ClientIssuer entity by ids.
func (m *LcmClientMutation) AddClientIssuerAssociationIDs(ids ...int) {
	if m.client_issuer_associations == nil {
		m.client_issuer_associations = make(map[int]struct{})
	}
	for i := range ids {
		m.client_issuer_associations[ids[i]] = struct{}{}
	}
}

// ClearClientIssuerAssociations clears the "client_issuer_associations" edge to the ClientIssuer entity.
func (m *LcmClientMutation) ClearClientIssuerAssociations() {
	m.clearedclient_issuer_associations = true
}

// ClientIssuerAssociationsCleared reports if the "client_issuer_associations" edge to the ClientIssuer entity was cleared.
func (m *LcmClientMutation) ClientIssuerAssociationsCleared() bool {
	return m.clearedclient_issuer_associations
}

// RemoveClientIssuerAssociationIDs removes the "client_issuer_associations" edge to the ClientIssuer entity by IDs.
func (m *LcmClientMutation) RemoveClientIssuerAssociationIDs(ids ...int) {
	if m.removedclient_issuer_associations == nil {
		m.removedclient_issuer_associations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.client_issuer_associations, ids[i])
		m.removedclient_issuer_associations[ids[i]] = struct{}{}
	}
}

// RemovedClientIssuerAssociations returns the removed IDs of the "client_issuer_associations" edge to the ClientIssuer entity.
func (m *LcmClientMutation) RemovedClientIssuerAssociationsIDs() (ids []int) {
	for id := range m.removedclient_issuer_associations {
		ids = append(ids, id)
	}
	return
}

// ClientIssuerAssociationsIDs returns the "client_issuer_associations" edge IDs in the mutation.
func (m *LcmClientMutation) ClientIssuerAssociationsIDs() (ids []int) {
	for id := range m.client_issuer_associations {
		ids = append(ids, id)
	}
	return
}

// ResetClientIssuerAssociations resets all changes to the "client_issuer_associations" edge.
func (m *LcmClientMutation) ResetClientIssuerAssociations() {
	m.client_issuer_associations = nil
	m.clearedclient_issuer_associations = false
	m.removedclient_issuer_associations = nil
}

// SetLcmCaID sets the "lcm_ca" edge to the LcmCa entity by id.
func (m *LcmClientMutation) SetLcmCaID(id uint32) {
	m.lcm_ca = &id
}

// ClearLcmCa clears the "lcm_ca" edge to the LcmCa entity.
func (m *LcmClientMutation) ClearLcmCa() {
	m.clearedlcm_ca = true
}

// LcmCaCleared reports if the "lcm_ca" edge to the LcmCa entity was cleared.
func (m *LcmClientMutation) LcmCaCleared() bool {
	return m.clearedlcm_ca
}

// LcmCaID returns the "lcm_ca" edge ID in the mutation.
func (m *LcmClientMutation) LcmCaID() (id uint32, exists bool) {
	if m.lcm_ca != nil {
		return *m.lcm_ca, true
	}
	return
}

// LcmCaIDs returns the "lcm_ca" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LcmCaID instead. It exists only for internal usage by the builders.
func (m *LcmClientMutation) LcmCaIDs() (ids []uint32) {
	if id := m.lcm_ca; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLcmCa resets all changes to the "lcm_ca" edge.
func (m *LcmClientMutation) ResetLcmCa() {
	m.lcm_ca = nil
	m.clearedlcm_ca = false
}

// AddCertificateGrantIDs adds the "certificate_grants" edge to the CertificatePermission entity by ids.
func (m *LcmClientMutation) AddCertificateGrantIDs(ids ...uint32) {
	if m.certificate_grants == nil {
		m.certificate_grants = make(map[uint32]struct{})
	}
	for i := range ids {
		m.certificate_grants[ids[i]] = struct{}{}
	}
}

// ClearCertificateGrants clears the "certificate_grants" edge to the CertificatePermission entity.
func (m *LcmClientMutation) ClearCertificateGrants() {
	m.clearedcertificate_grants = true
}

// CertificateGrantsCleared reports if the "certificate_grants" edge to the CertificatePermission entity was cleared.
func (m *LcmClientMutation) CertificateGrantsCleared() bool {
	return m.clearedcertificate_grants
}

// RemoveCertificateGrantIDs removes the "certificate_grants" edge to the CertificatePermission entity by IDs.
func (m *LcmClientMutation) RemoveCertificateGrantIDs(ids ...uint32) {
	if m.removedcertificate_grants == nil {
		m.removedcertificate_grants = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.certificate_grants, ids[i])
		m.removedcertificate_grants[ids[i]] = struct{}{}
	}
}

// RemovedCertificateGrants returns the removed IDs of the "certificate_grants" edge to the CertificatePermission entity.
func (m *LcmClientMutation) RemovedCertificateGrantsIDs() (ids []uint32) {
	for id := range m.removedcertificate_grants {
		ids = append(ids, id)
	}
	return
}

// CertificateGrantsIDs returns the "certificate_grants" edge IDs in the mutation.
func (m *LcmClientMutation) CertificateGrantsIDs() (ids []uint32) {
	for id := range m.certificate_grants {
		ids = append(ids, id)
	}
	return
}

// ResetCertificateGrants resets all changes to the "certificate_grants" edge.
func (m *LcmClientMutation) ResetCertificateGrants() {
	m.certificate_grants = nil
	m.clearedcertificate_grants = false
	m.removedcertificate_grants = nil
}

// Where appends a list predicates to the LcmClientMutation builder.
func (m *LcmClientMutation) Where(ps ...predicate.LcmClient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LcmClientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LcmClientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LcmClient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LcmClientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LcmClientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LcmClient).
func (m *LcmClientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LcmClientMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_by != nil {
		fields = append(fields, lcmclient.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, lcmclient.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, lcmclient.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, lcmclient.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, lcmclient.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, lcmclient.FieldTenantID)
	}
	if m.client_id != nil {
		fields = append(fields, lcmclient.FieldClientID)
	}
	if m.description != nil {
		fields = append(fields, lcmclient.FieldDescription)
	}
	if m.organization != nil {
		fields = append(fields, lcmclient.FieldOrganization)
	}
	if m.contact_email != nil {
		fields = append(fields, lcmclient.FieldContactEmail)
	}
	if m.metadata != nil {
		fields = append(fields, lcmclient.FieldMetadata)
	}
	if m.status != nil {
		fields = append(fields, lcmclient.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LcmClientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lcmclient.FieldCreateBy:
		return m.CreateBy()
	case lcmclient.FieldUpdateBy:
		return m.UpdateBy()
	case lcmclient.FieldCreateTime:
		return m.CreateTime()
	case lcmclient.FieldUpdateTime:
		return m.UpdateTime()
	case lcmclient.FieldDeleteTime:
		return m.DeleteTime()
	case lcmclient.FieldTenantID:
		return m.TenantID()
	case lcmclient.FieldClientID:
		return m.ClientID()
	case lcmclient.FieldDescription:
		return m.Description()
	case lcmclient.FieldOrganization:
		return m.Organization()
	case lcmclient.FieldContactEmail:
		return m.ContactEmail()
	case lcmclient.FieldMetadata:
		return m.Metadata()
	case lcmclient.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LcmClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lcmclient.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case lcmclient.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case lcmclient.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case lcmclient.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case lcmclient.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case lcmclient.FieldTenantID:
		return m.OldTenantID(ctx)
	case lcmclient.FieldClientID:
		return m.OldClientID(ctx)
	case lcmclient.FieldDescription:
		return m.OldDescription(ctx)
	case lcmclient.FieldOrganization:
		return m.OldOrganization(ctx)
	case lcmclient.FieldContactEmail:
		return m.OldContactEmail(ctx)
	case lcmclient.FieldMetadata:
		return m.OldMetadata(ctx)
	case lcmclient.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown LcmClient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LcmClientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lcmclient.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case lcmclient.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case lcmclient.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case lcmclient.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case lcmclient.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case lcmclient.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case lcmclient.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case lcmclient.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case lcmclient.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case lcmclient.FieldContactEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactEmail(v)
		return nil
	case lcmclient.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case lcmclient.FieldStatus:
		v, ok := value.(lcmclient.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown LcmClient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LcmClientMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, lcmclient.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, lcmclient.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, lcmclient.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LcmClientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lcmclient.FieldCreateBy:
		return m.AddedCreateBy()
	case lcmclient.FieldUpdateBy:
		return m.AddedUpdateBy()
	case lcmclient.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LcmClientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lcmclient.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case lcmclient.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case lcmclient.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown LcmClient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LcmClientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lcmclient.FieldCreateBy) {
		fields = append(fields, lcmclient.FieldCreateBy)
	}
	if m.FieldCleared(lcmclient.FieldUpdateBy) {
		fields = append(fields, lcmclient.FieldUpdateBy)
	}
	if m.FieldCleared(lcmclient.FieldCreateTime) {
		fields = append(fields, lcmclient.FieldCreateTime)
	}
	if m.FieldCleared(lcmclient.FieldUpdateTime) {
		fields = append(fields, lcmclient.FieldUpdateTime)
	}
	if m.FieldCleared(lcmclient.FieldDeleteTime) {
		fields = append(fields, lcmclient.FieldDeleteTime)
	}
	if m.FieldCleared(lcmclient.FieldTenantID) {
		fields = append(fields, lcmclient.FieldTenantID)
	}
	if m.FieldCleared(lcmclient.FieldDescription) {
		fields = append(fields, lcmclient.FieldDescription)
	}
	if m.FieldCleared(lcmclient.FieldOrganization) {
		fields = append(fields, lcmclient.FieldOrganization)
	}
	if m.FieldCleared(lcmclient.FieldContactEmail) {
		fields = append(fields, lcmclient.FieldContactEmail)
	}
	if m.FieldCleared(lcmclient.FieldMetadata) {
		fields = append(fields, lcmclient.FieldMetadata)
	}
	if m.FieldCleared(lcmclient.FieldStatus) {
		fields = append(fields, lcmclient.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LcmClientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LcmClientMutation) ClearField(name string) error {
	switch name {
	case lcmclient.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case lcmclient.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case lcmclient.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case lcmclient.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case lcmclient.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case lcmclient.FieldTenantID:
		m.ClearTenantID()
		return nil
	case lcmclient.FieldDescription:
		m.ClearDescription()
		return nil
	case lcmclient.FieldOrganization:
		m.ClearOrganization()
		return nil
	case lcmclient.FieldContactEmail:
		m.ClearContactEmail()
		return nil
	case lcmclient.FieldMetadata:
		m.ClearMetadata()
		return nil
	case lcmclient.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown LcmClient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LcmClientMutation) ResetField(name string) error {
	switch name {
	case lcmclient.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case lcmclient.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case lcmclient.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case lcmclient.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case lcmclient.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case lcmclient.FieldTenantID:
		m.ResetTenantID()
		return nil
	case lcmclient.FieldClientID:
		m.ResetClientID()
		return nil
	case lcmclient.FieldDescription:
		m.ResetDescription()
		return nil
	case lcmclient.FieldOrganization:
		m.ResetOrganization()
		return nil
	case lcmclient.FieldContactEmail:
		m.ResetContactEmail()
		return nil
	case lcmclient.FieldMetadata:
		m.ResetMetadata()
		return nil
	case lcmclient.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown LcmClient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LcmClientMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.mtls_certificates != nil {
		edges = append(edges, lcmclient.EdgeMtlsCertificates)
	}
	if m.mtls_certificate_requests != nil {
		edges = append(edges, lcmclient.EdgeMtlsCertificateRequests)
	}
	if m.owned_issuers != nil {
		edges = append(edges, lcmclient.EdgeOwnedIssuers)
	}
	if m.certificate_requests != nil {
		edges = append(edges, lcmclient.EdgeCertificateRequests)
	}
	if m.issued_certificates != nil {
		edges = append(edges, lcmclient.EdgeIssuedCertificates)
	}
	if m.client_issuer_associations != nil {
		edges = append(edges, lcmclient.EdgeClientIssuerAssociations)
	}
	if m.lcm_ca != nil {
		edges = append(edges, lcmclient.EdgeLcmCa)
	}
	if m.certificate_grants != nil {
		edges = append(edges, lcmclient.EdgeCertificateGrants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LcmClientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lcmclient.EdgeMtlsCertificates:
		ids := make([]ent.Value, 0, len(m.mtls_certificates))
		for id := range m.mtls_certificates {
			ids = append(ids, id)
		}
		return ids
	case lcmclient.EdgeMtlsCertificateRequests:
		ids := make([]ent.Value, 0, len(m.mtls_certificate_requests))
		for id := range m.mtls_certificate_requests {
			ids = append(ids, id)
		}
		return ids
	case lcmclient.EdgeOwnedIssuers:
		ids := make([]ent.Value, 0, len(m.owned_issuers))
		for id := range m.owned_issuers {
			ids = append(ids, id)
		}
		return ids
	case lcmclient.EdgeCertificateRequests:
		ids := make([]ent.Value, 0, len(m.certificate_requests))
		for id := range m.certificate_requests {
			ids = append(ids, id)
		}
		return ids
	case lcmclient.EdgeIssuedCertificates:
		ids := make([]ent.Value, 0, len(m.issued_certificates))
		for id := range m.issued_certificates {
			ids = append(ids, id)
		}
		return ids
	case lcmclient.EdgeClientIssuerAssociations:
		ids := make([]ent.Value, 0, len(m.client_issuer_associations))
		for id := range m.client_issuer_associations {
			ids = append(ids, id)
		}
		return ids
	case lcmclient.EdgeLcmCa:
		if id := m.lcm_ca; id != nil {
			return []ent.Value{*id}
		}
	case lcmclient.EdgeCertificateGrants:
		ids := make([]ent.Value, 0, len(m.certificate_grants))
		for id := range m.certificate_grants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LcmClientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedmtls_certificates != nil {
		edges = append(edges, lcmclient.EdgeMtlsCertificates)
	}
	if m.removedmtls_certificate_requests != nil {
		edges = append(edges, lcmclient.EdgeMtlsCertificateRequests)
	}
	if m.removedowned_issuers != nil {
		edges = append(edges, lcmclient.EdgeOwnedIssuers)
	}
	if m.removedcertificate_requests != nil {
		edges = append(edges, lcmclient.EdgeCertificateRequests)
	}
	if m.removedissued_certificates != nil {
		edges = append(edges, lcmclient.EdgeIssuedCertificates)
	}
	if m.removedclient_issuer_associations != nil {
		edges = append(edges, lcmclient.EdgeClientIssuerAssociations)
	}
	if m.removedcertificate_grants != nil {
		edges = append(edges, lcmclient.EdgeCertificateGrants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LcmClientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lcmclient.EdgeMtlsCertificates:
		ids := make([]ent.Value, 0, len(m.removedmtls_certificates))
		for id := range m.removedmtls_certificates {
			ids = append(ids, id)
		}
		return ids
	case lcmclient.EdgeMtlsCertificateRequests:
		ids := make([]ent.Value, 0, len(m.removedmtls_certificate_requests))
		for id := range m.removedmtls_certificate_requests {
			ids = append(ids, id)
		}
		return ids
	case lcmclient.EdgeOwnedIssuers:
		ids := make([]ent.Value, 0, len(m.removedowned_issuers))
		for id := range m.removedowned_issuers {
			ids = append(ids, id)
		}
		return ids
	case lcmclient.EdgeCertificateRequests:
		ids := make([]ent.Value, 0, len(m.removedcertificate_requests))
		for id := range m.removedcertificate_requests {
			ids = append(ids, id)
		}
		return ids
	case lcmclient.EdgeIssuedCertificates:
		ids := make([]ent.Value, 0, len(m.removedissued_certificates))
		for id := range m.removedissued_certificates {
			ids = append(ids, id)
		}
		return ids
	case lcmclient.EdgeClientIssuerAssociations:
		ids := make([]ent.Value, 0, len(m.removedclient_issuer_associations))
		for id := range m.removedclient_issuer_associations {
			ids = append(ids, id)
		}
		return ids
	case lcmclient.EdgeCertificateGrants:
		ids := make([]ent.Value, 0, len(m.removedcertificate_grants))
		for id := range m.removedcertificate_grants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LcmClientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedmtls_certificates {
		edges = append(edges, lcmclient.EdgeMtlsCertificates)
	}
	if m.clearedmtls_certificate_requests {
		edges = append(edges, lcmclient.EdgeMtlsCertificateRequests)
	}
	if m.clearedowned_issuers {
		edges = append(edges, lcmclient.EdgeOwnedIssuers)
	}
	if m.clearedcertificate_requests {
		edges = append(edges, lcmclient.EdgeCertificateRequests)
	}
	if m.clearedissued_certificates {
		edges = append(edges, lcmclient.EdgeIssuedCertificates)
	}
	if m.clearedclient_issuer_associations {
		edges = append(edges, lcmclient.EdgeClientIssuerAssociations)
	}
	if m.clearedlcm_ca {
		edges = append(edges, lcmclient.EdgeLcmCa)
	}
	if m.clearedcertificate_grants {
		edges = append(edges, lcmclient.EdgeCertificateGrants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LcmClientMutation) EdgeCleared(name string) bool {
	switch name {
	case lcmclient.EdgeMtlsCertificates:
		return m.clearedmtls_certificates
	case lcmclient.EdgeMtlsCertificateRequests:
		return m.clearedmtls_certificate_requests
	case lcmclient.EdgeOwnedIssuers:
		return m.clearedowned_issuers
	case lcmclient.EdgeCertificateRequests:
		return m.clearedcertificate_requests
	case lcmclient.EdgeIssuedCertificates:
		return m.clearedissued_certificates
	case lcmclient.EdgeClientIssuerAssociations:
		return m.clearedclient_issuer_associations
	case lcmclient.EdgeLcmCa:
		return m.clearedlcm_ca
	case lcmclient.EdgeCertificateGrants:
		return m.clearedcertificate_grants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LcmClientMutation) ClearEdge(name string) error {
	switch name {
	case lcmclient.EdgeLcmCa:
		m.ClearLcmCa()
		return nil
	}
	return fmt.Errorf("unknown LcmClient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LcmClientMutation) ResetEdge(name string) error {
	switch name {
	case lcmclient.EdgeMtlsCertificates:
		m.ResetMtlsCertificates()
		return nil
	case lcmclient.EdgeMtlsCertificateRequests:
		m.ResetMtlsCertificateRequests()
		return nil
	case lcmclient.EdgeOwnedIssuers:
		m.ResetOwnedIssuers()
		return nil
	case lcmclient.EdgeCertificateRequests:
		m.ResetCertificateRequests()
		return nil
	case lcmclient.EdgeIssuedCertificates:
		m.ResetIssuedCertificates()
		return nil
	case lcmclient.EdgeClientIssuerAssociations:
		m.ResetClientIssuerAssociations()
		return nil
	case lcmclient.EdgeLcmCa:
		m.ResetLcmCa()
		return nil
	case lcmclient.EdgeCertificateGrants:
		m.ResetCertificateGrants()
		return nil
	}
	return fmt.Errorf("unknown LcmClient edge %s", name)
}

// MtlsCertificateMutation represents an operation that mutates the MtlsCertificate nodes in the graph.
type MtlsCertificateMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint32
	create_by              *uint32
	addcreate_by           *int32
	update_by              *uint32
	addupdate_by           *int32
	create_time            *time.Time
	update_time            *time.Time
	delete_time            *time.Time
	tenant_id              *uint32
	addtenant_id           *int32
	serial_number          *int64
	addserial_number       *int64
	client_id              *string
	common_name            *string
	subject_dn             *string
	issuer_dn              *string
	issuer_name            *string
	fingerprint_sha256     *string
	fingerprint_sha1       *string
	public_key_algorithm   *string
	public_key_size        *int32
	addpublic_key_size     *int32
	signature_algorithm    *string
	certificate_pem        *string
	public_key_pem         *string
	dns_names              *[]string
	appenddns_names        []string
	ip_addresses           *[]string
	appendip_addresses     []string
	email_addresses        *[]string
	appendemail_addresses  []string
	uris                   *[]string
	appenduris             []string
	cert_type              *mtlscertificate.CertType
	status                 *mtlscertificate.Status
	is_ca                  *bool
	path_len_constraint    *int32
	addpath_len_constraint *int32
	key_usage              *[]string
	appendkey_usage        []string
	ext_key_usage          *[]string
	appendext_key_usage    []string
	metadata               *map[string]string
	notes                  *string
	request_id             *uint32
	addrequest_id          *int32
	revocation_reason      *mtlscertificate.RevocationReason
	revocation_notes       *string
	issued_by              *uint32
	addissued_by           *int32
	revoked_by             *uint32
	addrevoked_by          *int32
	not_before             *time.Time
	not_after              *time.Time
	issued_at              *time.Time
	revoked_at             *time.Time
	last_seen_at           *time.Time
	clearedFields          map[string]struct{}
	lcm_client             *uint32
	clearedlcm_client      bool
	done                   bool
	oldValue               func(context.Context) (*MtlsCertificate, error)
	predicates             []predicate.MtlsCertificate
}

var _ ent.Mutation = (*MtlsCertificateMutation)(nil)

// mtlscertificateOption allows management of the mutation configuration using functional options.
type mtlscertificateOption func(*MtlsCertificateMutation)

// newMtlsCertificateMutation creates new mutation for the MtlsCertificate entity.
func newMtlsCertificateMutation(c config, op Op, opts ...mtlscertificateOption) *MtlsCertificateMutation {
	m := &MtlsCertificateMutation{
		config:        c,
		op:            op,
		typ:           TypeMtlsCertificate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMtlsCertificateID sets the ID field of the mutation.
func withMtlsCertificateID(id uint32) mtlscertificateOption {
	return func(m *MtlsCertificateMutation) {
		var (
			err   error
			once  sync.Once
			value *MtlsCertificate
		)
		m.oldValue = func(ctx context.Context) (*MtlsCertificate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MtlsCertificate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMtlsCertificate sets the old MtlsCertificate of the mutation.
func withMtlsCertificate(node *MtlsCertificate) mtlscertificateOption {
	return func(m *MtlsCertificateMutation) {
		m.oldValue = func(context.Context) (*MtlsCertificate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MtlsCertificateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MtlsCertificateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MtlsCertificate entities.
func (m *MtlsCertificateMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MtlsCertificateMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MtlsCertificateMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MtlsCertificate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *MtlsCertificateMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *MtlsCertificateMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *MtlsCertificateMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *MtlsCertificateMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *MtlsCertificateMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[mtlscertificate.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *MtlsCertificateMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *MtlsCertificateMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, mtlscertificate.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *MtlsCertificateMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *MtlsCertificateMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *MtlsCertificateMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *MtlsCertificateMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *MtlsCertificateMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[mtlscertificate.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *MtlsCertificateMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *MtlsCertificateMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, mtlscertificate.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *MtlsCertificateMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MtlsCertificateMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *MtlsCertificateMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[mtlscertificate.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *MtlsCertificateMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MtlsCertificateMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, mtlscertificate.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *MtlsCertificateMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MtlsCertificateMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *MtlsCertificateMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[mtlscertificate.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *MtlsCertificateMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MtlsCertificateMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, mtlscertificate.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *MtlsCertificateMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *MtlsCertificateMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *MtlsCertificateMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[mtlscertificate.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *MtlsCertificateMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *MtlsCertificateMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, mtlscertificate.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *MtlsCertificateMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *MtlsCertificateMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *MtlsCertificateMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *MtlsCertificateMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *MtlsCertificateMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[mtlscertificate.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *MtlsCertificateMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *MtlsCertificateMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, mtlscertificate.FieldTenantID)
}

// SetSerialNumber sets the "serial_number" field.
func (m *MtlsCertificateMutation) SetSerialNumber(i int64) {
	m.serial_number = &i
	m.addserial_number = nil
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *MtlsCertificateMutation) SerialNumber() (r int64, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldSerialNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// AddSerialNumber adds i to the "serial_number" field.
func (m *MtlsCertificateMutation) AddSerialNumber(i int64) {
	if m.addserial_number != nil {
		*m.addserial_number += i
	} else {
		m.addserial_number = &i
	}
}

// AddedSerialNumber returns the value that was added to the "serial_number" field in this mutation.
func (m *MtlsCertificateMutation) AddedSerialNumber() (r int64, exists bool) {
	v := m.addserial_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *MtlsCertificateMutation) ResetSerialNumber() {
	m.serial_number = nil
	m.addserial_number = nil
}

// SetClientID sets the "client_id" field.
func (m *MtlsCertificateMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *MtlsCertificateMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *MtlsCertificateMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[mtlscertificate.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *MtlsCertificateMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *MtlsCertificateMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, mtlscertificate.FieldClientID)
}

// SetCommonName sets the "common_name" field.
func (m *MtlsCertificateMutation) SetCommonName(s string) {
	m.common_name = &s
}

// CommonName returns the value of the "common_name" field in the mutation.
func (m *MtlsCertificateMutation) CommonName() (r string, exists bool) {
	v := m.common_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCommonName returns the old "common_name" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldCommonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommonName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommonName: %w", err)
	}
	return oldValue.CommonName, nil
}

// ClearCommonName clears the value of the "common_name" field.
func (m *MtlsCertificateMutation) ClearCommonName() {
	m.common_name = nil
	m.clearedFields[mtlscertificate.FieldCommonName] = struct{}{}
}

// CommonNameCleared returns if the "common_name" field was cleared in this mutation.
func (m *MtlsCertificateMutation) CommonNameCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldCommonName]
	return ok
}

// ResetCommonName resets all changes to the "common_name" field.
func (m *MtlsCertificateMutation) ResetCommonName() {
	m.common_name = nil
	delete(m.clearedFields, mtlscertificate.FieldCommonName)
}

// SetSubjectDn sets the "subject_dn" field.
func (m *MtlsCertificateMutation) SetSubjectDn(s string) {
	m.subject_dn = &s
}

// SubjectDn returns the value of the "subject_dn" field in the mutation.
func (m *MtlsCertificateMutation) SubjectDn() (r string, exists bool) {
	v := m.subject_dn
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectDn returns the old "subject_dn" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldSubjectDn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectDn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectDn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectDn: %w", err)
	}
	return oldValue.SubjectDn, nil
}

// ClearSubjectDn clears the value of the "subject_dn" field.
func (m *MtlsCertificateMutation) ClearSubjectDn() {
	m.subject_dn = nil
	m.clearedFields[mtlscertificate.FieldSubjectDn] = struct{}{}
}

// SubjectDnCleared returns if the "subject_dn" field was cleared in this mutation.
func (m *MtlsCertificateMutation) SubjectDnCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldSubjectDn]
	return ok
}

// ResetSubjectDn resets all changes to the "subject_dn" field.
func (m *MtlsCertificateMutation) ResetSubjectDn() {
	m.subject_dn = nil
	delete(m.clearedFields, mtlscertificate.FieldSubjectDn)
}

// SetIssuerDn sets the "issuer_dn" field.
func (m *MtlsCertificateMutation) SetIssuerDn(s string) {
	m.issuer_dn = &s
}

// IssuerDn returns the value of the "issuer_dn" field in the mutation.
func (m *MtlsCertificateMutation) IssuerDn() (r string, exists bool) {
	v := m.issuer_dn
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerDn returns the old "issuer_dn" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldIssuerDn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerDn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerDn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerDn: %w", err)
	}
	return oldValue.IssuerDn, nil
}

// ClearIssuerDn clears the value of the "issuer_dn" field.
func (m *MtlsCertificateMutation) ClearIssuerDn() {
	m.issuer_dn = nil
	m.clearedFields[mtlscertificate.FieldIssuerDn] = struct{}{}
}

// IssuerDnCleared returns if the "issuer_dn" field was cleared in this mutation.
func (m *MtlsCertificateMutation) IssuerDnCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldIssuerDn]
	return ok
}

// ResetIssuerDn resets all changes to the "issuer_dn" field.
func (m *MtlsCertificateMutation) ResetIssuerDn() {
	m.issuer_dn = nil
	delete(m.clearedFields, mtlscertificate.FieldIssuerDn)
}

// SetIssuerName sets the "issuer_name" field.
func (m *MtlsCertificateMutation) SetIssuerName(s string) {
	m.issuer_name = &s
}

// IssuerName returns the value of the "issuer_name" field in the mutation.
func (m *MtlsCertificateMutation) IssuerName() (r string, exists bool) {
	v := m.issuer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerName returns the old "issuer_name" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldIssuerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerName: %w", err)
	}
	return oldValue.IssuerName, nil
}

// ClearIssuerName clears the value of the "issuer_name" field.
func (m *MtlsCertificateMutation) ClearIssuerName() {
	m.issuer_name = nil
	m.clearedFields[mtlscertificate.FieldIssuerName] = struct{}{}
}

// IssuerNameCleared returns if the "issuer_name" field was cleared in this mutation.
func (m *MtlsCertificateMutation) IssuerNameCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldIssuerName]
	return ok
}

// ResetIssuerName resets all changes to the "issuer_name" field.
func (m *MtlsCertificateMutation) ResetIssuerName() {
	m.issuer_name = nil
	delete(m.clearedFields, mtlscertificate.FieldIssuerName)
}

// SetFingerprintSha256 sets the "fingerprint_sha256" field.
func (m *MtlsCertificateMutation) SetFingerprintSha256(s string) {
	m.fingerprint_sha256 = &s
}

// FingerprintSha256 returns the value of the "fingerprint_sha256" field in the mutation.
func (m *MtlsCertificateMutation) FingerprintSha256() (r string, exists bool) {
	v := m.fingerprint_sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldFingerprintSha256 returns the old "fingerprint_sha256" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldFingerprintSha256(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFingerprintSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFingerprintSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFingerprintSha256: %w", err)
	}
	return oldValue.FingerprintSha256, nil
}

// ClearFingerprintSha256 clears the value of the "fingerprint_sha256" field.
func (m *MtlsCertificateMutation) ClearFingerprintSha256() {
	m.fingerprint_sha256 = nil
	m.clearedFields[mtlscertificate.FieldFingerprintSha256] = struct{}{}
}

// FingerprintSha256Cleared returns if the "fingerprint_sha256" field was cleared in this mutation.
func (m *MtlsCertificateMutation) FingerprintSha256Cleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldFingerprintSha256]
	return ok
}

// ResetFingerprintSha256 resets all changes to the "fingerprint_sha256" field.
func (m *MtlsCertificateMutation) ResetFingerprintSha256() {
	m.fingerprint_sha256 = nil
	delete(m.clearedFields, mtlscertificate.FieldFingerprintSha256)
}

// SetFingerprintSha1 sets the "fingerprint_sha1" field.
func (m *MtlsCertificateMutation) SetFingerprintSha1(s string) {
	m.fingerprint_sha1 = &s
}

// FingerprintSha1 returns the value of the "fingerprint_sha1" field in the mutation.
func (m *MtlsCertificateMutation) FingerprintSha1() (r string, exists bool) {
	v := m.fingerprint_sha1
	if v == nil {
		return
	}
	return *v, true
}

// OldFingerprintSha1 returns the old "fingerprint_sha1" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldFingerprintSha1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFingerprintSha1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFingerprintSha1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFingerprintSha1: %w", err)
	}
	return oldValue.FingerprintSha1, nil
}

// ClearFingerprintSha1 clears the value of the "fingerprint_sha1" field.
func (m *MtlsCertificateMutation) ClearFingerprintSha1() {
	m.fingerprint_sha1 = nil
	m.clearedFields[mtlscertificate.FieldFingerprintSha1] = struct{}{}
}

// FingerprintSha1Cleared returns if the "fingerprint_sha1" field was cleared in this mutation.
func (m *MtlsCertificateMutation) FingerprintSha1Cleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldFingerprintSha1]
	return ok
}

// ResetFingerprintSha1 resets all changes to the "fingerprint_sha1" field.
func (m *MtlsCertificateMutation) ResetFingerprintSha1() {
	m.fingerprint_sha1 = nil
	delete(m.clearedFields, mtlscertificate.FieldFingerprintSha1)
}

// SetPublicKeyAlgorithm sets the "public_key_algorithm" field.
func (m *MtlsCertificateMutation) SetPublicKeyAlgorithm(s string) {
	m.public_key_algorithm = &s
}

// PublicKeyAlgorithm returns the value of the "public_key_algorithm" field in the mutation.
func (m *MtlsCertificateMutation) PublicKeyAlgorithm() (r string, exists bool) {
	v := m.public_key_algorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKeyAlgorithm returns the old "public_key_algorithm" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldPublicKeyAlgorithm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKeyAlgorithm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKeyAlgorithm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKeyAlgorithm: %w", err)
	}
	return oldValue.PublicKeyAlgorithm, nil
}

// ClearPublicKeyAlgorithm clears the value of the "public_key_algorithm" field.
func (m *MtlsCertificateMutation) ClearPublicKeyAlgorithm() {
	m.public_key_algorithm = nil
	m.clearedFields[mtlscertificate.FieldPublicKeyAlgorithm] = struct{}{}
}

// PublicKeyAlgorithmCleared returns if the "public_key_algorithm" field was cleared in this mutation.
func (m *MtlsCertificateMutation) PublicKeyAlgorithmCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldPublicKeyAlgorithm]
	return ok
}

// ResetPublicKeyAlgorithm resets all changes to the "public_key_algorithm" field.
func (m *MtlsCertificateMutation) ResetPublicKeyAlgorithm() {
	m.public_key_algorithm = nil
	delete(m.clearedFields, mtlscertificate.FieldPublicKeyAlgorithm)
}

// SetPublicKeySize sets the "public_key_size" field.
func (m *MtlsCertificateMutation) SetPublicKeySize(i int32) {
	m.public_key_size = &i
	m.addpublic_key_size = nil
}

// PublicKeySize returns the value of the "public_key_size" field in the mutation.
func (m *MtlsCertificateMutation) PublicKeySize() (r int32, exists bool) {
	v := m.public_key_size
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKeySize returns the old "public_key_size" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldPublicKeySize(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKeySize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKeySize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKeySize: %w", err)
	}
	return oldValue.PublicKeySize, nil
}

// AddPublicKeySize adds i to the "public_key_size" field.
func (m *MtlsCertificateMutation) AddPublicKeySize(i int32) {
	if m.addpublic_key_size != nil {
		*m.addpublic_key_size += i
	} else {
		m.addpublic_key_size = &i
	}
}

// AddedPublicKeySize returns the value that was added to the "public_key_size" field in this mutation.
func (m *MtlsCertificateMutation) AddedPublicKeySize() (r int32, exists bool) {
	v := m.addpublic_key_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearPublicKeySize clears the value of the "public_key_size" field.
func (m *MtlsCertificateMutation) ClearPublicKeySize() {
	m.public_key_size = nil
	m.addpublic_key_size = nil
	m.clearedFields[mtlscertificate.FieldPublicKeySize] = struct{}{}
}

// PublicKeySizeCleared returns if the "public_key_size" field was cleared in this mutation.
func (m *MtlsCertificateMutation) PublicKeySizeCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldPublicKeySize]
	return ok
}

// ResetPublicKeySize resets all changes to the "public_key_size" field.
func (m *MtlsCertificateMutation) ResetPublicKeySize() {
	m.public_key_size = nil
	m.addpublic_key_size = nil
	delete(m.clearedFields, mtlscertificate.FieldPublicKeySize)
}

// SetSignatureAlgorithm sets the "signature_algorithm" field.
func (m *MtlsCertificateMutation) SetSignatureAlgorithm(s string) {
	m.signature_algorithm = &s
}

// SignatureAlgorithm returns the value of the "signature_algorithm" field in the mutation.
func (m *MtlsCertificateMutation) SignatureAlgorithm() (r string, exists bool) {
	v := m.signature_algorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldSignatureAlgorithm returns the old "signature_algorithm" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldSignatureAlgorithm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignatureAlgorithm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignatureAlgorithm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignatureAlgorithm: %w", err)
	}
	return oldValue.SignatureAlgorithm, nil
}

// ClearSignatureAlgorithm clears the value of the "signature_algorithm" field.
func (m *MtlsCertificateMutation) ClearSignatureAlgorithm() {
	m.signature_algorithm = nil
	m.clearedFields[mtlscertificate.FieldSignatureAlgorithm] = struct{}{}
}

// SignatureAlgorithmCleared returns if the "signature_algorithm" field was cleared in this mutation.
func (m *MtlsCertificateMutation) SignatureAlgorithmCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldSignatureAlgorithm]
	return ok
}

// ResetSignatureAlgorithm resets all changes to the "signature_algorithm" field.
func (m *MtlsCertificateMutation) ResetSignatureAlgorithm() {
	m.signature_algorithm = nil
	delete(m.clearedFields, mtlscertificate.FieldSignatureAlgorithm)
}

// SetCertificatePem sets the "certificate_pem" field.
func (m *MtlsCertificateMutation) SetCertificatePem(s string) {
	m.certificate_pem = &s
}

// CertificatePem returns the value of the "certificate_pem" field in the mutation.
func (m *MtlsCertificateMutation) CertificatePem() (r string, exists bool) {
	v := m.certificate_pem
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificatePem returns the old "certificate_pem" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldCertificatePem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificatePem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificatePem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificatePem: %w", err)
	}
	return oldValue.CertificatePem, nil
}

// ClearCertificatePem clears the value of the "certificate_pem" field.
func (m *MtlsCertificateMutation) ClearCertificatePem() {
	m.certificate_pem = nil
	m.clearedFields[mtlscertificate.FieldCertificatePem] = struct{}{}
}

// CertificatePemCleared returns if the "certificate_pem" field was cleared in this mutation.
func (m *MtlsCertificateMutation) CertificatePemCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldCertificatePem]
	return ok
}

// ResetCertificatePem resets all changes to the "certificate_pem" field.
func (m *MtlsCertificateMutation) ResetCertificatePem() {
	m.certificate_pem = nil
	delete(m.clearedFields, mtlscertificate.FieldCertificatePem)
}

// SetPublicKeyPem sets the "public_key_pem" field.
func (m *MtlsCertificateMutation) SetPublicKeyPem(s string) {
	m.public_key_pem = &s
}

// PublicKeyPem returns the value of the "public_key_pem" field in the mutation.
func (m *MtlsCertificateMutation) PublicKeyPem() (r string, exists bool) {
	v := m.public_key_pem
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKeyPem returns the old "public_key_pem" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldPublicKeyPem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKeyPem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKeyPem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKeyPem: %w", err)
	}
	return oldValue.PublicKeyPem, nil
}

// ClearPublicKeyPem clears the value of the "public_key_pem" field.
func (m *MtlsCertificateMutation) ClearPublicKeyPem() {
	m.public_key_pem = nil
	m.clearedFields[mtlscertificate.FieldPublicKeyPem] = struct{}{}
}

// PublicKeyPemCleared returns if the "public_key_pem" field was cleared in this mutation.
func (m *MtlsCertificateMutation) PublicKeyPemCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldPublicKeyPem]
	return ok
}

// ResetPublicKeyPem resets all changes to the "public_key_pem" field.
func (m *MtlsCertificateMutation) ResetPublicKeyPem() {
	m.public_key_pem = nil
	delete(m.clearedFields, mtlscertificate.FieldPublicKeyPem)
}

// SetDNSNames sets the "dns_names" field.
func (m *MtlsCertificateMutation) SetDNSNames(s []string) {
	m.dns_names = &s
	m.appenddns_names = nil
}

// DNSNames returns the value of the "dns_names" field in the mutation.
func (m *MtlsCertificateMutation) DNSNames() (r []string, exists bool) {
	v := m.dns_names
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSNames returns the old "dns_names" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldDNSNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSNames: %w", err)
	}
	return oldValue.DNSNames, nil
}

// AppendDNSNames adds s to the "dns_names" field.
func (m *MtlsCertificateMutation) AppendDNSNames(s []string) {
	m.appenddns_names = append(m.appenddns_names, s...)
}

// AppendedDNSNames returns the list of values that were appended to the "dns_names" field in this mutation.
func (m *MtlsCertificateMutation) AppendedDNSNames() ([]string, bool) {
	if len(m.appenddns_names) == 0 {
		return nil, false
	}
	return m.appenddns_names, true
}

// ClearDNSNames clears the value of the "dns_names" field.
func (m *MtlsCertificateMutation) ClearDNSNames() {
	m.dns_names = nil
	m.appenddns_names = nil
	m.clearedFields[mtlscertificate.FieldDNSNames] = struct{}{}
}

// DNSNamesCleared returns if the "dns_names" field was cleared in this mutation.
func (m *MtlsCertificateMutation) DNSNamesCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldDNSNames]
	return ok
}

// ResetDNSNames resets all changes to the "dns_names" field.
func (m *MtlsCertificateMutation) ResetDNSNames() {
	m.dns_names = nil
	m.appenddns_names = nil
	delete(m.clearedFields, mtlscertificate.FieldDNSNames)
}

// SetIPAddresses sets the "ip_addresses" field.
func (m *MtlsCertificateMutation) SetIPAddresses(s []string) {
	m.ip_addresses = &s
	m.appendip_addresses = nil
}

// IPAddresses returns the value of the "ip_addresses" field in the mutation.
func (m *MtlsCertificateMutation) IPAddresses() (r []string, exists bool) {
	v := m.ip_addresses
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddresses returns the old "ip_addresses" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldIPAddresses(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddresses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddresses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddresses: %w", err)
	}
	return oldValue.IPAddresses, nil
}

// AppendIPAddresses adds s to the "ip_addresses" field.
func (m *MtlsCertificateMutation) AppendIPAddresses(s []string) {
	m.appendip_addresses = append(m.appendip_addresses, s...)
}

// AppendedIPAddresses returns the list of values that were appended to the "ip_addresses" field in this mutation.
func (m *MtlsCertificateMutation) AppendedIPAddresses() ([]string, bool) {
	if len(m.appendip_addresses) == 0 {
		return nil, false
	}
	return m.appendip_addresses, true
}

// ClearIPAddresses clears the value of the "ip_addresses" field.
func (m *MtlsCertificateMutation) ClearIPAddresses() {
	m.ip_addresses = nil
	m.appendip_addresses = nil
	m.clearedFields[mtlscertificate.FieldIPAddresses] = struct{}{}
}

// IPAddressesCleared returns if the "ip_addresses" field was cleared in this mutation.
func (m *MtlsCertificateMutation) IPAddressesCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldIPAddresses]
	return ok
}

// ResetIPAddresses resets all changes to the "ip_addresses" field.
func (m *MtlsCertificateMutation) ResetIPAddresses() {
	m.ip_addresses = nil
	m.appendip_addresses = nil
	delete(m.clearedFields, mtlscertificate.FieldIPAddresses)
}

// SetEmailAddresses sets the "email_addresses" field.
func (m *MtlsCertificateMutation) SetEmailAddresses(s []string) {
	m.email_addresses = &s
	m.appendemail_addresses = nil
}

// EmailAddresses returns the value of the "email_addresses" field in the mutation.
func (m *MtlsCertificateMutation) EmailAddresses() (r []string, exists bool) {
	v := m.email_addresses
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailAddresses returns the old "email_addresses" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldEmailAddresses(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailAddresses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailAddresses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailAddresses: %w", err)
	}
	return oldValue.EmailAddresses, nil
}

// AppendEmailAddresses adds s to the "email_addresses" field.
func (m *MtlsCertificateMutation) AppendEmailAddresses(s []string) {
	m.appendemail_addresses = append(m.appendemail_addresses, s...)
}

// AppendedEmailAddresses returns the list of values that were appended to the "email_addresses" field in this mutation.
func (m *MtlsCertificateMutation) AppendedEmailAddresses() ([]string, bool) {
	if len(m.appendemail_addresses) == 0 {
		return nil, false
	}
	return m.appendemail_addresses, true
}

// ClearEmailAddresses clears the value of the "email_addresses" field.
func (m *MtlsCertificateMutation) ClearEmailAddresses() {
	m.email_addresses = nil
	m.appendemail_addresses = nil
	m.clearedFields[mtlscertificate.FieldEmailAddresses] = struct{}{}
}

// EmailAddressesCleared returns if the "email_addresses" field was cleared in this mutation.
func (m *MtlsCertificateMutation) EmailAddressesCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldEmailAddresses]
	return ok
}

// ResetEmailAddresses resets all changes to the "email_addresses" field.
func (m *MtlsCertificateMutation) ResetEmailAddresses() {
	m.email_addresses = nil
	m.appendemail_addresses = nil
	delete(m.clearedFields, mtlscertificate.FieldEmailAddresses)
}

// SetUris sets the "uris" field.
func (m *MtlsCertificateMutation) SetUris(s []string) {
	m.uris = &s
	m.appenduris = nil
}

// Uris returns the value of the "uris" field in the mutation.
func (m *MtlsCertificateMutation) Uris() (r []string, exists bool) {
	v := m.uris
	if v == nil {
		return
	}
	return *v, true
}

// OldUris returns the old "uris" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldUris(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUris is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUris requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUris: %w", err)
	}
	return oldValue.Uris, nil
}

// AppendUris adds s to the "uris" field.
func (m *MtlsCertificateMutation) AppendUris(s []string) {
	m.appenduris = append(m.appenduris, s...)
}

// AppendedUris returns the list of values that were appended to the "uris" field in this mutation.
func (m *MtlsCertificateMutation) AppendedUris() ([]string, bool) {
	if len(m.appenduris) == 0 {
		return nil, false
	}
	return m.appenduris, true
}

// ClearUris clears the value of the "uris" field.
func (m *MtlsCertificateMutation) ClearUris() {
	m.uris = nil
	m.appenduris = nil
	m.clearedFields[mtlscertificate.FieldUris] = struct{}{}
}

// UrisCleared returns if the "uris" field was cleared in this mutation.
func (m *MtlsCertificateMutation) UrisCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldUris]
	return ok
}

// ResetUris resets all changes to the "uris" field.
func (m *MtlsCertificateMutation) ResetUris() {
	m.uris = nil
	m.appenduris = nil
	delete(m.clearedFields, mtlscertificate.FieldUris)
}

// SetCertType sets the "cert_type" field.
func (m *MtlsCertificateMutation) SetCertType(mt mtlscertificate.CertType) {
	m.cert_type = &mt
}

// CertType returns the value of the "cert_type" field in the mutation.
func (m *MtlsCertificateMutation) CertType() (r mtlscertificate.CertType, exists bool) {
	v := m.cert_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCertType returns the old "cert_type" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldCertType(ctx context.Context) (v *mtlscertificate.CertType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertType: %w", err)
	}
	return oldValue.CertType, nil
}

// ClearCertType clears the value of the "cert_type" field.
func (m *MtlsCertificateMutation) ClearCertType() {
	m.cert_type = nil
	m.clearedFields[mtlscertificate.FieldCertType] = struct{}{}
}

// CertTypeCleared returns if the "cert_type" field was cleared in this mutation.
func (m *MtlsCertificateMutation) CertTypeCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldCertType]
	return ok
}

// ResetCertType resets all changes to the "cert_type" field.
func (m *MtlsCertificateMutation) ResetCertType() {
	m.cert_type = nil
	delete(m.clearedFields, mtlscertificate.FieldCertType)
}

// SetStatus sets the "status" field.
func (m *MtlsCertificateMutation) SetStatus(value mtlscertificate.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MtlsCertificateMutation) Status() (r mtlscertificate.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldStatus(ctx context.Context) (v *mtlscertificate.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *MtlsCertificateMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[mtlscertificate.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MtlsCertificateMutation) StatusCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MtlsCertificateMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, mtlscertificate.FieldStatus)
}

// SetIsCa sets the "is_ca" field.
func (m *MtlsCertificateMutation) SetIsCa(b bool) {
	m.is_ca = &b
}

// IsCa returns the value of the "is_ca" field in the mutation.
func (m *MtlsCertificateMutation) IsCa() (r bool, exists bool) {
	v := m.is_ca
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCa returns the old "is_ca" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldIsCa(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCa: %w", err)
	}
	return oldValue.IsCa, nil
}

// ResetIsCa resets all changes to the "is_ca" field.
func (m *MtlsCertificateMutation) ResetIsCa() {
	m.is_ca = nil
}

// SetPathLenConstraint sets the "path_len_constraint" field.
func (m *MtlsCertificateMutation) SetPathLenConstraint(i int32) {
	m.path_len_constraint = &i
	m.addpath_len_constraint = nil
}

// PathLenConstraint returns the value of the "path_len_constraint" field in the mutation.
func (m *MtlsCertificateMutation) PathLenConstraint() (r int32, exists bool) {
	v := m.path_len_constraint
	if v == nil {
		return
	}
	return *v, true
}

// OldPathLenConstraint returns the old "path_len_constraint" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldPathLenConstraint(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPathLenConstraint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPathLenConstraint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPathLenConstraint: %w", err)
	}
	return oldValue.PathLenConstraint, nil
}

// AddPathLenConstraint adds i to the "path_len_constraint" field.
func (m *MtlsCertificateMutation) AddPathLenConstraint(i int32) {
	if m.addpath_len_constraint != nil {
		*m.addpath_len_constraint += i
	} else {
		m.addpath_len_constraint = &i
	}
}

// AddedPathLenConstraint returns the value that was added to the "path_len_constraint" field in this mutation.
func (m *MtlsCertificateMutation) AddedPathLenConstraint() (r int32, exists bool) {
	v := m.addpath_len_constraint
	if v == nil {
		return
	}
	return *v, true
}

// ClearPathLenConstraint clears the value of the "path_len_constraint" field.
func (m *MtlsCertificateMutation) ClearPathLenConstraint() {
	m.path_len_constraint = nil
	m.addpath_len_constraint = nil
	m.clearedFields[mtlscertificate.FieldPathLenConstraint] = struct{}{}
}

// PathLenConstraintCleared returns if the "path_len_constraint" field was cleared in this mutation.
func (m *MtlsCertificateMutation) PathLenConstraintCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldPathLenConstraint]
	return ok
}

// ResetPathLenConstraint resets all changes to the "path_len_constraint" field.
func (m *MtlsCertificateMutation) ResetPathLenConstraint() {
	m.path_len_constraint = nil
	m.addpath_len_constraint = nil
	delete(m.clearedFields, mtlscertificate.FieldPathLenConstraint)
}

// SetKeyUsage sets the "key_usage" field.
func (m *MtlsCertificateMutation) SetKeyUsage(s []string) {
	m.key_usage = &s
	m.appendkey_usage = nil
}

// KeyUsage returns the value of the "key_usage" field in the mutation.
func (m *MtlsCertificateMutation) KeyUsage() (r []string, exists bool) {
	v := m.key_usage
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyUsage returns the old "key_usage" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldKeyUsage(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyUsage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyUsage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyUsage: %w", err)
	}
	return oldValue.KeyUsage, nil
}

// AppendKeyUsage adds s to the "key_usage" field.
func (m *MtlsCertificateMutation) AppendKeyUsage(s []string) {
	m.appendkey_usage = append(m.appendkey_usage, s...)
}

// AppendedKeyUsage returns the list of values that were appended to the "key_usage" field in this mutation.
func (m *MtlsCertificateMutation) AppendedKeyUsage() ([]string, bool) {
	if len(m.appendkey_usage) == 0 {
		return nil, false
	}
	return m.appendkey_usage, true
}

// ClearKeyUsage clears the value of the "key_usage" field.
func (m *MtlsCertificateMutation) ClearKeyUsage() {
	m.key_usage = nil
	m.appendkey_usage = nil
	m.clearedFields[mtlscertificate.FieldKeyUsage] = struct{}{}
}

// KeyUsageCleared returns if the "key_usage" field was cleared in this mutation.
func (m *MtlsCertificateMutation) KeyUsageCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldKeyUsage]
	return ok
}

// ResetKeyUsage resets all changes to the "key_usage" field.
func (m *MtlsCertificateMutation) ResetKeyUsage() {
	m.key_usage = nil
	m.appendkey_usage = nil
	delete(m.clearedFields, mtlscertificate.FieldKeyUsage)
}

// SetExtKeyUsage sets the "ext_key_usage" field.
func (m *MtlsCertificateMutation) SetExtKeyUsage(s []string) {
	m.ext_key_usage = &s
	m.appendext_key_usage = nil
}

// ExtKeyUsage returns the value of the "ext_key_usage" field in the mutation.
func (m *MtlsCertificateMutation) ExtKeyUsage() (r []string, exists bool) {
	v := m.ext_key_usage
	if v == nil {
		return
	}
	return *v, true
}

// OldExtKeyUsage returns the old "ext_key_usage" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldExtKeyUsage(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtKeyUsage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtKeyUsage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtKeyUsage: %w", err)
	}
	return oldValue.ExtKeyUsage, nil
}

// AppendExtKeyUsage adds s to the "ext_key_usage" field.
func (m *MtlsCertificateMutation) AppendExtKeyUsage(s []string) {
	m.appendext_key_usage = append(m.appendext_key_usage, s...)
}

// AppendedExtKeyUsage returns the list of values that were appended to the "ext_key_usage" field in this mutation.
func (m *MtlsCertificateMutation) AppendedExtKeyUsage() ([]string, bool) {
	if len(m.appendext_key_usage) == 0 {
		return nil, false
	}
	return m.appendext_key_usage, true
}

// ClearExtKeyUsage clears the value of the "ext_key_usage" field.
func (m *MtlsCertificateMutation) ClearExtKeyUsage() {
	m.ext_key_usage = nil
	m.appendext_key_usage = nil
	m.clearedFields[mtlscertificate.FieldExtKeyUsage] = struct{}{}
}

// ExtKeyUsageCleared returns if the "ext_key_usage" field was cleared in this mutation.
func (m *MtlsCertificateMutation) ExtKeyUsageCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldExtKeyUsage]
	return ok
}

// ResetExtKeyUsage resets all changes to the "ext_key_usage" field.
func (m *MtlsCertificateMutation) ResetExtKeyUsage() {
	m.ext_key_usage = nil
	m.appendext_key_usage = nil
	delete(m.clearedFields, mtlscertificate.FieldExtKeyUsage)
}

// SetMetadata sets the "metadata" field.
func (m *MtlsCertificateMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *MtlsCertificateMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *MtlsCertificateMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[mtlscertificate.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *MtlsCertificateMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *MtlsCertificateMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, mtlscertificate.FieldMetadata)
}

// SetNotes sets the "notes" field.
func (m *MtlsCertificateMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *MtlsCertificateMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *MtlsCertificateMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[mtlscertificate.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *MtlsCertificateMutation) NotesCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *MtlsCertificateMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, mtlscertificate.FieldNotes)
}

// SetRequestID sets the "request_id" field.
func (m *MtlsCertificateMutation) SetRequestID(u uint32) {
	m.request_id = &u
	m.addrequest_id = nil
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *MtlsCertificateMutation) RequestID() (r uint32, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldRequestID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// AddRequestID adds u to the "request_id" field.
func (m *MtlsCertificateMutation) AddRequestID(u int32) {
	if m.addrequest_id != nil {
		*m.addrequest_id += u
	} else {
		m.addrequest_id = &u
	}
}

// AddedRequestID returns the value that was added to the "request_id" field in this mutation.
func (m *MtlsCertificateMutation) AddedRequestID() (r int32, exists bool) {
	v := m.addrequest_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRequestID clears the value of the "request_id" field.
func (m *MtlsCertificateMutation) ClearRequestID() {
	m.request_id = nil
	m.addrequest_id = nil
	m.clearedFields[mtlscertificate.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *MtlsCertificateMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *MtlsCertificateMutation) ResetRequestID() {
	m.request_id = nil
	m.addrequest_id = nil
	delete(m.clearedFields, mtlscertificate.FieldRequestID)
}

// SetRevocationReason sets the "revocation_reason" field.
func (m *MtlsCertificateMutation) SetRevocationReason(mr mtlscertificate.RevocationReason) {
	m.revocation_reason = &mr
}

// RevocationReason returns the value of the "revocation_reason" field in the mutation.
func (m *MtlsCertificateMutation) RevocationReason() (r mtlscertificate.RevocationReason, exists bool) {
	v := m.revocation_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRevocationReason returns the old "revocation_reason" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldRevocationReason(ctx context.Context) (v *mtlscertificate.RevocationReason, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevocationReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevocationReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevocationReason: %w", err)
	}
	return oldValue.RevocationReason, nil
}

// ClearRevocationReason clears the value of the "revocation_reason" field.
func (m *MtlsCertificateMutation) ClearRevocationReason() {
	m.revocation_reason = nil
	m.clearedFields[mtlscertificate.FieldRevocationReason] = struct{}{}
}

// RevocationReasonCleared returns if the "revocation_reason" field was cleared in this mutation.
func (m *MtlsCertificateMutation) RevocationReasonCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldRevocationReason]
	return ok
}

// ResetRevocationReason resets all changes to the "revocation_reason" field.
func (m *MtlsCertificateMutation) ResetRevocationReason() {
	m.revocation_reason = nil
	delete(m.clearedFields, mtlscertificate.FieldRevocationReason)
}

// SetRevocationNotes sets the "revocation_notes" field.
func (m *MtlsCertificateMutation) SetRevocationNotes(s string) {
	m.revocation_notes = &s
}

// RevocationNotes returns the value of the "revocation_notes" field in the mutation.
func (m *MtlsCertificateMutation) RevocationNotes() (r string, exists bool) {
	v := m.revocation_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldRevocationNotes returns the old "revocation_notes" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldRevocationNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevocationNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevocationNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevocationNotes: %w", err)
	}
	return oldValue.RevocationNotes, nil
}

// ClearRevocationNotes clears the value of the "revocation_notes" field.
func (m *MtlsCertificateMutation) ClearRevocationNotes() {
	m.revocation_notes = nil
	m.clearedFields[mtlscertificate.FieldRevocationNotes] = struct{}{}
}

// RevocationNotesCleared returns if the "revocation_notes" field was cleared in this mutation.
func (m *MtlsCertificateMutation) RevocationNotesCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldRevocationNotes]
	return ok
}

// ResetRevocationNotes resets all changes to the "revocation_notes" field.
func (m *MtlsCertificateMutation) ResetRevocationNotes() {
	m.revocation_notes = nil
	delete(m.clearedFields, mtlscertificate.FieldRevocationNotes)
}

// SetIssuedBy sets the "issued_by" field.
func (m *MtlsCertificateMutation) SetIssuedBy(u uint32) {
	m.issued_by = &u
	m.addissued_by = nil
}

// IssuedBy returns the value of the "issued_by" field in the mutation.
func (m *MtlsCertificateMutation) IssuedBy() (r uint32, exists bool) {
	v := m.issued_by
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuedBy returns the old "issued_by" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldIssuedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuedBy: %w", err)
	}
	return oldValue.IssuedBy, nil
}

// AddIssuedBy adds u to the "issued_by" field.
func (m *MtlsCertificateMutation) AddIssuedBy(u int32) {
	if m.addissued_by != nil {
		*m.addissued_by += u
	} else {
		m.addissued_by = &u
	}
}

// AddedIssuedBy returns the value that was added to the "issued_by" field in this mutation.
func (m *MtlsCertificateMutation) AddedIssuedBy() (r int32, exists bool) {
	v := m.addissued_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearIssuedBy clears the value of the "issued_by" field.
func (m *MtlsCertificateMutation) ClearIssuedBy() {
	m.issued_by = nil
	m.addissued_by = nil
	m.clearedFields[mtlscertificate.FieldIssuedBy] = struct{}{}
}

// IssuedByCleared returns if the "issued_by" field was cleared in this mutation.
func (m *MtlsCertificateMutation) IssuedByCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldIssuedBy]
	return ok
}

// ResetIssuedBy resets all changes to the "issued_by" field.
func (m *MtlsCertificateMutation) ResetIssuedBy() {
	m.issued_by = nil
	m.addissued_by = nil
	delete(m.clearedFields, mtlscertificate.FieldIssuedBy)
}

// SetRevokedBy sets the "revoked_by" field.
func (m *MtlsCertificateMutation) SetRevokedBy(u uint32) {
	m.revoked_by = &u
	m.addrevoked_by = nil
}

// RevokedBy returns the value of the "revoked_by" field in the mutation.
func (m *MtlsCertificateMutation) RevokedBy() (r uint32, exists bool) {
	v := m.revoked_by
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedBy returns the old "revoked_by" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldRevokedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedBy: %w", err)
	}
	return oldValue.RevokedBy, nil
}

// AddRevokedBy adds u to the "revoked_by" field.
func (m *MtlsCertificateMutation) AddRevokedBy(u int32) {
	if m.addrevoked_by != nil {
		*m.addrevoked_by += u
	} else {
		m.addrevoked_by = &u
	}
}

// AddedRevokedBy returns the value that was added to the "revoked_by" field in this mutation.
func (m *MtlsCertificateMutation) AddedRevokedBy() (r int32, exists bool) {
	v := m.addrevoked_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearRevokedBy clears the value of the "revoked_by" field.
func (m *MtlsCertificateMutation) ClearRevokedBy() {
	m.revoked_by = nil
	m.addrevoked_by = nil
	m.clearedFields[mtlscertificate.FieldRevokedBy] = struct{}{}
}

// RevokedByCleared returns if the "revoked_by" field was cleared in this mutation.
func (m *MtlsCertificateMutation) RevokedByCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldRevokedBy]
	return ok
}

// ResetRevokedBy resets all changes to the "revoked_by" field.
func (m *MtlsCertificateMutation) ResetRevokedBy() {
	m.revoked_by = nil
	m.addrevoked_by = nil
	delete(m.clearedFields, mtlscertificate.FieldRevokedBy)
}

// SetNotBefore sets the "not_before" field.
func (m *MtlsCertificateMutation) SetNotBefore(t time.Time) {
	m.not_before = &t
}

// NotBefore returns the value of the "not_before" field in the mutation.
func (m *MtlsCertificateMutation) NotBefore() (r time.Time, exists bool) {
	v := m.not_before
	if v == nil {
		return
	}
	return *v, true
}

// OldNotBefore returns the old "not_before" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldNotBefore(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotBefore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotBefore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotBefore: %w", err)
	}
	return oldValue.NotBefore, nil
}

// ClearNotBefore clears the value of the "not_before" field.
func (m *MtlsCertificateMutation) ClearNotBefore() {
	m.not_before = nil
	m.clearedFields[mtlscertificate.FieldNotBefore] = struct{}{}
}

// NotBeforeCleared returns if the "not_before" field was cleared in this mutation.
func (m *MtlsCertificateMutation) NotBeforeCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldNotBefore]
	return ok
}

// ResetNotBefore resets all changes to the "not_before" field.
func (m *MtlsCertificateMutation) ResetNotBefore() {
	m.not_before = nil
	delete(m.clearedFields, mtlscertificate.FieldNotBefore)
}

// SetNotAfter sets the "not_after" field.
func (m *MtlsCertificateMutation) SetNotAfter(t time.Time) {
	m.not_after = &t
}

// NotAfter returns the value of the "not_after" field in the mutation.
func (m *MtlsCertificateMutation) NotAfter() (r time.Time, exists bool) {
	v := m.not_after
	if v == nil {
		return
	}
	return *v, true
}

// OldNotAfter returns the old "not_after" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldNotAfter(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotAfter: %w", err)
	}
	return oldValue.NotAfter, nil
}

// ClearNotAfter clears the value of the "not_after" field.
func (m *MtlsCertificateMutation) ClearNotAfter() {
	m.not_after = nil
	m.clearedFields[mtlscertificate.FieldNotAfter] = struct{}{}
}

// NotAfterCleared returns if the "not_after" field was cleared in this mutation.
func (m *MtlsCertificateMutation) NotAfterCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldNotAfter]
	return ok
}

// ResetNotAfter resets all changes to the "not_after" field.
func (m *MtlsCertificateMutation) ResetNotAfter() {
	m.not_after = nil
	delete(m.clearedFields, mtlscertificate.FieldNotAfter)
}

// SetIssuedAt sets the "issued_at" field.
func (m *MtlsCertificateMutation) SetIssuedAt(t time.Time) {
	m.issued_at = &t
}

// IssuedAt returns the value of the "issued_at" field in the mutation.
func (m *MtlsCertificateMutation) IssuedAt() (r time.Time, exists bool) {
	v := m.issued_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuedAt returns the old "issued_at" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldIssuedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuedAt: %w", err)
	}
	return oldValue.IssuedAt, nil
}

// ClearIssuedAt clears the value of the "issued_at" field.
func (m *MtlsCertificateMutation) ClearIssuedAt() {
	m.issued_at = nil
	m.clearedFields[mtlscertificate.FieldIssuedAt] = struct{}{}
}

// IssuedAtCleared returns if the "issued_at" field was cleared in this mutation.
func (m *MtlsCertificateMutation) IssuedAtCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldIssuedAt]
	return ok
}

// ResetIssuedAt resets all changes to the "issued_at" field.
func (m *MtlsCertificateMutation) ResetIssuedAt() {
	m.issued_at = nil
	delete(m.clearedFields, mtlscertificate.FieldIssuedAt)
}

// SetRevokedAt sets the "revoked_at" field.
func (m *MtlsCertificateMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *MtlsCertificateMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *MtlsCertificateMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[mtlscertificate.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *MtlsCertificateMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *MtlsCertificateMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, mtlscertificate.FieldRevokedAt)
}

// SetLastSeenAt sets the "last_seen_at" field.
func (m *MtlsCertificateMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the value of the "last_seen_at" field in the mutation.
func (m *MtlsCertificateMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old "last_seen_at" field's value of the MtlsCertificate entity.
// If the MtlsCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateMutation) OldLastSeenAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ClearLastSeenAt clears the value of the "last_seen_at" field.
func (m *MtlsCertificateMutation) ClearLastSeenAt() {
	m.last_seen_at = nil
	m.clearedFields[mtlscertificate.FieldLastSeenAt] = struct{}{}
}

// LastSeenAtCleared returns if the "last_seen_at" field was cleared in this mutation.
func (m *MtlsCertificateMutation) LastSeenAtCleared() bool {
	_, ok := m.clearedFields[mtlscertificate.FieldLastSeenAt]
	return ok
}

// ResetLastSeenAt resets all changes to the "last_seen_at" field.
func (m *MtlsCertificateMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
	delete(m.clearedFields, mtlscertificate.FieldLastSeenAt)
}

// SetLcmClientID sets the "lcm_client" edge to the LcmClient entity by id.
func (m *MtlsCertificateMutation) SetLcmClientID(id uint32) {
	m.lcm_client = &id
}

// ClearLcmClient clears the "lcm_client" edge to the LcmClient entity.
func (m *MtlsCertificateMutation) ClearLcmClient() {
	m.clearedlcm_client = true
}

// LcmClientCleared reports if the "lcm_client" edge to the LcmClient entity was cleared.
func (m *MtlsCertificateMutation) LcmClientCleared() bool {
	return m.clearedlcm_client
}

// LcmClientID returns the "lcm_client" edge ID in the mutation.
func (m *MtlsCertificateMutation) LcmClientID() (id uint32, exists bool) {
	if m.lcm_client != nil {
		return *m.lcm_client, true
	}
	return
}

// LcmClientIDs returns the "lcm_client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LcmClientID instead. It exists only for internal usage by the builders.
func (m *MtlsCertificateMutation) LcmClientIDs() (ids []uint32) {
	if id := m.lcm_client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLcmClient resets all changes to the "lcm_client" edge.
func (m *MtlsCertificateMutation) ResetLcmClient() {
	m.lcm_client = nil
	m.clearedlcm_client = false
}

// Where appends a list predicates to the MtlsCertificateMutation builder.
func (m *MtlsCertificateMutation) Where(ps ...predicate.MtlsCertificate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MtlsCertificateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MtlsCertificateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MtlsCertificate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MtlsCertificateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MtlsCertificateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MtlsCertificate).
func (m *MtlsCertificateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MtlsCertificateMutation) Fields() []string {
	fields := make([]string, 0, 41)
	if m.create_by != nil {
		fields = append(fields, mtlscertificate.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, mtlscertificate.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, mtlscertificate.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, mtlscertificate.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, mtlscertificate.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, mtlscertificate.FieldTenantID)
	}
	if m.serial_number != nil {
		fields = append(fields, mtlscertificate.FieldSerialNumber)
	}
	if m.client_id != nil {
		fields = append(fields, mtlscertificate.FieldClientID)
	}
	if m.common_name != nil {
		fields = append(fields, mtlscertificate.FieldCommonName)
	}
	if m.subject_dn != nil {
		fields = append(fields, mtlscertificate.FieldSubjectDn)
	}
	if m.issuer_dn != nil {
		fields = append(fields, mtlscertificate.FieldIssuerDn)
	}
	if m.issuer_name != nil {
		fields = append(fields, mtlscertificate.FieldIssuerName)
	}
	if m.fingerprint_sha256 != nil {
		fields = append(fields, mtlscertificate.FieldFingerprintSha256)
	}
	if m.fingerprint_sha1 != nil {
		fields = append(fields, mtlscertificate.FieldFingerprintSha1)
	}
	if m.public_key_algorithm != nil {
		fields = append(fields, mtlscertificate.FieldPublicKeyAlgorithm)
	}
	if m.public_key_size != nil {
		fields = append(fields, mtlscertificate.FieldPublicKeySize)
	}
	if m.signature_algorithm != nil {
		fields = append(fields, mtlscertificate.FieldSignatureAlgorithm)
	}
	if m.certificate_pem != nil {
		fields = append(fields, mtlscertificate.FieldCertificatePem)
	}
	if m.public_key_pem != nil {
		fields = append(fields, mtlscertificate.FieldPublicKeyPem)
	}
	if m.dns_names != nil {
		fields = append(fields, mtlscertificate.FieldDNSNames)
	}
	if m.ip_addresses != nil {
		fields = append(fields, mtlscertificate.FieldIPAddresses)
	}
	if m.email_addresses != nil {
		fields = append(fields, mtlscertificate.FieldEmailAddresses)
	}
	if m.uris != nil {
		fields = append(fields, mtlscertificate.FieldUris)
	}
	if m.cert_type != nil {
		fields = append(fields, mtlscertificate.FieldCertType)
	}
	if m.status != nil {
		fields = append(fields, mtlscertificate.FieldStatus)
	}
	if m.is_ca != nil {
		fields = append(fields, mtlscertificate.FieldIsCa)
	}
	if m.path_len_constraint != nil {
		fields = append(fields, mtlscertificate.FieldPathLenConstraint)
	}
	if m.key_usage != nil {
		fields = append(fields, mtlscertificate.FieldKeyUsage)
	}
	if m.ext_key_usage != nil {
		fields = append(fields, mtlscertificate.FieldExtKeyUsage)
	}
	if m.metadata != nil {
		fields = append(fields, mtlscertificate.FieldMetadata)
	}
	if m.notes != nil {
		fields = append(fields, mtlscertificate.FieldNotes)
	}
	if m.request_id != nil {
		fields = append(fields, mtlscertificate.FieldRequestID)
	}
	if m.revocation_reason != nil {
		fields = append(fields, mtlscertificate.FieldRevocationReason)
	}
	if m.revocation_notes != nil {
		fields = append(fields, mtlscertificate.FieldRevocationNotes)
	}
	if m.issued_by != nil {
		fields = append(fields, mtlscertificate.FieldIssuedBy)
	}
	if m.revoked_by != nil {
		fields = append(fields, mtlscertificate.FieldRevokedBy)
	}
	if m.not_before != nil {
		fields = append(fields, mtlscertificate.FieldNotBefore)
	}
	if m.not_after != nil {
		fields = append(fields, mtlscertificate.FieldNotAfter)
	}
	if m.issued_at != nil {
		fields = append(fields, mtlscertificate.FieldIssuedAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, mtlscertificate.FieldRevokedAt)
	}
	if m.last_seen_at != nil {
		fields = append(fields, mtlscertificate.FieldLastSeenAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MtlsCertificateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mtlscertificate.FieldCreateBy:
		return m.CreateBy()
	case mtlscertificate.FieldUpdateBy:
		return m.UpdateBy()
	case mtlscertificate.FieldCreateTime:
		return m.CreateTime()
	case mtlscertificate.FieldUpdateTime:
		return m.UpdateTime()
	case mtlscertificate.FieldDeleteTime:
		return m.DeleteTime()
	case mtlscertificate.FieldTenantID:
		return m.TenantID()
	case mtlscertificate.FieldSerialNumber:
		return m.SerialNumber()
	case mtlscertificate.FieldClientID:
		return m.ClientID()
	case mtlscertificate.FieldCommonName:
		return m.CommonName()
	case mtlscertificate.FieldSubjectDn:
		return m.SubjectDn()
	case mtlscertificate.FieldIssuerDn:
		return m.IssuerDn()
	case mtlscertificate.FieldIssuerName:
		return m.IssuerName()
	case mtlscertificate.FieldFingerprintSha256:
		return m.FingerprintSha256()
	case mtlscertificate.FieldFingerprintSha1:
		return m.FingerprintSha1()
	case mtlscertificate.FieldPublicKeyAlgorithm:
		return m.PublicKeyAlgorithm()
	case mtlscertificate.FieldPublicKeySize:
		return m.PublicKeySize()
	case mtlscertificate.FieldSignatureAlgorithm:
		return m.SignatureAlgorithm()
	case mtlscertificate.FieldCertificatePem:
		return m.CertificatePem()
	case mtlscertificate.FieldPublicKeyPem:
		return m.PublicKeyPem()
	case mtlscertificate.FieldDNSNames:
		return m.DNSNames()
	case mtlscertificate.FieldIPAddresses:
		return m.IPAddresses()
	case mtlscertificate.FieldEmailAddresses:
		return m.EmailAddresses()
	case mtlscertificate.FieldUris:
		return m.Uris()
	case mtlscertificate.FieldCertType:
		return m.CertType()
	case mtlscertificate.FieldStatus:
		return m.Status()
	case mtlscertificate.FieldIsCa:
		return m.IsCa()
	case mtlscertificate.FieldPathLenConstraint:
		return m.PathLenConstraint()
	case mtlscertificate.FieldKeyUsage:
		return m.KeyUsage()
	case mtlscertificate.FieldExtKeyUsage:
		return m.ExtKeyUsage()
	case mtlscertificate.FieldMetadata:
		return m.Metadata()
	case mtlscertificate.FieldNotes:
		return m.Notes()
	case mtlscertificate.FieldRequestID:
		return m.RequestID()
	case mtlscertificate.FieldRevocationReason:
		return m.RevocationReason()
	case mtlscertificate.FieldRevocationNotes:
		return m.RevocationNotes()
	case mtlscertificate.FieldIssuedBy:
		return m.IssuedBy()
	case mtlscertificate.FieldRevokedBy:
		return m.RevokedBy()
	case mtlscertificate.FieldNotBefore:
		return m.NotBefore()
	case mtlscertificate.FieldNotAfter:
		return m.NotAfter()
	case mtlscertificate.FieldIssuedAt:
		return m.IssuedAt()
	case mtlscertificate.FieldRevokedAt:
		return m.RevokedAt()
	case mtlscertificate.FieldLastSeenAt:
		return m.LastSeenAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MtlsCertificateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mtlscertificate.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case mtlscertificate.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case mtlscertificate.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case mtlscertificate.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case mtlscertificate.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case mtlscertificate.FieldTenantID:
		return m.OldTenantID(ctx)
	case mtlscertificate.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case mtlscertificate.FieldClientID:
		return m.OldClientID(ctx)
	case mtlscertificate.FieldCommonName:
		return m.OldCommonName(ctx)
	case mtlscertificate.FieldSubjectDn:
		return m.OldSubjectDn(ctx)
	case mtlscertificate.FieldIssuerDn:
		return m.OldIssuerDn(ctx)
	case mtlscertificate.FieldIssuerName:
		return m.OldIssuerName(ctx)
	case mtlscertificate.FieldFingerprintSha256:
		return m.OldFingerprintSha256(ctx)
	case mtlscertificate.FieldFingerprintSha1:
		return m.OldFingerprintSha1(ctx)
	case mtlscertificate.FieldPublicKeyAlgorithm:
		return m.OldPublicKeyAlgorithm(ctx)
	case mtlscertificate.FieldPublicKeySize:
		return m.OldPublicKeySize(ctx)
	case mtlscertificate.FieldSignatureAlgorithm:
		return m.OldSignatureAlgorithm(ctx)
	case mtlscertificate.FieldCertificatePem:
		return m.OldCertificatePem(ctx)
	case mtlscertificate.FieldPublicKeyPem:
		return m.OldPublicKeyPem(ctx)
	case mtlscertificate.FieldDNSNames:
		return m.OldDNSNames(ctx)
	case mtlscertificate.FieldIPAddresses:
		return m.OldIPAddresses(ctx)
	case mtlscertificate.FieldEmailAddresses:
		return m.OldEmailAddresses(ctx)
	case mtlscertificate.FieldUris:
		return m.OldUris(ctx)
	case mtlscertificate.FieldCertType:
		return m.OldCertType(ctx)
	case mtlscertificate.FieldStatus:
		return m.OldStatus(ctx)
	case mtlscertificate.FieldIsCa:
		return m.OldIsCa(ctx)
	case mtlscertificate.FieldPathLenConstraint:
		return m.OldPathLenConstraint(ctx)
	case mtlscertificate.FieldKeyUsage:
		return m.OldKeyUsage(ctx)
	case mtlscertificate.FieldExtKeyUsage:
		return m.OldExtKeyUsage(ctx)
	case mtlscertificate.FieldMetadata:
		return m.OldMetadata(ctx)
	case mtlscertificate.FieldNotes:
		return m.OldNotes(ctx)
	case mtlscertificate.FieldRequestID:
		return m.OldRequestID(ctx)
	case mtlscertificate.FieldRevocationReason:
		return m.OldRevocationReason(ctx)
	case mtlscertificate.FieldRevocationNotes:
		return m.OldRevocationNotes(ctx)
	case mtlscertificate.FieldIssuedBy:
		return m.OldIssuedBy(ctx)
	case mtlscertificate.FieldRevokedBy:
		return m.OldRevokedBy(ctx)
	case mtlscertificate.FieldNotBefore:
		return m.OldNotBefore(ctx)
	case mtlscertificate.FieldNotAfter:
		return m.OldNotAfter(ctx)
	case mtlscertificate.FieldIssuedAt:
		return m.OldIssuedAt(ctx)
	case mtlscertificate.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case mtlscertificate.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	}
	return nil, fmt.Errorf("unknown MtlsCertificate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MtlsCertificateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mtlscertificate.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case mtlscertificate.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case mtlscertificate.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case mtlscertificate.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case mtlscertificate.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case mtlscertificate.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case mtlscertificate.FieldSerialNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case mtlscertificate.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case mtlscertificate.FieldCommonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommonName(v)
		return nil
	case mtlscertificate.FieldSubjectDn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectDn(v)
		return nil
	case mtlscertificate.FieldIssuerDn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerDn(v)
		return nil
	case mtlscertificate.FieldIssuerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerName(v)
		return nil
	case mtlscertificate.FieldFingerprintSha256:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFingerprintSha256(v)
		return nil
	case mtlscertificate.FieldFingerprintSha1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFingerprintSha1(v)
		return nil
	case mtlscertificate.FieldPublicKeyAlgorithm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKeyAlgorithm(v)
		return nil
	case mtlscertificate.FieldPublicKeySize:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKeySize(v)
		return nil
	case mtlscertificate.FieldSignatureAlgorithm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignatureAlgorithm(v)
		return nil
	case mtlscertificate.FieldCertificatePem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificatePem(v)
		return nil
	case mtlscertificate.FieldPublicKeyPem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKeyPem(v)
		return nil
	case mtlscertificate.FieldDNSNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSNames(v)
		return nil
	case mtlscertificate.FieldIPAddresses:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddresses(v)
		return nil
	case mtlscertificate.FieldEmailAddresses:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailAddresses(v)
		return nil
	case mtlscertificate.FieldUris:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUris(v)
		return nil
	case mtlscertificate.FieldCertType:
		v, ok := value.(mtlscertificate.CertType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertType(v)
		return nil
	case mtlscertificate.FieldStatus:
		v, ok := value.(mtlscertificate.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case mtlscertificate.FieldIsCa:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCa(v)
		return nil
	case mtlscertificate.FieldPathLenConstraint:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPathLenConstraint(v)
		return nil
	case mtlscertificate.FieldKeyUsage:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyUsage(v)
		return nil
	case mtlscertificate.FieldExtKeyUsage:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtKeyUsage(v)
		return nil
	case mtlscertificate.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case mtlscertificate.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case mtlscertificate.FieldRequestID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case mtlscertificate.FieldRevocationReason:
		v, ok := value.(mtlscertificate.RevocationReason)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevocationReason(v)
		return nil
	case mtlscertificate.FieldRevocationNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevocationNotes(v)
		return nil
	case mtlscertificate.FieldIssuedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuedBy(v)
		return nil
	case mtlscertificate.FieldRevokedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedBy(v)
		return nil
	case mtlscertificate.FieldNotBefore:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotBefore(v)
		return nil
	case mtlscertificate.FieldNotAfter:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotAfter(v)
		return nil
	case mtlscertificate.FieldIssuedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuedAt(v)
		return nil
	case mtlscertificate.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case mtlscertificate.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	}
	return fmt.Errorf("unknown MtlsCertificate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MtlsCertificateMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, mtlscertificate.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, mtlscertificate.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, mtlscertificate.FieldTenantID)
	}
	if m.addserial_number != nil {
		fields = append(fields, mtlscertificate.FieldSerialNumber)
	}
	if m.addpublic_key_size != nil {
		fields = append(fields, mtlscertificate.FieldPublicKeySize)
	}
	if m.addpath_len_constraint != nil {
		fields = append(fields, mtlscertificate.FieldPathLenConstraint)
	}
	if m.addrequest_id != nil {
		fields = append(fields, mtlscertificate.FieldRequestID)
	}
	if m.addissued_by != nil {
		fields = append(fields, mtlscertificate.FieldIssuedBy)
	}
	if m.addrevoked_by != nil {
		fields = append(fields, mtlscertificate.FieldRevokedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MtlsCertificateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mtlscertificate.FieldCreateBy:
		return m.AddedCreateBy()
	case mtlscertificate.FieldUpdateBy:
		return m.AddedUpdateBy()
	case mtlscertificate.FieldTenantID:
		return m.AddedTenantID()
	case mtlscertificate.FieldSerialNumber:
		return m.AddedSerialNumber()
	case mtlscertificate.FieldPublicKeySize:
		return m.AddedPublicKeySize()
	case mtlscertificate.FieldPathLenConstraint:
		return m.AddedPathLenConstraint()
	case mtlscertificate.FieldRequestID:
		return m.AddedRequestID()
	case mtlscertificate.FieldIssuedBy:
		return m.AddedIssuedBy()
	case mtlscertificate.FieldRevokedBy:
		return m.AddedRevokedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MtlsCertificateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mtlscertificate.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case mtlscertificate.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case mtlscertificate.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case mtlscertificate.FieldSerialNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSerialNumber(v)
		return nil
	case mtlscertificate.FieldPublicKeySize:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublicKeySize(v)
		return nil
	case mtlscertificate.FieldPathLenConstraint:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPathLenConstraint(v)
		return nil
	case mtlscertificate.FieldRequestID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequestID(v)
		return nil
	case mtlscertificate.FieldIssuedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIssuedBy(v)
		return nil
	case mtlscertificate.FieldRevokedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevokedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MtlsCertificate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MtlsCertificateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mtlscertificate.FieldCreateBy) {
		fields = append(fields, mtlscertificate.FieldCreateBy)
	}
	if m.FieldCleared(mtlscertificate.FieldUpdateBy) {
		fields = append(fields, mtlscertificate.FieldUpdateBy)
	}
	if m.FieldCleared(mtlscertificate.FieldCreateTime) {
		fields = append(fields, mtlscertificate.FieldCreateTime)
	}
	if m.FieldCleared(mtlscertificate.FieldUpdateTime) {
		fields = append(fields, mtlscertificate.FieldUpdateTime)
	}
	if m.FieldCleared(mtlscertificate.FieldDeleteTime) {
		fields = append(fields, mtlscertificate.FieldDeleteTime)
	}
	if m.FieldCleared(mtlscertificate.FieldTenantID) {
		fields = append(fields, mtlscertificate.FieldTenantID)
	}
	if m.FieldCleared(mtlscertificate.FieldClientID) {
		fields = append(fields, mtlscertificate.FieldClientID)
	}
	if m.FieldCleared(mtlscertificate.FieldCommonName) {
		fields = append(fields, mtlscertificate.FieldCommonName)
	}
	if m.FieldCleared(mtlscertificate.FieldSubjectDn) {
		fields = append(fields, mtlscertificate.FieldSubjectDn)
	}
	if m.FieldCleared(mtlscertificate.FieldIssuerDn) {
		fields = append(fields, mtlscertificate.FieldIssuerDn)
	}
	if m.FieldCleared(mtlscertificate.FieldIssuerName) {
		fields = append(fields, mtlscertificate.FieldIssuerName)
	}
	if m.FieldCleared(mtlscertificate.FieldFingerprintSha256) {
		fields = append(fields, mtlscertificate.FieldFingerprintSha256)
	}
	if m.FieldCleared(mtlscertificate.FieldFingerprintSha1) {
		fields = append(fields, mtlscertificate.FieldFingerprintSha1)
	}
	if m.FieldCleared(mtlscertificate.FieldPublicKeyAlgorithm) {
		fields = append(fields, mtlscertificate.FieldPublicKeyAlgorithm)
	}
	if m.FieldCleared(mtlscertificate.FieldPublicKeySize) {
		fields = append(fields, mtlscertificate.FieldPublicKeySize)
	}
	if m.FieldCleared(mtlscertificate.FieldSignatureAlgorithm) {
		fields = append(fields, mtlscertificate.FieldSignatureAlgorithm)
	}
	if m.FieldCleared(mtlscertificate.FieldCertificatePem) {
		fields = append(fields, mtlscertificate.FieldCertificatePem)
	}
	if m.FieldCleared(mtlscertificate.FieldPublicKeyPem) {
		fields = append(fields, mtlscertificate.FieldPublicKeyPem)
	}
	if m.FieldCleared(mtlscertificate.FieldDNSNames) {
		fields = append(fields, mtlscertificate.FieldDNSNames)
	}
	if m.FieldCleared(mtlscertificate.FieldIPAddresses) {
		fields = append(fields, mtlscertificate.FieldIPAddresses)
	}
	if m.FieldCleared(mtlscertificate.FieldEmailAddresses) {
		fields = append(fields, mtlscertificate.FieldEmailAddresses)
	}
	if m.FieldCleared(mtlscertificate.FieldUris) {
		fields = append(fields, mtlscertificate.FieldUris)
	}
	if m.FieldCleared(mtlscertificate.FieldCertType) {
		fields = append(fields, mtlscertificate.FieldCertType)
	}
	if m.FieldCleared(mtlscertificate.FieldStatus) {
		fields = append(fields, mtlscertificate.FieldStatus)
	}
	if m.FieldCleared(mtlscertificate.FieldPathLenConstraint) {
		fields = append(fields, mtlscertificate.FieldPathLenConstraint)
	}
	if m.FieldCleared(mtlscertificate.FieldKeyUsage) {
		fields = append(fields, mtlscertificate.FieldKeyUsage)
	}
	if m.FieldCleared(mtlscertificate.FieldExtKeyUsage) {
		fields = append(fields, mtlscertificate.FieldExtKeyUsage)
	}
	if m.FieldCleared(mtlscertificate.FieldMetadata) {
		fields = append(fields, mtlscertificate.FieldMetadata)
	}
	if m.FieldCleared(mtlscertificate.FieldNotes) {
		fields = append(fields, mtlscertificate.FieldNotes)
	}
	if m.FieldCleared(mtlscertificate.FieldRequestID) {
		fields = append(fields, mtlscertificate.FieldRequestID)
	}
	if m.FieldCleared(mtlscertificate.FieldRevocationReason) {
		fields = append(fields, mtlscertificate.FieldRevocationReason)
	}
	if m.FieldCleared(mtlscertificate.FieldRevocationNotes) {
		fields = append(fields, mtlscertificate.FieldRevocationNotes)
	}
	if m.FieldCleared(mtlscertificate.FieldIssuedBy) {
		fields = append(fields, mtlscertificate.FieldIssuedBy)
	}
	if m.FieldCleared(mtlscertificate.FieldRevokedBy) {
		fields = append(fields, mtlscertificate.FieldRevokedBy)
	}
	if m.FieldCleared(mtlscertificate.FieldNotBefore) {
		fields = append(fields, mtlscertificate.FieldNotBefore)
	}
	if m.FieldCleared(mtlscertificate.FieldNotAfter) {
		fields = append(fields, mtlscertificate.FieldNotAfter)
	}
	if m.FieldCleared(mtlscertificate.FieldIssuedAt) {
		fields = append(fields, mtlscertificate.FieldIssuedAt)
	}
	if m.FieldCleared(mtlscertificate.FieldRevokedAt) {
		fields = append(fields, mtlscertificate.FieldRevokedAt)
	}
	if m.FieldCleared(mtlscertificate.FieldLastSeenAt) {
		fields = append(fields, mtlscertificate.FieldLastSeenAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MtlsCertificateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MtlsCertificateMutation) ClearField(name string) error {
	switch name {
	case mtlscertificate.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case mtlscertificate.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case mtlscertificate.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case mtlscertificate.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case mtlscertificate.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case mtlscertificate.FieldTenantID:
		m.ClearTenantID()
		return nil
	case mtlscertificate.FieldClientID:
		m.ClearClientID()
		return nil
	case mtlscertificate.FieldCommonName:
		m.ClearCommonName()
		return nil
	case mtlscertificate.FieldSubjectDn:
		m.ClearSubjectDn()
		return nil
	case mtlscertificate.FieldIssuerDn:
		m.ClearIssuerDn()
		return nil
	case mtlscertificate.FieldIssuerName:
		m.ClearIssuerName()
		return nil
	case mtlscertificate.FieldFingerprintSha256:
		m.ClearFingerprintSha256()
		return nil
	case mtlscertificate.FieldFingerprintSha1:
		m.ClearFingerprintSha1()
		return nil
	case mtlscertificate.FieldPublicKeyAlgorithm:
		m.ClearPublicKeyAlgorithm()
		return nil
	case mtlscertificate.FieldPublicKeySize:
		m.ClearPublicKeySize()
		return nil
	case mtlscertificate.FieldSignatureAlgorithm:
		m.ClearSignatureAlgorithm()
		return nil
	case mtlscertificate.FieldCertificatePem:
		m.ClearCertificatePem()
		return nil
	case mtlscertificate.FieldPublicKeyPem:
		m.ClearPublicKeyPem()
		return nil
	case mtlscertificate.FieldDNSNames:
		m.ClearDNSNames()
		return nil
	case mtlscertificate.FieldIPAddresses:
		m.ClearIPAddresses()
		return nil
	case mtlscertificate.FieldEmailAddresses:
		m.ClearEmailAddresses()
		return nil
	case mtlscertificate.FieldUris:
		m.ClearUris()
		return nil
	case mtlscertificate.FieldCertType:
		m.ClearCertType()
		return nil
	case mtlscertificate.FieldStatus:
		m.ClearStatus()
		return nil
	case mtlscertificate.FieldPathLenConstraint:
		m.ClearPathLenConstraint()
		return nil
	case mtlscertificate.FieldKeyUsage:
		m.ClearKeyUsage()
		return nil
	case mtlscertificate.FieldExtKeyUsage:
		m.ClearExtKeyUsage()
		return nil
	case mtlscertificate.FieldMetadata:
		m.ClearMetadata()
		return nil
	case mtlscertificate.FieldNotes:
		m.ClearNotes()
		return nil
	case mtlscertificate.FieldRequestID:
		m.ClearRequestID()
		return nil
	case mtlscertificate.FieldRevocationReason:
		m.ClearRevocationReason()
		return nil
	case mtlscertificate.FieldRevocationNotes:
		m.ClearRevocationNotes()
		return nil
	case mtlscertificate.FieldIssuedBy:
		m.ClearIssuedBy()
		return nil
	case mtlscertificate.FieldRevokedBy:
		m.ClearRevokedBy()
		return nil
	case mtlscertificate.FieldNotBefore:
		m.ClearNotBefore()
		return nil
	case mtlscertificate.FieldNotAfter:
		m.ClearNotAfter()
		return nil
	case mtlscertificate.FieldIssuedAt:
		m.ClearIssuedAt()
		return nil
	case mtlscertificate.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case mtlscertificate.FieldLastSeenAt:
		m.ClearLastSeenAt()
		return nil
	}
	return fmt.Errorf("unknown MtlsCertificate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MtlsCertificateMutation) ResetField(name string) error {
	switch name {
	case mtlscertificate.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case mtlscertificate.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case mtlscertificate.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case mtlscertificate.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case mtlscertificate.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case mtlscertificate.FieldTenantID:
		m.ResetTenantID()
		return nil
	case mtlscertificate.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case mtlscertificate.FieldClientID:
		m.ResetClientID()
		return nil
	case mtlscertificate.FieldCommonName:
		m.ResetCommonName()
		return nil
	case mtlscertificate.FieldSubjectDn:
		m.ResetSubjectDn()
		return nil
	case mtlscertificate.FieldIssuerDn:
		m.ResetIssuerDn()
		return nil
	case mtlscertificate.FieldIssuerName:
		m.ResetIssuerName()
		return nil
	case mtlscertificate.FieldFingerprintSha256:
		m.ResetFingerprintSha256()
		return nil
	case mtlscertificate.FieldFingerprintSha1:
		m.ResetFingerprintSha1()
		return nil
	case mtlscertificate.FieldPublicKeyAlgorithm:
		m.ResetPublicKeyAlgorithm()
		return nil
	case mtlscertificate.FieldPublicKeySize:
		m.ResetPublicKeySize()
		return nil
	case mtlscertificate.FieldSignatureAlgorithm:
		m.ResetSignatureAlgorithm()
		return nil
	case mtlscertificate.FieldCertificatePem:
		m.ResetCertificatePem()
		return nil
	case mtlscertificate.FieldPublicKeyPem:
		m.ResetPublicKeyPem()
		return nil
	case mtlscertificate.FieldDNSNames:
		m.ResetDNSNames()
		return nil
	case mtlscertificate.FieldIPAddresses:
		m.ResetIPAddresses()
		return nil
	case mtlscertificate.FieldEmailAddresses:
		m.ResetEmailAddresses()
		return nil
	case mtlscertificate.FieldUris:
		m.ResetUris()
		return nil
	case mtlscertificate.FieldCertType:
		m.ResetCertType()
		return nil
	case mtlscertificate.FieldStatus:
		m.ResetStatus()
		return nil
	case mtlscertificate.FieldIsCa:
		m.ResetIsCa()
		return nil
	case mtlscertificate.FieldPathLenConstraint:
		m.ResetPathLenConstraint()
		return nil
	case mtlscertificate.FieldKeyUsage:
		m.ResetKeyUsage()
		return nil
	case mtlscertificate.FieldExtKeyUsage:
		m.ResetExtKeyUsage()
		return nil
	case mtlscertificate.FieldMetadata:
		m.ResetMetadata()
		return nil
	case mtlscertificate.FieldNotes:
		m.ResetNotes()
		return nil
	case mtlscertificate.FieldRequestID:
		m.ResetRequestID()
		return nil
	case mtlscertificate.FieldRevocationReason:
		m.ResetRevocationReason()
		return nil
	case mtlscertificate.FieldRevocationNotes:
		m.ResetRevocationNotes()
		return nil
	case mtlscertificate.FieldIssuedBy:
		m.ResetIssuedBy()
		return nil
	case mtlscertificate.FieldRevokedBy:
		m.ResetRevokedBy()
		return nil
	case mtlscertificate.FieldNotBefore:
		m.ResetNotBefore()
		return nil
	case mtlscertificate.FieldNotAfter:
		m.ResetNotAfter()
		return nil
	case mtlscertificate.FieldIssuedAt:
		m.ResetIssuedAt()
		return nil
	case mtlscertificate.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case mtlscertificate.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	}
	return fmt.Errorf("unknown MtlsCertificate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MtlsCertificateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.lcm_client != nil {
		edges = append(edges, mtlscertificate.EdgeLcmClient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MtlsCertificateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mtlscertificate.EdgeLcmClient:
		if id := m.lcm_client; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MtlsCertificateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MtlsCertificateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MtlsCertificateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlcm_client {
		edges = append(edges, mtlscertificate.EdgeLcmClient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MtlsCertificateMutation) EdgeCleared(name string) bool {
	switch name {
	case mtlscertificate.EdgeLcmClient:
		return m.clearedlcm_client
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MtlsCertificateMutation) ClearEdge(name string) error {
	switch name {
	case mtlscertificate.EdgeLcmClient:
		m.ClearLcmClient()
		return nil
	}
	return fmt.Errorf("unknown MtlsCertificate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MtlsCertificateMutation) ResetEdge(name string) error {
	switch name {
	case mtlscertificate.EdgeLcmClient:
		m.ResetLcmClient()
		return nil
	}
	return fmt.Errorf("unknown MtlsCertificate edge %s", name)
}

// MtlsCertificateRequestMutation represents an operation that mutates the MtlsCertificateRequest nodes in the graph.
type MtlsCertificateRequestMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint32
	create_by             *uint32
	addcreate_by          *int32
	update_by             *uint32
	addupdate_by          *int32
	create_time           *time.Time
	update_time           *time.Time
	delete_time           *time.Time
	tenant_id             *uint32
	addtenant_id          *int32
	request_id            *string
	client_id             *string
	common_name           *string
	csr_pem               *string
	public_key            *string
	dns_names             *[]string
	appenddns_names       []string
	ip_addresses          *[]string
	appendip_addresses    []string
	issuer_name           *string
	cert_type             *mtlscertificaterequest.CertType
	status                *mtlscertificaterequest.Status
	validity_days         *int32
	addvalidity_days      *int32
	reject_reason         *string
	metadata              *map[string]string
	notes                 *string
	approved_by           *uint32
	addapproved_by        *int32
	rejected_by           *uint32
	addrejected_by        *int32
	approved_at           *time.Time
	rejected_at           *time.Time
	expires_at            *time.Time
	certificate_serial    *int64
	addcertificate_serial *int64
	clearedFields         map[string]struct{}
	lcm_client            *uint32
	clearedlcm_client     bool
	done                  bool
	oldValue              func(context.Context) (*MtlsCertificateRequest, error)
	predicates            []predicate.MtlsCertificateRequest
}

var _ ent.Mutation = (*MtlsCertificateRequestMutation)(nil)

// mtlscertificaterequestOption allows management of the mutation configuration using functional options.
type mtlscertificaterequestOption func(*MtlsCertificateRequestMutation)

// newMtlsCertificateRequestMutation creates new mutation for the MtlsCertificateRequest entity.
func newMtlsCertificateRequestMutation(c config, op Op, opts ...mtlscertificaterequestOption) *MtlsCertificateRequestMutation {
	m := &MtlsCertificateRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeMtlsCertificateRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMtlsCertificateRequestID sets the ID field of the mutation.
func withMtlsCertificateRequestID(id uint32) mtlscertificaterequestOption {
	return func(m *MtlsCertificateRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *MtlsCertificateRequest
		)
		m.oldValue = func(ctx context.Context) (*MtlsCertificateRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MtlsCertificateRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMtlsCertificateRequest sets the old MtlsCertificateRequest of the mutation.
func withMtlsCertificateRequest(node *MtlsCertificateRequest) mtlscertificaterequestOption {
	return func(m *MtlsCertificateRequestMutation) {
		m.oldValue = func(context.Context) (*MtlsCertificateRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MtlsCertificateRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MtlsCertificateRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MtlsCertificateRequest entities.
func (m *MtlsCertificateRequestMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MtlsCertificateRequestMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MtlsCertificateRequestMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MtlsCertificateRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *MtlsCertificateRequestMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *MtlsCertificateRequestMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *MtlsCertificateRequestMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *MtlsCertificateRequestMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *MtlsCertificateRequestMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[mtlscertificaterequest.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *MtlsCertificateRequestMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *MtlsCertificateRequestMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *MtlsCertificateRequestMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *MtlsCertificateRequestMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *MtlsCertificateRequestMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *MtlsCertificateRequestMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[mtlscertificaterequest.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *MtlsCertificateRequestMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *MtlsCertificateRequestMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MtlsCertificateRequestMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *MtlsCertificateRequestMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[mtlscertificaterequest.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MtlsCertificateRequestMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *MtlsCertificateRequestMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MtlsCertificateRequestMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *MtlsCertificateRequestMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[mtlscertificaterequest.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MtlsCertificateRequestMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *MtlsCertificateRequestMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *MtlsCertificateRequestMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *MtlsCertificateRequestMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[mtlscertificaterequest.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *MtlsCertificateRequestMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *MtlsCertificateRequestMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *MtlsCertificateRequestMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *MtlsCertificateRequestMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *MtlsCertificateRequestMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *MtlsCertificateRequestMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[mtlscertificaterequest.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *MtlsCertificateRequestMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldTenantID)
}

// SetRequestID sets the "request_id" field.
func (m *MtlsCertificateRequestMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *MtlsCertificateRequestMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *MtlsCertificateRequestMutation) ResetRequestID() {
	m.request_id = nil
}

// SetClientID sets the "client_id" field.
func (m *MtlsCertificateRequestMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *MtlsCertificateRequestMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *MtlsCertificateRequestMutation) ResetClientID() {
	m.client_id = nil
}

// SetCommonName sets the "common_name" field.
func (m *MtlsCertificateRequestMutation) SetCommonName(s string) {
	m.common_name = &s
}

// CommonName returns the value of the "common_name" field in the mutation.
func (m *MtlsCertificateRequestMutation) CommonName() (r string, exists bool) {
	v := m.common_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCommonName returns the old "common_name" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldCommonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommonName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommonName: %w", err)
	}
	return oldValue.CommonName, nil
}

// ClearCommonName clears the value of the "common_name" field.
func (m *MtlsCertificateRequestMutation) ClearCommonName() {
	m.common_name = nil
	m.clearedFields[mtlscertificaterequest.FieldCommonName] = struct{}{}
}

// CommonNameCleared returns if the "common_name" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) CommonNameCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldCommonName]
	return ok
}

// ResetCommonName resets all changes to the "common_name" field.
func (m *MtlsCertificateRequestMutation) ResetCommonName() {
	m.common_name = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldCommonName)
}

// SetCsrPem sets the "csr_pem" field.
func (m *MtlsCertificateRequestMutation) SetCsrPem(s string) {
	m.csr_pem = &s
}

// CsrPem returns the value of the "csr_pem" field in the mutation.
func (m *MtlsCertificateRequestMutation) CsrPem() (r string, exists bool) {
	v := m.csr_pem
	if v == nil {
		return
	}
	return *v, true
}

// OldCsrPem returns the old "csr_pem" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldCsrPem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCsrPem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCsrPem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCsrPem: %w", err)
	}
	return oldValue.CsrPem, nil
}

// ClearCsrPem clears the value of the "csr_pem" field.
func (m *MtlsCertificateRequestMutation) ClearCsrPem() {
	m.csr_pem = nil
	m.clearedFields[mtlscertificaterequest.FieldCsrPem] = struct{}{}
}

// CsrPemCleared returns if the "csr_pem" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) CsrPemCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldCsrPem]
	return ok
}

// ResetCsrPem resets all changes to the "csr_pem" field.
func (m *MtlsCertificateRequestMutation) ResetCsrPem() {
	m.csr_pem = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldCsrPem)
}

// SetPublicKey sets the "public_key" field.
func (m *MtlsCertificateRequestMutation) SetPublicKey(s string) {
	m.public_key = &s
}

// PublicKey returns the value of the "public_key" field in the mutation.
func (m *MtlsCertificateRequestMutation) PublicKey() (r string, exists bool) {
	v := m.public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "public_key" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldPublicKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ClearPublicKey clears the value of the "public_key" field.
func (m *MtlsCertificateRequestMutation) ClearPublicKey() {
	m.public_key = nil
	m.clearedFields[mtlscertificaterequest.FieldPublicKey] = struct{}{}
}

// PublicKeyCleared returns if the "public_key" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) PublicKeyCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldPublicKey]
	return ok
}

// ResetPublicKey resets all changes to the "public_key" field.
func (m *MtlsCertificateRequestMutation) ResetPublicKey() {
	m.public_key = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldPublicKey)
}

// SetDNSNames sets the "dns_names" field.
func (m *MtlsCertificateRequestMutation) SetDNSNames(s []string) {
	m.dns_names = &s
	m.appenddns_names = nil
}

// DNSNames returns the value of the "dns_names" field in the mutation.
func (m *MtlsCertificateRequestMutation) DNSNames() (r []string, exists bool) {
	v := m.dns_names
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSNames returns the old "dns_names" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldDNSNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSNames: %w", err)
	}
	return oldValue.DNSNames, nil
}

// AppendDNSNames adds s to the "dns_names" field.
func (m *MtlsCertificateRequestMutation) AppendDNSNames(s []string) {
	m.appenddns_names = append(m.appenddns_names, s...)
}

// AppendedDNSNames returns the list of values that were appended to the "dns_names" field in this mutation.
func (m *MtlsCertificateRequestMutation) AppendedDNSNames() ([]string, bool) {
	if len(m.appenddns_names) == 0 {
		return nil, false
	}
	return m.appenddns_names, true
}

// ClearDNSNames clears the value of the "dns_names" field.
func (m *MtlsCertificateRequestMutation) ClearDNSNames() {
	m.dns_names = nil
	m.appenddns_names = nil
	m.clearedFields[mtlscertificaterequest.FieldDNSNames] = struct{}{}
}

// DNSNamesCleared returns if the "dns_names" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) DNSNamesCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldDNSNames]
	return ok
}

// ResetDNSNames resets all changes to the "dns_names" field.
func (m *MtlsCertificateRequestMutation) ResetDNSNames() {
	m.dns_names = nil
	m.appenddns_names = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldDNSNames)
}

// SetIPAddresses sets the "ip_addresses" field.
func (m *MtlsCertificateRequestMutation) SetIPAddresses(s []string) {
	m.ip_addresses = &s
	m.appendip_addresses = nil
}

// IPAddresses returns the value of the "ip_addresses" field in the mutation.
func (m *MtlsCertificateRequestMutation) IPAddresses() (r []string, exists bool) {
	v := m.ip_addresses
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddresses returns the old "ip_addresses" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldIPAddresses(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddresses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddresses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddresses: %w", err)
	}
	return oldValue.IPAddresses, nil
}

// AppendIPAddresses adds s to the "ip_addresses" field.
func (m *MtlsCertificateRequestMutation) AppendIPAddresses(s []string) {
	m.appendip_addresses = append(m.appendip_addresses, s...)
}

// AppendedIPAddresses returns the list of values that were appended to the "ip_addresses" field in this mutation.
func (m *MtlsCertificateRequestMutation) AppendedIPAddresses() ([]string, bool) {
	if len(m.appendip_addresses) == 0 {
		return nil, false
	}
	return m.appendip_addresses, true
}

// ClearIPAddresses clears the value of the "ip_addresses" field.
func (m *MtlsCertificateRequestMutation) ClearIPAddresses() {
	m.ip_addresses = nil
	m.appendip_addresses = nil
	m.clearedFields[mtlscertificaterequest.FieldIPAddresses] = struct{}{}
}

// IPAddressesCleared returns if the "ip_addresses" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) IPAddressesCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldIPAddresses]
	return ok
}

// ResetIPAddresses resets all changes to the "ip_addresses" field.
func (m *MtlsCertificateRequestMutation) ResetIPAddresses() {
	m.ip_addresses = nil
	m.appendip_addresses = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldIPAddresses)
}

// SetIssuerName sets the "issuer_name" field.
func (m *MtlsCertificateRequestMutation) SetIssuerName(s string) {
	m.issuer_name = &s
}

// IssuerName returns the value of the "issuer_name" field in the mutation.
func (m *MtlsCertificateRequestMutation) IssuerName() (r string, exists bool) {
	v := m.issuer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerName returns the old "issuer_name" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldIssuerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerName: %w", err)
	}
	return oldValue.IssuerName, nil
}

// ClearIssuerName clears the value of the "issuer_name" field.
func (m *MtlsCertificateRequestMutation) ClearIssuerName() {
	m.issuer_name = nil
	m.clearedFields[mtlscertificaterequest.FieldIssuerName] = struct{}{}
}

// IssuerNameCleared returns if the "issuer_name" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) IssuerNameCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldIssuerName]
	return ok
}

// ResetIssuerName resets all changes to the "issuer_name" field.
func (m *MtlsCertificateRequestMutation) ResetIssuerName() {
	m.issuer_name = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldIssuerName)
}

// SetCertType sets the "cert_type" field.
func (m *MtlsCertificateRequestMutation) SetCertType(mt mtlscertificaterequest.CertType) {
	m.cert_type = &mt
}

// CertType returns the value of the "cert_type" field in the mutation.
func (m *MtlsCertificateRequestMutation) CertType() (r mtlscertificaterequest.CertType, exists bool) {
	v := m.cert_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCertType returns the old "cert_type" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldCertType(ctx context.Context) (v *mtlscertificaterequest.CertType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertType: %w", err)
	}
	return oldValue.CertType, nil
}

// ClearCertType clears the value of the "cert_type" field.
func (m *MtlsCertificateRequestMutation) ClearCertType() {
	m.cert_type = nil
	m.clearedFields[mtlscertificaterequest.FieldCertType] = struct{}{}
}

// CertTypeCleared returns if the "cert_type" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) CertTypeCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldCertType]
	return ok
}

// ResetCertType resets all changes to the "cert_type" field.
func (m *MtlsCertificateRequestMutation) ResetCertType() {
	m.cert_type = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldCertType)
}

// SetStatus sets the "status" field.
func (m *MtlsCertificateRequestMutation) SetStatus(value mtlscertificaterequest.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MtlsCertificateRequestMutation) Status() (r mtlscertificaterequest.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldStatus(ctx context.Context) (v *mtlscertificaterequest.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *MtlsCertificateRequestMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[mtlscertificaterequest.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) StatusCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MtlsCertificateRequestMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldStatus)
}

// SetValidityDays sets the "validity_days" field.
func (m *MtlsCertificateRequestMutation) SetValidityDays(i int32) {
	m.validity_days = &i
	m.addvalidity_days = nil
}

// ValidityDays returns the value of the "validity_days" field in the mutation.
func (m *MtlsCertificateRequestMutation) ValidityDays() (r int32, exists bool) {
	v := m.validity_days
	if v == nil {
		return
	}
	return *v, true
}

// OldValidityDays returns the old "validity_days" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldValidityDays(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidityDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidityDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidityDays: %w", err)
	}
	return oldValue.ValidityDays, nil
}

// AddValidityDays adds i to the "validity_days" field.
func (m *MtlsCertificateRequestMutation) AddValidityDays(i int32) {
	if m.addvalidity_days != nil {
		*m.addvalidity_days += i
	} else {
		m.addvalidity_days = &i
	}
}

// AddedValidityDays returns the value that was added to the "validity_days" field in this mutation.
func (m *MtlsCertificateRequestMutation) AddedValidityDays() (r int32, exists bool) {
	v := m.addvalidity_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearValidityDays clears the value of the "validity_days" field.
func (m *MtlsCertificateRequestMutation) ClearValidityDays() {
	m.validity_days = nil
	m.addvalidity_days = nil
	m.clearedFields[mtlscertificaterequest.FieldValidityDays] = struct{}{}
}

// ValidityDaysCleared returns if the "validity_days" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) ValidityDaysCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldValidityDays]
	return ok
}

// ResetValidityDays resets all changes to the "validity_days" field.
func (m *MtlsCertificateRequestMutation) ResetValidityDays() {
	m.validity_days = nil
	m.addvalidity_days = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldValidityDays)
}

// SetRejectReason sets the "reject_reason" field.
func (m *MtlsCertificateRequestMutation) SetRejectReason(s string) {
	m.reject_reason = &s
}

// RejectReason returns the value of the "reject_reason" field in the mutation.
func (m *MtlsCertificateRequestMutation) RejectReason() (r string, exists bool) {
	v := m.reject_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRejectReason returns the old "reject_reason" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldRejectReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRejectReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRejectReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRejectReason: %w", err)
	}
	return oldValue.RejectReason, nil
}

// ClearRejectReason clears the value of the "reject_reason" field.
func (m *MtlsCertificateRequestMutation) ClearRejectReason() {
	m.reject_reason = nil
	m.clearedFields[mtlscertificaterequest.FieldRejectReason] = struct{}{}
}

// RejectReasonCleared returns if the "reject_reason" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) RejectReasonCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldRejectReason]
	return ok
}

// ResetRejectReason resets all changes to the "reject_reason" field.
func (m *MtlsCertificateRequestMutation) ResetRejectReason() {
	m.reject_reason = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldRejectReason)
}

// SetMetadata sets the "metadata" field.
func (m *MtlsCertificateRequestMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *MtlsCertificateRequestMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *MtlsCertificateRequestMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[mtlscertificaterequest.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *MtlsCertificateRequestMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldMetadata)
}

// SetNotes sets the "notes" field.
func (m *MtlsCertificateRequestMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *MtlsCertificateRequestMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *MtlsCertificateRequestMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[mtlscertificaterequest.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) NotesCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *MtlsCertificateRequestMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldNotes)
}

// SetApprovedBy sets the "approved_by" field.
func (m *MtlsCertificateRequestMutation) SetApprovedBy(u uint32) {
	m.approved_by = &u
	m.addapproved_by = nil
}

// ApprovedBy returns the value of the "approved_by" field in the mutation.
func (m *MtlsCertificateRequestMutation) ApprovedBy() (r uint32, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedBy returns the old "approved_by" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldApprovedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedBy: %w", err)
	}
	return oldValue.ApprovedBy, nil
}

// AddApprovedBy adds u to the "approved_by" field.
func (m *MtlsCertificateRequestMutation) AddApprovedBy(u int32) {
	if m.addapproved_by != nil {
		*m.addapproved_by += u
	} else {
		m.addapproved_by = &u
	}
}

// AddedApprovedBy returns the value that was added to the "approved_by" field in this mutation.
func (m *MtlsCertificateRequestMutation) AddedApprovedBy() (r int32, exists bool) {
	v := m.addapproved_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearApprovedBy clears the value of the "approved_by" field.
func (m *MtlsCertificateRequestMutation) ClearApprovedBy() {
	m.approved_by = nil
	m.addapproved_by = nil
	m.clearedFields[mtlscertificaterequest.FieldApprovedBy] = struct{}{}
}

// ApprovedByCleared returns if the "approved_by" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) ApprovedByCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldApprovedBy]
	return ok
}

// ResetApprovedBy resets all changes to the "approved_by" field.
func (m *MtlsCertificateRequestMutation) ResetApprovedBy() {
	m.approved_by = nil
	m.addapproved_by = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldApprovedBy)
}

// SetRejectedBy sets the "rejected_by" field.
func (m *MtlsCertificateRequestMutation) SetRejectedBy(u uint32) {
	m.rejected_by = &u
	m.addrejected_by = nil
}

// RejectedBy returns the value of the "rejected_by" field in the mutation.
func (m *MtlsCertificateRequestMutation) RejectedBy() (r uint32, exists bool) {
	v := m.rejected_by
	if v == nil {
		return
	}
	return *v, true
}

// OldRejectedBy returns the old "rejected_by" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldRejectedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRejectedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRejectedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRejectedBy: %w", err)
	}
	return oldValue.RejectedBy, nil
}

// AddRejectedBy adds u to the "rejected_by" field.
func (m *MtlsCertificateRequestMutation) AddRejectedBy(u int32) {
	if m.addrejected_by != nil {
		*m.addrejected_by += u
	} else {
		m.addrejected_by = &u
	}
}

// AddedRejectedBy returns the value that was added to the "rejected_by" field in this mutation.
func (m *MtlsCertificateRequestMutation) AddedRejectedBy() (r int32, exists bool) {
	v := m.addrejected_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearRejectedBy clears the value of the "rejected_by" field.
func (m *MtlsCertificateRequestMutation) ClearRejectedBy() {
	m.rejected_by = nil
	m.addrejected_by = nil
	m.clearedFields[mtlscertificaterequest.FieldRejectedBy] = struct{}{}
}

// RejectedByCleared returns if the "rejected_by" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) RejectedByCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldRejectedBy]
	return ok
}

// ResetRejectedBy resets all changes to the "rejected_by" field.
func (m *MtlsCertificateRequestMutation) ResetRejectedBy() {
	m.rejected_by = nil
	m.addrejected_by = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldRejectedBy)
}

// SetApprovedAt sets the "approved_at" field.
func (m *MtlsCertificateRequestMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *MtlsCertificateRequestMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldApprovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *MtlsCertificateRequestMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[mtlscertificaterequest.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *MtlsCertificateRequestMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldApprovedAt)
}

// SetRejectedAt sets the "rejected_at" field.
func (m *MtlsCertificateRequestMutation) SetRejectedAt(t time.Time) {
	m.rejected_at = &t
}

// RejectedAt returns the value of the "rejected_at" field in the mutation.
func (m *MtlsCertificateRequestMutation) RejectedAt() (r time.Time, exists bool) {
	v := m.rejected_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRejectedAt returns the old "rejected_at" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldRejectedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRejectedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRejectedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRejectedAt: %w", err)
	}
	return oldValue.RejectedAt, nil
}

// ClearRejectedAt clears the value of the "rejected_at" field.
func (m *MtlsCertificateRequestMutation) ClearRejectedAt() {
	m.rejected_at = nil
	m.clearedFields[mtlscertificaterequest.FieldRejectedAt] = struct{}{}
}

// RejectedAtCleared returns if the "rejected_at" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) RejectedAtCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldRejectedAt]
	return ok
}

// ResetRejectedAt resets all changes to the "rejected_at" field.
func (m *MtlsCertificateRequestMutation) ResetRejectedAt() {
	m.rejected_at = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldRejectedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *MtlsCertificateRequestMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *MtlsCertificateRequestMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *MtlsCertificateRequestMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[mtlscertificaterequest.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *MtlsCertificateRequestMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldExpiresAt)
}

// SetCertificateSerial sets the "certificate_serial" field.
func (m *MtlsCertificateRequestMutation) SetCertificateSerial(i int64) {
	m.certificate_serial = &i
	m.addcertificate_serial = nil
}

// CertificateSerial returns the value of the "certificate_serial" field in the mutation.
func (m *MtlsCertificateRequestMutation) CertificateSerial() (r int64, exists bool) {
	v := m.certificate_serial
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateSerial returns the old "certificate_serial" field's value of the MtlsCertificateRequest entity.
// If the MtlsCertificateRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MtlsCertificateRequestMutation) OldCertificateSerial(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateSerial: %w", err)
	}
	return oldValue.CertificateSerial, nil
}

// AddCertificateSerial adds i to the "certificate_serial" field.
func (m *MtlsCertificateRequestMutation) AddCertificateSerial(i int64) {
	if m.addcertificate_serial != nil {
		*m.addcertificate_serial += i
	} else {
		m.addcertificate_serial = &i
	}
}

// AddedCertificateSerial returns the value that was added to the "certificate_serial" field in this mutation.
func (m *MtlsCertificateRequestMutation) AddedCertificateSerial() (r int64, exists bool) {
	v := m.addcertificate_serial
	if v == nil {
		return
	}
	return *v, true
}

// ClearCertificateSerial clears the value of the "certificate_serial" field.
func (m *MtlsCertificateRequestMutation) ClearCertificateSerial() {
	m.certificate_serial = nil
	m.addcertificate_serial = nil
	m.clearedFields[mtlscertificaterequest.FieldCertificateSerial] = struct{}{}
}

// CertificateSerialCleared returns if the "certificate_serial" field was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) CertificateSerialCleared() bool {
	_, ok := m.clearedFields[mtlscertificaterequest.FieldCertificateSerial]
	return ok
}

// ResetCertificateSerial resets all changes to the "certificate_serial" field.
func (m *MtlsCertificateRequestMutation) ResetCertificateSerial() {
	m.certificate_serial = nil
	m.addcertificate_serial = nil
	delete(m.clearedFields, mtlscertificaterequest.FieldCertificateSerial)
}

// SetLcmClientID sets the "lcm_client" edge to the LcmClient entity by id.
func (m *MtlsCertificateRequestMutation) SetLcmClientID(id uint32) {
	m.lcm_client = &id
}

// ClearLcmClient clears the "lcm_client" edge to the LcmClient entity.
func (m *MtlsCertificateRequestMutation) ClearLcmClient() {
	m.clearedlcm_client = true
}

// LcmClientCleared reports if the "lcm_client" edge to the LcmClient entity was cleared.
func (m *MtlsCertificateRequestMutation) LcmClientCleared() bool {
	return m.clearedlcm_client
}

// LcmClientID returns the "lcm_client" edge ID in the mutation.
func (m *MtlsCertificateRequestMutation) LcmClientID() (id uint32, exists bool) {
	if m.lcm_client != nil {
		return *m.lcm_client, true
	}
	return
}

// LcmClientIDs returns the "lcm_client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LcmClientID instead. It exists only for internal usage by the builders.
func (m *MtlsCertificateRequestMutation) LcmClientIDs() (ids []uint32) {
	if id := m.lcm_client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLcmClient resets all changes to the "lcm_client" edge.
func (m *MtlsCertificateRequestMutation) ResetLcmClient() {
	m.lcm_client = nil
	m.clearedlcm_client = false
}

// Where appends a list predicates to the MtlsCertificateRequestMutation builder.
func (m *MtlsCertificateRequestMutation) Where(ps ...predicate.MtlsCertificateRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MtlsCertificateRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MtlsCertificateRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MtlsCertificateRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MtlsCertificateRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MtlsCertificateRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MtlsCertificateRequest).
func (m *MtlsCertificateRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MtlsCertificateRequestMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.create_by != nil {
		fields = append(fields, mtlscertificaterequest.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, mtlscertificaterequest.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, mtlscertificaterequest.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, mtlscertificaterequest.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, mtlscertificaterequest.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, mtlscertificaterequest.FieldTenantID)
	}
	if m.request_id != nil {
		fields = append(fields, mtlscertificaterequest.FieldRequestID)
	}
	if m.client_id != nil {
		fields = append(fields, mtlscertificaterequest.FieldClientID)
	}
	if m.common_name != nil {
		fields = append(fields, mtlscertificaterequest.FieldCommonName)
	}
	if m.csr_pem != nil {
		fields = append(fields, mtlscertificaterequest.FieldCsrPem)
	}
	if m.public_key != nil {
		fields = append(fields, mtlscertificaterequest.FieldPublicKey)
	}
	if m.dns_names != nil {
		fields = append(fields, mtlscertificaterequest.FieldDNSNames)
	}
	if m.ip_addresses != nil {
		fields = append(fields, mtlscertificaterequest.FieldIPAddresses)
	}
	if m.issuer_name != nil {
		fields = append(fields, mtlscertificaterequest.FieldIssuerName)
	}
	if m.cert_type != nil {
		fields = append(fields, mtlscertificaterequest.FieldCertType)
	}
	if m.status != nil {
		fields = append(fields, mtlscertificaterequest.FieldStatus)
	}
	if m.validity_days != nil {
		fields = append(fields, mtlscertificaterequest.FieldValidityDays)
	}
	if m.reject_reason != nil {
		fields = append(fields, mtlscertificaterequest.FieldRejectReason)
	}
	if m.metadata != nil {
		fields = append(fields, mtlscertificaterequest.FieldMetadata)
	}
	if m.notes != nil {
		fields = append(fields, mtlscertificaterequest.FieldNotes)
	}
	if m.approved_by != nil {
		fields = append(fields, mtlscertificaterequest.FieldApprovedBy)
	}
	if m.rejected_by != nil {
		fields = append(fields, mtlscertificaterequest.FieldRejectedBy)
	}
	if m.approved_at != nil {
		fields = append(fields, mtlscertificaterequest.FieldApprovedAt)
	}
	if m.rejected_at != nil {
		fields = append(fields, mtlscertificaterequest.FieldRejectedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, mtlscertificaterequest.FieldExpiresAt)
	}
	if m.certificate_serial != nil {
		fields = append(fields, mtlscertificaterequest.FieldCertificateSerial)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MtlsCertificateRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mtlscertificaterequest.FieldCreateBy:
		return m.CreateBy()
	case mtlscertificaterequest.FieldUpdateBy:
		return m.UpdateBy()
	case mtlscertificaterequest.FieldCreateTime:
		return m.CreateTime()
	case mtlscertificaterequest.FieldUpdateTime:
		return m.UpdateTime()
	case mtlscertificaterequest.FieldDeleteTime:
		return m.DeleteTime()
	case mtlscertificaterequest.FieldTenantID:
		return m.TenantID()
	case mtlscertificaterequest.FieldRequestID:
		return m.RequestID()
	case mtlscertificaterequest.FieldClientID:
		return m.ClientID()
	case mtlscertificaterequest.FieldCommonName:
		return m.CommonName()
	case mtlscertificaterequest.FieldCsrPem:
		return m.CsrPem()
	case mtlscertificaterequest.FieldPublicKey:
		return m.PublicKey()
	case mtlscertificaterequest.FieldDNSNames:
		return m.DNSNames()
	case mtlscertificaterequest.FieldIPAddresses:
		return m.IPAddresses()
	case mtlscertificaterequest.FieldIssuerName:
		return m.IssuerName()
	case mtlscertificaterequest.FieldCertType:
		return m.CertType()
	case mtlscertificaterequest.FieldStatus:
		return m.Status()
	case mtlscertificaterequest.FieldValidityDays:
		return m.ValidityDays()
	case mtlscertificaterequest.FieldRejectReason:
		return m.RejectReason()
	case mtlscertificaterequest.FieldMetadata:
		return m.Metadata()
	case mtlscertificaterequest.FieldNotes:
		return m.Notes()
	case mtlscertificaterequest.FieldApprovedBy:
		return m.ApprovedBy()
	case mtlscertificaterequest.FieldRejectedBy:
		return m.RejectedBy()
	case mtlscertificaterequest.FieldApprovedAt:
		return m.ApprovedAt()
	case mtlscertificaterequest.FieldRejectedAt:
		return m.RejectedAt()
	case mtlscertificaterequest.FieldExpiresAt:
		return m.ExpiresAt()
	case mtlscertificaterequest.FieldCertificateSerial:
		return m.CertificateSerial()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MtlsCertificateRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mtlscertificaterequest.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case mtlscertificaterequest.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case mtlscertificaterequest.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case mtlscertificaterequest.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case mtlscertificaterequest.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case mtlscertificaterequest.FieldTenantID:
		return m.OldTenantID(ctx)
	case mtlscertificaterequest.FieldRequestID:
		return m.OldRequestID(ctx)
	case mtlscertificaterequest.FieldClientID:
		return m.OldClientID(ctx)
	case mtlscertificaterequest.FieldCommonName:
		return m.OldCommonName(ctx)
	case mtlscertificaterequest.FieldCsrPem:
		return m.OldCsrPem(ctx)
	case mtlscertificaterequest.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case mtlscertificaterequest.FieldDNSNames:
		return m.OldDNSNames(ctx)
	case mtlscertificaterequest.FieldIPAddresses:
		return m.OldIPAddresses(ctx)
	case mtlscertificaterequest.FieldIssuerName:
		return m.OldIssuerName(ctx)
	case mtlscertificaterequest.FieldCertType:
		return m.OldCertType(ctx)
	case mtlscertificaterequest.FieldStatus:
		return m.OldStatus(ctx)
	case mtlscertificaterequest.FieldValidityDays:
		return m.OldValidityDays(ctx)
	case mtlscertificaterequest.FieldRejectReason:
		return m.OldRejectReason(ctx)
	case mtlscertificaterequest.FieldMetadata:
		return m.OldMetadata(ctx)
	case mtlscertificaterequest.FieldNotes:
		return m.OldNotes(ctx)
	case mtlscertificaterequest.FieldApprovedBy:
		return m.OldApprovedBy(ctx)
	case mtlscertificaterequest.FieldRejectedBy:
		return m.OldRejectedBy(ctx)
	case mtlscertificaterequest.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case mtlscertificaterequest.FieldRejectedAt:
		return m.OldRejectedAt(ctx)
	case mtlscertificaterequest.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case mtlscertificaterequest.FieldCertificateSerial:
		return m.OldCertificateSerial(ctx)
	}
	return nil, fmt.Errorf("unknown MtlsCertificateRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MtlsCertificateRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mtlscertificaterequest.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case mtlscertificaterequest.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case mtlscertificaterequest.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case mtlscertificaterequest.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case mtlscertificaterequest.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case mtlscertificaterequest.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case mtlscertificaterequest.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case mtlscertificaterequest.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case mtlscertificaterequest.FieldCommonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommonName(v)
		return nil
	case mtlscertificaterequest.FieldCsrPem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCsrPem(v)
		return nil
	case mtlscertificaterequest.FieldPublicKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case mtlscertificaterequest.FieldDNSNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSNames(v)
		return nil
	case mtlscertificaterequest.FieldIPAddresses:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddresses(v)
		return nil
	case mtlscertificaterequest.FieldIssuerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerName(v)
		return nil
	case mtlscertificaterequest.FieldCertType:
		v, ok := value.(mtlscertificaterequest.CertType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertType(v)
		return nil
	case mtlscertificaterequest.FieldStatus:
		v, ok := value.(mtlscertificaterequest.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case mtlscertificaterequest.FieldValidityDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidityDays(v)
		return nil
	case mtlscertificaterequest.FieldRejectReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRejectReason(v)
		return nil
	case mtlscertificaterequest.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case mtlscertificaterequest.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case mtlscertificaterequest.FieldApprovedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedBy(v)
		return nil
	case mtlscertificaterequest.FieldRejectedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRejectedBy(v)
		return nil
	case mtlscertificaterequest.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case mtlscertificaterequest.FieldRejectedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRejectedAt(v)
		return nil
	case mtlscertificaterequest.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case mtlscertificaterequest.FieldCertificateSerial:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateSerial(v)
		return nil
	}
	return fmt.Errorf("unknown MtlsCertificateRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MtlsCertificateRequestMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, mtlscertificaterequest.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, mtlscertificaterequest.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, mtlscertificaterequest.FieldTenantID)
	}
	if m.addvalidity_days != nil {
		fields = append(fields, mtlscertificaterequest.FieldValidityDays)
	}
	if m.addapproved_by != nil {
		fields = append(fields, mtlscertificaterequest.FieldApprovedBy)
	}
	if m.addrejected_by != nil {
		fields = append(fields, mtlscertificaterequest.FieldRejectedBy)
	}
	if m.addcertificate_serial != nil {
		fields = append(fields, mtlscertificaterequest.FieldCertificateSerial)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MtlsCertificateRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mtlscertificaterequest.FieldCreateBy:
		return m.AddedCreateBy()
	case mtlscertificaterequest.FieldUpdateBy:
		return m.AddedUpdateBy()
	case mtlscertificaterequest.FieldTenantID:
		return m.AddedTenantID()
	case mtlscertificaterequest.FieldValidityDays:
		return m.AddedValidityDays()
	case mtlscertificaterequest.FieldApprovedBy:
		return m.AddedApprovedBy()
	case mtlscertificaterequest.FieldRejectedBy:
		return m.AddedRejectedBy()
	case mtlscertificaterequest.FieldCertificateSerial:
		return m.AddedCertificateSerial()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MtlsCertificateRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mtlscertificaterequest.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case mtlscertificaterequest.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case mtlscertificaterequest.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case mtlscertificaterequest.FieldValidityDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValidityDays(v)
		return nil
	case mtlscertificaterequest.FieldApprovedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApprovedBy(v)
		return nil
	case mtlscertificaterequest.FieldRejectedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRejectedBy(v)
		return nil
	case mtlscertificaterequest.FieldCertificateSerial:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCertificateSerial(v)
		return nil
	}
	return fmt.Errorf("unknown MtlsCertificateRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MtlsCertificateRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mtlscertificaterequest.FieldCreateBy) {
		fields = append(fields, mtlscertificaterequest.FieldCreateBy)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldUpdateBy) {
		fields = append(fields, mtlscertificaterequest.FieldUpdateBy)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldCreateTime) {
		fields = append(fields, mtlscertificaterequest.FieldCreateTime)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldUpdateTime) {
		fields = append(fields, mtlscertificaterequest.FieldUpdateTime)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldDeleteTime) {
		fields = append(fields, mtlscertificaterequest.FieldDeleteTime)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldTenantID) {
		fields = append(fields, mtlscertificaterequest.FieldTenantID)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldCommonName) {
		fields = append(fields, mtlscertificaterequest.FieldCommonName)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldCsrPem) {
		fields = append(fields, mtlscertificaterequest.FieldCsrPem)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldPublicKey) {
		fields = append(fields, mtlscertificaterequest.FieldPublicKey)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldDNSNames) {
		fields = append(fields, mtlscertificaterequest.FieldDNSNames)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldIPAddresses) {
		fields = append(fields, mtlscertificaterequest.FieldIPAddresses)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldIssuerName) {
		fields = append(fields, mtlscertificaterequest.FieldIssuerName)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldCertType) {
		fields = append(fields, mtlscertificaterequest.FieldCertType)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldStatus) {
		fields = append(fields, mtlscertificaterequest.FieldStatus)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldValidityDays) {
		fields = append(fields, mtlscertificaterequest.FieldValidityDays)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldRejectReason) {
		fields = append(fields, mtlscertificaterequest.FieldRejectReason)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldMetadata) {
		fields = append(fields, mtlscertificaterequest.FieldMetadata)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldNotes) {
		fields = append(fields, mtlscertificaterequest.FieldNotes)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldApprovedBy) {
		fields = append(fields, mtlscertificaterequest.FieldApprovedBy)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldRejectedBy) {
		fields = append(fields, mtlscertificaterequest.FieldRejectedBy)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldApprovedAt) {
		fields = append(fields, mtlscertificaterequest.FieldApprovedAt)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldRejectedAt) {
		fields = append(fields, mtlscertificaterequest.FieldRejectedAt)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldExpiresAt) {
		fields = append(fields, mtlscertificaterequest.FieldExpiresAt)
	}
	if m.FieldCleared(mtlscertificaterequest.FieldCertificateSerial) {
		fields = append(fields, mtlscertificaterequest.FieldCertificateSerial)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MtlsCertificateRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MtlsCertificateRequestMutation) ClearField(name string) error {
	switch name {
	case mtlscertificaterequest.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case mtlscertificaterequest.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case mtlscertificaterequest.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case mtlscertificaterequest.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case mtlscertificaterequest.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case mtlscertificaterequest.FieldTenantID:
		m.ClearTenantID()
		return nil
	case mtlscertificaterequest.FieldCommonName:
		m.ClearCommonName()
		return nil
	case mtlscertificaterequest.FieldCsrPem:
		m.ClearCsrPem()
		return nil
	case mtlscertificaterequest.FieldPublicKey:
		m.ClearPublicKey()
		return nil
	case mtlscertificaterequest.FieldDNSNames:
		m.ClearDNSNames()
		return nil
	case mtlscertificaterequest.FieldIPAddresses:
		m.ClearIPAddresses()
		return nil
	case mtlscertificaterequest.FieldIssuerName:
		m.ClearIssuerName()
		return nil
	case mtlscertificaterequest.FieldCertType:
		m.ClearCertType()
		return nil
	case mtlscertificaterequest.FieldStatus:
		m.ClearStatus()
		return nil
	case mtlscertificaterequest.FieldValidityDays:
		m.ClearValidityDays()
		return nil
	case mtlscertificaterequest.FieldRejectReason:
		m.ClearRejectReason()
		return nil
	case mtlscertificaterequest.FieldMetadata:
		m.ClearMetadata()
		return nil
	case mtlscertificaterequest.FieldNotes:
		m.ClearNotes()
		return nil
	case mtlscertificaterequest.FieldApprovedBy:
		m.ClearApprovedBy()
		return nil
	case mtlscertificaterequest.FieldRejectedBy:
		m.ClearRejectedBy()
		return nil
	case mtlscertificaterequest.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case mtlscertificaterequest.FieldRejectedAt:
		m.ClearRejectedAt()
		return nil
	case mtlscertificaterequest.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case mtlscertificaterequest.FieldCertificateSerial:
		m.ClearCertificateSerial()
		return nil
	}
	return fmt.Errorf("unknown MtlsCertificateRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MtlsCertificateRequestMutation) ResetField(name string) error {
	switch name {
	case mtlscertificaterequest.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case mtlscertificaterequest.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case mtlscertificaterequest.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case mtlscertificaterequest.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case mtlscertificaterequest.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case mtlscertificaterequest.FieldTenantID:
		m.ResetTenantID()
		return nil
	case mtlscertificaterequest.FieldRequestID:
		m.ResetRequestID()
		return nil
	case mtlscertificaterequest.FieldClientID:
		m.ResetClientID()
		return nil
	case mtlscertificaterequest.FieldCommonName:
		m.ResetCommonName()
		return nil
	case mtlscertificaterequest.FieldCsrPem:
		m.ResetCsrPem()
		return nil
	case mtlscertificaterequest.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case mtlscertificaterequest.FieldDNSNames:
		m.ResetDNSNames()
		return nil
	case mtlscertificaterequest.FieldIPAddresses:
		m.ResetIPAddresses()
		return nil
	case mtlscertificaterequest.FieldIssuerName:
		m.ResetIssuerName()
		return nil
	case mtlscertificaterequest.FieldCertType:
		m.ResetCertType()
		return nil
	case mtlscertificaterequest.FieldStatus:
		m.ResetStatus()
		return nil
	case mtlscertificaterequest.FieldValidityDays:
		m.ResetValidityDays()
		return nil
	case mtlscertificaterequest.FieldRejectReason:
		m.ResetRejectReason()
		return nil
	case mtlscertificaterequest.FieldMetadata:
		m.ResetMetadata()
		return nil
	case mtlscertificaterequest.FieldNotes:
		m.ResetNotes()
		return nil
	case mtlscertificaterequest.FieldApprovedBy:
		m.ResetApprovedBy()
		return nil
	case mtlscertificaterequest.FieldRejectedBy:
		m.ResetRejectedBy()
		return nil
	case mtlscertificaterequest.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case mtlscertificaterequest.FieldRejectedAt:
		m.ResetRejectedAt()
		return nil
	case mtlscertificaterequest.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case mtlscertificaterequest.FieldCertificateSerial:
		m.ResetCertificateSerial()
		return nil
	}
	return fmt.Errorf("unknown MtlsCertificateRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MtlsCertificateRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.lcm_client != nil {
		edges = append(edges, mtlscertificaterequest.EdgeLcmClient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MtlsCertificateRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mtlscertificaterequest.EdgeLcmClient:
		if id := m.lcm_client; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MtlsCertificateRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MtlsCertificateRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MtlsCertificateRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlcm_client {
		edges = append(edges, mtlscertificaterequest.EdgeLcmClient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MtlsCertificateRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case mtlscertificaterequest.EdgeLcmClient:
		return m.clearedlcm_client
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MtlsCertificateRequestMutation) ClearEdge(name string) error {
	switch name {
	case mtlscertificaterequest.EdgeLcmClient:
		m.ClearLcmClient()
		return nil
	}
	return fmt.Errorf("unknown MtlsCertificateRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MtlsCertificateRequestMutation) ResetEdge(name string) error {
	switch name {
	case mtlscertificaterequest.EdgeLcmClient:
		m.ResetLcmClient()
		return nil
	}
	return fmt.Errorf("unknown MtlsCertificateRequest edge %s", name)
}

// SelfSignedIssuerMutation represents an operation that mutates the SelfSignedIssuer nodes in the graph.
type SelfSignedIssuerMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	common_name                *string
	dns_names                  *[]string
	appenddns_names            []string
	ip_addresses               *[]string
	appendip_addresses         []string
	ca_common_name             *string
	ca_organization            *string
	ca_organizational_unit     *string
	ca_country                 *string
	ca_province                *string
	ca_locality                *string
	ca_validity_days           *int32
	addca_validity_days        *int32
	ca_certificate_pem         *string
	ca_private_key_pem         *string
	ca_certificate_fingerprint *string
	ca_expires_at              *time.Time
	created_at                 *time.Time
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	issuer                     *uint32
	clearedissuer              bool
	done                       bool
	oldValue                   func(context.Context) (*SelfSignedIssuer, error)
	predicates                 []predicate.SelfSignedIssuer
}

var _ ent.Mutation = (*SelfSignedIssuerMutation)(nil)

// selfsignedissuerOption allows management of the mutation configuration using functional options.
type selfsignedissuerOption func(*SelfSignedIssuerMutation)

// newSelfSignedIssuerMutation creates new mutation for the SelfSignedIssuer entity.
func newSelfSignedIssuerMutation(c config, op Op, opts ...selfsignedissuerOption) *SelfSignedIssuerMutation {
	m := &SelfSignedIssuerMutation{
		config:        c,
		op:            op,
		typ:           TypeSelfSignedIssuer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSelfSignedIssuerID sets the ID field of the mutation.
func withSelfSignedIssuerID(id int) selfsignedissuerOption {
	return func(m *SelfSignedIssuerMutation) {
		var (
			err   error
			once  sync.Once
			value *SelfSignedIssuer
		)
		m.oldValue = func(ctx context.Context) (*SelfSignedIssuer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SelfSignedIssuer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSelfSignedIssuer sets the old SelfSignedIssuer of the mutation.
func withSelfSignedIssuer(node *SelfSignedIssuer) selfsignedissuerOption {
	return func(m *SelfSignedIssuerMutation) {
		m.oldValue = func(context.Context) (*SelfSignedIssuer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SelfSignedIssuerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SelfSignedIssuerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SelfSignedIssuerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SelfSignedIssuerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SelfSignedIssuer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCommonName sets the "common_name" field.
func (m *SelfSignedIssuerMutation) SetCommonName(s string) {
	m.common_name = &s
}

// CommonName returns the value of the "common_name" field in the mutation.
func (m *SelfSignedIssuerMutation) CommonName() (r string, exists bool) {
	v := m.common_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCommonName returns the old "common_name" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldCommonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommonName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommonName: %w", err)
	}
	return oldValue.CommonName, nil
}

// ResetCommonName resets all changes to the "common_name" field.
func (m *SelfSignedIssuerMutation) ResetCommonName() {
	m.common_name = nil
}

// SetDNSNames sets the "dns_names" field.
func (m *SelfSignedIssuerMutation) SetDNSNames(s []string) {
	m.dns_names = &s
	m.appenddns_names = nil
}

// DNSNames returns the value of the "dns_names" field in the mutation.
func (m *SelfSignedIssuerMutation) DNSNames() (r []string, exists bool) {
	v := m.dns_names
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSNames returns the old "dns_names" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldDNSNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSNames: %w", err)
	}
	return oldValue.DNSNames, nil
}

// AppendDNSNames adds s to the "dns_names" field.
func (m *SelfSignedIssuerMutation) AppendDNSNames(s []string) {
	m.appenddns_names = append(m.appenddns_names, s...)
}

// AppendedDNSNames returns the list of values that were appended to the "dns_names" field in this mutation.
func (m *SelfSignedIssuerMutation) AppendedDNSNames() ([]string, bool) {
	if len(m.appenddns_names) == 0 {
		return nil, false
	}
	return m.appenddns_names, true
}

// ClearDNSNames clears the value of the "dns_names" field.
func (m *SelfSignedIssuerMutation) ClearDNSNames() {
	m.dns_names = nil
	m.appenddns_names = nil
	m.clearedFields[selfsignedissuer.FieldDNSNames] = struct{}{}
}

// DNSNamesCleared returns if the "dns_names" field was cleared in this mutation.
func (m *SelfSignedIssuerMutation) DNSNamesCleared() bool {
	_, ok := m.clearedFields[selfsignedissuer.FieldDNSNames]
	return ok
}

// ResetDNSNames resets all changes to the "dns_names" field.
func (m *SelfSignedIssuerMutation) ResetDNSNames() {
	m.dns_names = nil
	m.appenddns_names = nil
	delete(m.clearedFields, selfsignedissuer.FieldDNSNames)
}

// SetIPAddresses sets the "ip_addresses" field.
func (m *SelfSignedIssuerMutation) SetIPAddresses(s []string) {
	m.ip_addresses = &s
	m.appendip_addresses = nil
}

// IPAddresses returns the value of the "ip_addresses" field in the mutation.
func (m *SelfSignedIssuerMutation) IPAddresses() (r []string, exists bool) {
	v := m.ip_addresses
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddresses returns the old "ip_addresses" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldIPAddresses(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddresses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddresses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddresses: %w", err)
	}
	return oldValue.IPAddresses, nil
}

// AppendIPAddresses adds s to the "ip_addresses" field.
func (m *SelfSignedIssuerMutation) AppendIPAddresses(s []string) {
	m.appendip_addresses = append(m.appendip_addresses, s...)
}

// AppendedIPAddresses returns the list of values that were appended to the "ip_addresses" field in this mutation.
func (m *SelfSignedIssuerMutation) AppendedIPAddresses() ([]string, bool) {
	if len(m.appendip_addresses) == 0 {
		return nil, false
	}
	return m.appendip_addresses, true
}

// ClearIPAddresses clears the value of the "ip_addresses" field.
func (m *SelfSignedIssuerMutation) ClearIPAddresses() {
	m.ip_addresses = nil
	m.appendip_addresses = nil
	m.clearedFields[selfsignedissuer.FieldIPAddresses] = struct{}{}
}

// IPAddressesCleared returns if the "ip_addresses" field was cleared in this mutation.
func (m *SelfSignedIssuerMutation) IPAddressesCleared() bool {
	_, ok := m.clearedFields[selfsignedissuer.FieldIPAddresses]
	return ok
}

// ResetIPAddresses resets all changes to the "ip_addresses" field.
func (m *SelfSignedIssuerMutation) ResetIPAddresses() {
	m.ip_addresses = nil
	m.appendip_addresses = nil
	delete(m.clearedFields, selfsignedissuer.FieldIPAddresses)
}

// SetCaCommonName sets the "ca_common_name" field.
func (m *SelfSignedIssuerMutation) SetCaCommonName(s string) {
	m.ca_common_name = &s
}

// CaCommonName returns the value of the "ca_common_name" field in the mutation.
func (m *SelfSignedIssuerMutation) CaCommonName() (r string, exists bool) {
	v := m.ca_common_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCaCommonName returns the old "ca_common_name" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldCaCommonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaCommonName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaCommonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaCommonName: %w", err)
	}
	return oldValue.CaCommonName, nil
}

// ResetCaCommonName resets all changes to the "ca_common_name" field.
func (m *SelfSignedIssuerMutation) ResetCaCommonName() {
	m.ca_common_name = nil
}

// SetCaOrganization sets the "ca_organization" field.
func (m *SelfSignedIssuerMutation) SetCaOrganization(s string) {
	m.ca_organization = &s
}

// CaOrganization returns the value of the "ca_organization" field in the mutation.
func (m *SelfSignedIssuerMutation) CaOrganization() (r string, exists bool) {
	v := m.ca_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldCaOrganization returns the old "ca_organization" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldCaOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaOrganization: %w", err)
	}
	return oldValue.CaOrganization, nil
}

// ClearCaOrganization clears the value of the "ca_organization" field.
func (m *SelfSignedIssuerMutation) ClearCaOrganization() {
	m.ca_organization = nil
	m.clearedFields[selfsignedissuer.FieldCaOrganization] = struct{}{}
}

// CaOrganizationCleared returns if the "ca_organization" field was cleared in this mutation.
func (m *SelfSignedIssuerMutation) CaOrganizationCleared() bool {
	_, ok := m.clearedFields[selfsignedissuer.FieldCaOrganization]
	return ok
}

// ResetCaOrganization resets all changes to the "ca_organization" field.
func (m *SelfSignedIssuerMutation) ResetCaOrganization() {
	m.ca_organization = nil
	delete(m.clearedFields, selfsignedissuer.FieldCaOrganization)
}

// SetCaOrganizationalUnit sets the "ca_organizational_unit" field.
func (m *SelfSignedIssuerMutation) SetCaOrganizationalUnit(s string) {
	m.ca_organizational_unit = &s
}

// CaOrganizationalUnit returns the value of the "ca_organizational_unit" field in the mutation.
func (m *SelfSignedIssuerMutation) CaOrganizationalUnit() (r string, exists bool) {
	v := m.ca_organizational_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldCaOrganizationalUnit returns the old "ca_organizational_unit" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldCaOrganizationalUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaOrganizationalUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaOrganizationalUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaOrganizationalUnit: %w", err)
	}
	return oldValue.CaOrganizationalUnit, nil
}

// ClearCaOrganizationalUnit clears the value of the "ca_organizational_unit" field.
func (m *SelfSignedIssuerMutation) ClearCaOrganizationalUnit() {
	m.ca_organizational_unit = nil
	m.clearedFields[selfsignedissuer.FieldCaOrganizationalUnit] = struct{}{}
}

// CaOrganizationalUnitCleared returns if the "ca_organizational_unit" field was cleared in this mutation.
func (m *SelfSignedIssuerMutation) CaOrganizationalUnitCleared() bool {
	_, ok := m.clearedFields[selfsignedissuer.FieldCaOrganizationalUnit]
	return ok
}

// ResetCaOrganizationalUnit resets all changes to the "ca_organizational_unit" field.
func (m *SelfSignedIssuerMutation) ResetCaOrganizationalUnit() {
	m.ca_organizational_unit = nil
	delete(m.clearedFields, selfsignedissuer.FieldCaOrganizationalUnit)
}

// SetCaCountry sets the "ca_country" field.
func (m *SelfSignedIssuerMutation) SetCaCountry(s string) {
	m.ca_country = &s
}

// CaCountry returns the value of the "ca_country" field in the mutation.
func (m *SelfSignedIssuerMutation) CaCountry() (r string, exists bool) {
	v := m.ca_country
	if v == nil {
		return
	}
	return *v, true
}

// OldCaCountry returns the old "ca_country" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldCaCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaCountry: %w", err)
	}
	return oldValue.CaCountry, nil
}

// ClearCaCountry clears the value of the "ca_country" field.
func (m *SelfSignedIssuerMutation) ClearCaCountry() {
	m.ca_country = nil
	m.clearedFields[selfsignedissuer.FieldCaCountry] = struct{}{}
}

// CaCountryCleared returns if the "ca_country" field was cleared in this mutation.
func (m *SelfSignedIssuerMutation) CaCountryCleared() bool {
	_, ok := m.clearedFields[selfsignedissuer.FieldCaCountry]
	return ok
}

// ResetCaCountry resets all changes to the "ca_country" field.
func (m *SelfSignedIssuerMutation) ResetCaCountry() {
	m.ca_country = nil
	delete(m.clearedFields, selfsignedissuer.FieldCaCountry)
}

// SetCaProvince sets the "ca_province" field.
func (m *SelfSignedIssuerMutation) SetCaProvince(s string) {
	m.ca_province = &s
}

// CaProvince returns the value of the "ca_province" field in the mutation.
func (m *SelfSignedIssuerMutation) CaProvince() (r string, exists bool) {
	v := m.ca_province
	if v == nil {
		return
	}
	return *v, true
}

// OldCaProvince returns the old "ca_province" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldCaProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaProvince: %w", err)
	}
	return oldValue.CaProvince, nil
}

// ClearCaProvince clears the value of the "ca_province" field.
func (m *SelfSignedIssuerMutation) ClearCaProvince() {
	m.ca_province = nil
	m.clearedFields[selfsignedissuer.FieldCaProvince] = struct{}{}
}

// CaProvinceCleared returns if the "ca_province" field was cleared in this mutation.
func (m *SelfSignedIssuerMutation) CaProvinceCleared() bool {
	_, ok := m.clearedFields[selfsignedissuer.FieldCaProvince]
	return ok
}

// ResetCaProvince resets all changes to the "ca_province" field.
func (m *SelfSignedIssuerMutation) ResetCaProvince() {
	m.ca_province = nil
	delete(m.clearedFields, selfsignedissuer.FieldCaProvince)
}

// SetCaLocality sets the "ca_locality" field.
func (m *SelfSignedIssuerMutation) SetCaLocality(s string) {
	m.ca_locality = &s
}

// CaLocality returns the value of the "ca_locality" field in the mutation.
func (m *SelfSignedIssuerMutation) CaLocality() (r string, exists bool) {
	v := m.ca_locality
	if v == nil {
		return
	}
	return *v, true
}

// OldCaLocality returns the old "ca_locality" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldCaLocality(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaLocality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaLocality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaLocality: %w", err)
	}
	return oldValue.CaLocality, nil
}

// ClearCaLocality clears the value of the "ca_locality" field.
func (m *SelfSignedIssuerMutation) ClearCaLocality() {
	m.ca_locality = nil
	m.clearedFields[selfsignedissuer.FieldCaLocality] = struct{}{}
}

// CaLocalityCleared returns if the "ca_locality" field was cleared in this mutation.
func (m *SelfSignedIssuerMutation) CaLocalityCleared() bool {
	_, ok := m.clearedFields[selfsignedissuer.FieldCaLocality]
	return ok
}

// ResetCaLocality resets all changes to the "ca_locality" field.
func (m *SelfSignedIssuerMutation) ResetCaLocality() {
	m.ca_locality = nil
	delete(m.clearedFields, selfsignedissuer.FieldCaLocality)
}

// SetCaValidityDays sets the "ca_validity_days" field.
func (m *SelfSignedIssuerMutation) SetCaValidityDays(i int32) {
	m.ca_validity_days = &i
	m.addca_validity_days = nil
}

// CaValidityDays returns the value of the "ca_validity_days" field in the mutation.
func (m *SelfSignedIssuerMutation) CaValidityDays() (r int32, exists bool) {
	v := m.ca_validity_days
	if v == nil {
		return
	}
	return *v, true
}

// OldCaValidityDays returns the old "ca_validity_days" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldCaValidityDays(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaValidityDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaValidityDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaValidityDays: %w", err)
	}
	return oldValue.CaValidityDays, nil
}

// AddCaValidityDays adds i to the "ca_validity_days" field.
func (m *SelfSignedIssuerMutation) AddCaValidityDays(i int32) {
	if m.addca_validity_days != nil {
		*m.addca_validity_days += i
	} else {
		m.addca_validity_days = &i
	}
}

// AddedCaValidityDays returns the value that was added to the "ca_validity_days" field in this mutation.
func (m *SelfSignedIssuerMutation) AddedCaValidityDays() (r int32, exists bool) {
	v := m.addca_validity_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetCaValidityDays resets all changes to the "ca_validity_days" field.
func (m *SelfSignedIssuerMutation) ResetCaValidityDays() {
	m.ca_validity_days = nil
	m.addca_validity_days = nil
}

// SetCaCertificatePem sets the "ca_certificate_pem" field.
func (m *SelfSignedIssuerMutation) SetCaCertificatePem(s string) {
	m.ca_certificate_pem = &s
}

// CaCertificatePem returns the value of the "ca_certificate_pem" field in the mutation.
func (m *SelfSignedIssuerMutation) CaCertificatePem() (r string, exists bool) {
	v := m.ca_certificate_pem
	if v == nil {
		return
	}
	return *v, true
}

// OldCaCertificatePem returns the old "ca_certificate_pem" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldCaCertificatePem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaCertificatePem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaCertificatePem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaCertificatePem: %w", err)
	}
	return oldValue.CaCertificatePem, nil
}

// ClearCaCertificatePem clears the value of the "ca_certificate_pem" field.
func (m *SelfSignedIssuerMutation) ClearCaCertificatePem() {
	m.ca_certificate_pem = nil
	m.clearedFields[selfsignedissuer.FieldCaCertificatePem] = struct{}{}
}

// CaCertificatePemCleared returns if the "ca_certificate_pem" field was cleared in this mutation.
func (m *SelfSignedIssuerMutation) CaCertificatePemCleared() bool {
	_, ok := m.clearedFields[selfsignedissuer.FieldCaCertificatePem]
	return ok
}

// ResetCaCertificatePem resets all changes to the "ca_certificate_pem" field.
func (m *SelfSignedIssuerMutation) ResetCaCertificatePem() {
	m.ca_certificate_pem = nil
	delete(m.clearedFields, selfsignedissuer.FieldCaCertificatePem)
}

// SetCaPrivateKeyPem sets the "ca_private_key_pem" field.
func (m *SelfSignedIssuerMutation) SetCaPrivateKeyPem(s string) {
	m.ca_private_key_pem = &s
}

// CaPrivateKeyPem returns the value of the "ca_private_key_pem" field in the mutation.
func (m *SelfSignedIssuerMutation) CaPrivateKeyPem() (r string, exists bool) {
	v := m.ca_private_key_pem
	if v == nil {
		return
	}
	return *v, true
}

// OldCaPrivateKeyPem returns the old "ca_private_key_pem" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldCaPrivateKeyPem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaPrivateKeyPem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaPrivateKeyPem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaPrivateKeyPem: %w", err)
	}
	return oldValue.CaPrivateKeyPem, nil
}

// ClearCaPrivateKeyPem clears the value of the "ca_private_key_pem" field.
func (m *SelfSignedIssuerMutation) ClearCaPrivateKeyPem() {
	m.ca_private_key_pem = nil
	m.clearedFields[selfsignedissuer.FieldCaPrivateKeyPem] = struct{}{}
}

// CaPrivateKeyPemCleared returns if the "ca_private_key_pem" field was cleared in this mutation.
func (m *SelfSignedIssuerMutation) CaPrivateKeyPemCleared() bool {
	_, ok := m.clearedFields[selfsignedissuer.FieldCaPrivateKeyPem]
	return ok
}

// ResetCaPrivateKeyPem resets all changes to the "ca_private_key_pem" field.
func (m *SelfSignedIssuerMutation) ResetCaPrivateKeyPem() {
	m.ca_private_key_pem = nil
	delete(m.clearedFields, selfsignedissuer.FieldCaPrivateKeyPem)
}

// SetCaCertificateFingerprint sets the "ca_certificate_fingerprint" field.
func (m *SelfSignedIssuerMutation) SetCaCertificateFingerprint(s string) {
	m.ca_certificate_fingerprint = &s
}

// CaCertificateFingerprint returns the value of the "ca_certificate_fingerprint" field in the mutation.
func (m *SelfSignedIssuerMutation) CaCertificateFingerprint() (r string, exists bool) {
	v := m.ca_certificate_fingerprint
	if v == nil {
		return
	}
	return *v, true
}

// OldCaCertificateFingerprint returns the old "ca_certificate_fingerprint" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldCaCertificateFingerprint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaCertificateFingerprint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaCertificateFingerprint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaCertificateFingerprint: %w", err)
	}
	return oldValue.CaCertificateFingerprint, nil
}

// ClearCaCertificateFingerprint clears the value of the "ca_certificate_fingerprint" field.
func (m *SelfSignedIssuerMutation) ClearCaCertificateFingerprint() {
	m.ca_certificate_fingerprint = nil
	m.clearedFields[selfsignedissuer.FieldCaCertificateFingerprint] = struct{}{}
}

// CaCertificateFingerprintCleared returns if the "ca_certificate_fingerprint" field was cleared in this mutation.
func (m *SelfSignedIssuerMutation) CaCertificateFingerprintCleared() bool {
	_, ok := m.clearedFields[selfsignedissuer.FieldCaCertificateFingerprint]
	return ok
}

// ResetCaCertificateFingerprint resets all changes to the "ca_certificate_fingerprint" field.
func (m *SelfSignedIssuerMutation) ResetCaCertificateFingerprint() {
	m.ca_certificate_fingerprint = nil
	delete(m.clearedFields, selfsignedissuer.FieldCaCertificateFingerprint)
}

// SetCaExpiresAt sets the "ca_expires_at" field.
func (m *SelfSignedIssuerMutation) SetCaExpiresAt(t time.Time) {
	m.ca_expires_at = &t
}

// CaExpiresAt returns the value of the "ca_expires_at" field in the mutation.
func (m *SelfSignedIssuerMutation) CaExpiresAt() (r time.Time, exists bool) {
	v := m.ca_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCaExpiresAt returns the old "ca_expires_at" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldCaExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaExpiresAt: %w", err)
	}
	return oldValue.CaExpiresAt, nil
}

// ClearCaExpiresAt clears the value of the "ca_expires_at" field.
func (m *SelfSignedIssuerMutation) ClearCaExpiresAt() {
	m.ca_expires_at = nil
	m.clearedFields[selfsignedissuer.FieldCaExpiresAt] = struct{}{}
}

// CaExpiresAtCleared returns if the "ca_expires_at" field was cleared in this mutation.
func (m *SelfSignedIssuerMutation) CaExpiresAtCleared() bool {
	_, ok := m.clearedFields[selfsignedissuer.FieldCaExpiresAt]
	return ok
}

// ResetCaExpiresAt resets all changes to the "ca_expires_at" field.
func (m *SelfSignedIssuerMutation) ResetCaExpiresAt() {
	m.ca_expires_at = nil
	delete(m.clearedFields, selfsignedissuer.FieldCaExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *SelfSignedIssuerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SelfSignedIssuerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SelfSignedIssuerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SelfSignedIssuerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SelfSignedIssuerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SelfSignedIssuer entity.
// If the SelfSignedIssuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfSignedIssuerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SelfSignedIssuerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIssuerID sets the "issuer" edge to the Issuer entity by id.
func (m *SelfSignedIssuerMutation) SetIssuerID(id uint32) {
	m.issuer = &id
}

// ClearIssuer clears the "issuer" edge to the Issuer entity.
func (m *SelfSignedIssuerMutation) ClearIssuer() {
	m.clearedissuer = true
}

// IssuerCleared reports if the "issuer" edge to the Issuer entity was cleared.
func (m *SelfSignedIssuerMutation) IssuerCleared() bool {
	return m.clearedissuer
}

// IssuerID returns the "issuer" edge ID in the mutation.
func (m *SelfSignedIssuerMutation) IssuerID() (id uint32, exists bool) {
	if m.issuer != nil {
		return *m.issuer, true
	}
	return
}

// IssuerIDs returns the "issuer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IssuerID instead. It exists only for internal usage by the builders.
func (m *SelfSignedIssuerMutation) IssuerIDs() (ids []uint32) {
	if id := m.issuer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIssuer resets all changes to the "issuer" edge.
func (m *SelfSignedIssuerMutation) ResetIssuer() {
	m.issuer = nil
	m.clearedissuer = false
}

// Where appends a list predicates to the SelfSignedIssuerMutation builder.
func (m *SelfSignedIssuerMutation) Where(ps ...predicate.SelfSignedIssuer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SelfSignedIssuerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SelfSignedIssuerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SelfSignedIssuer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SelfSignedIssuerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SelfSignedIssuerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SelfSignedIssuer).
func (m *SelfSignedIssuerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SelfSignedIssuerMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.common_name != nil {
		fields = append(fields, selfsignedissuer.FieldCommonName)
	}
	if m.dns_names != nil {
		fields = append(fields, selfsignedissuer.FieldDNSNames)
	}
	if m.ip_addresses != nil {
		fields = append(fields, selfsignedissuer.FieldIPAddresses)
	}
	if m.ca_common_name != nil {
		fields = append(fields, selfsignedissuer.FieldCaCommonName)
	}
	if m.ca_organization != nil {
		fields = append(fields, selfsignedissuer.FieldCaOrganization)
	}
	if m.ca_organizational_unit != nil {
		fields = append(fields, selfsignedissuer.FieldCaOrganizationalUnit)
	}
	if m.ca_country != nil {
		fields = append(fields, selfsignedissuer.FieldCaCountry)
	}
	if m.ca_province != nil {
		fields = append(fields, selfsignedissuer.FieldCaProvince)
	}
	if m.ca_locality != nil {
		fields = append(fields, selfsignedissuer.FieldCaLocality)
	}
	if m.ca_validity_days != nil {
		fields = append(fields, selfsignedissuer.FieldCaValidityDays)
	}
	if m.ca_certificate_pem != nil {
		fields = append(fields, selfsignedissuer.FieldCaCertificatePem)
	}
	if m.ca_private_key_pem != nil {
		fields = append(fields, selfsignedissuer.FieldCaPrivateKeyPem)
	}
	if m.ca_certificate_fingerprint != nil {
		fields = append(fields, selfsignedissuer.FieldCaCertificateFingerprint)
	}
	if m.ca_expires_at != nil {
		fields = append(fields, selfsignedissuer.FieldCaExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, selfsignedissuer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, selfsignedissuer.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SelfSignedIssuerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case selfsignedissuer.FieldCommonName:
		return m.CommonName()
	case selfsignedissuer.FieldDNSNames:
		return m.DNSNames()
	case selfsignedissuer.FieldIPAddresses:
		return m.IPAddresses()
	case selfsignedissuer.FieldCaCommonName:
		return m.CaCommonName()
	case selfsignedissuer.FieldCaOrganization:
		return m.CaOrganization()
	case selfsignedissuer.FieldCaOrganizationalUnit:
		return m.CaOrganizationalUnit()
	case selfsignedissuer.FieldCaCountry:
		return m.CaCountry()
	case selfsignedissuer.FieldCaProvince:
		return m.CaProvince()
	case selfsignedissuer.FieldCaLocality:
		return m.CaLocality()
	case selfsignedissuer.FieldCaValidityDays:
		return m.CaValidityDays()
	case selfsignedissuer.FieldCaCertificatePem:
		return m.CaCertificatePem()
	case selfsignedissuer.FieldCaPrivateKeyPem:
		return m.CaPrivateKeyPem()
	case selfsignedissuer.FieldCaCertificateFingerprint:
		return m.CaCertificateFingerprint()
	case selfsignedissuer.FieldCaExpiresAt:
		return m.CaExpiresAt()
	case selfsignedissuer.FieldCreatedAt:
		return m.CreatedAt()
	case selfsignedissuer.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SelfSignedIssuerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case selfsignedissuer.FieldCommonName:
		return m.OldCommonName(ctx)
	case selfsignedissuer.FieldDNSNames:
		return m.OldDNSNames(ctx)
	case selfsignedissuer.FieldIPAddresses:
		return m.OldIPAddresses(ctx)
	case selfsignedissuer.FieldCaCommonName:
		return m.OldCaCommonName(ctx)
	case selfsignedissuer.FieldCaOrganization:
		return m.OldCaOrganization(ctx)
	case selfsignedissuer.FieldCaOrganizationalUnit:
		return m.OldCaOrganizationalUnit(ctx)
	case selfsignedissuer.FieldCaCountry:
		return m.OldCaCountry(ctx)
	case selfsignedissuer.FieldCaProvince:
		return m.OldCaProvince(ctx)
	case selfsignedissuer.FieldCaLocality:
		return m.OldCaLocality(ctx)
	case selfsignedissuer.FieldCaValidityDays:
		return m.OldCaValidityDays(ctx)
	case selfsignedissuer.FieldCaCertificatePem:
		return m.OldCaCertificatePem(ctx)
	case selfsignedissuer.FieldCaPrivateKeyPem:
		return m.OldCaPrivateKeyPem(ctx)
	case selfsignedissuer.FieldCaCertificateFingerprint:
		return m.OldCaCertificateFingerprint(ctx)
	case selfsignedissuer.FieldCaExpiresAt:
		return m.OldCaExpiresAt(ctx)
	case selfsignedissuer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case selfsignedissuer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SelfSignedIssuer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SelfSignedIssuerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case selfsignedissuer.FieldCommonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommonName(v)
		return nil
	case selfsignedissuer.FieldDNSNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSNames(v)
		return nil
	case selfsignedissuer.FieldIPAddresses:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddresses(v)
		return nil
	case selfsignedissuer.FieldCaCommonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaCommonName(v)
		return nil
	case selfsignedissuer.FieldCaOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaOrganization(v)
		return nil
	case selfsignedissuer.FieldCaOrganizationalUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaOrganizationalUnit(v)
		return nil
	case selfsignedissuer.FieldCaCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaCountry(v)
		return nil
	case selfsignedissuer.FieldCaProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaProvince(v)
		return nil
	case selfsignedissuer.FieldCaLocality:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaLocality(v)
		return nil
	case selfsignedissuer.FieldCaValidityDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaValidityDays(v)
		return nil
	case selfsignedissuer.FieldCaCertificatePem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaCertificatePem(v)
		return nil
	case selfsignedissuer.FieldCaPrivateKeyPem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaPrivateKeyPem(v)
		return nil
	case selfsignedissuer.FieldCaCertificateFingerprint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaCertificateFingerprint(v)
		return nil
	case selfsignedissuer.FieldCaExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaExpiresAt(v)
		return nil
	case selfsignedissuer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case selfsignedissuer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SelfSignedIssuer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SelfSignedIssuerMutation) AddedFields() []string {
	var fields []string
	if m.addca_validity_days != nil {
		fields = append(fields, selfsignedissuer.FieldCaValidityDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SelfSignedIssuerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case selfsignedissuer.FieldCaValidityDays:
		return m.AddedCaValidityDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SelfSignedIssuerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case selfsignedissuer.FieldCaValidityDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCaValidityDays(v)
		return nil
	}
	return fmt.Errorf("unknown SelfSignedIssuer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SelfSignedIssuerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(selfsignedissuer.FieldDNSNames) {
		fields = append(fields, selfsignedissuer.FieldDNSNames)
	}
	if m.FieldCleared(selfsignedissuer.FieldIPAddresses) {
		fields = append(fields, selfsignedissuer.FieldIPAddresses)
	}
	if m.FieldCleared(selfsignedissuer.FieldCaOrganization) {
		fields = append(fields, selfsignedissuer.FieldCaOrganization)
	}
	if m.FieldCleared(selfsignedissuer.FieldCaOrganizationalUnit) {
		fields = append(fields, selfsignedissuer.FieldCaOrganizationalUnit)
	}
	if m.FieldCleared(selfsignedissuer.FieldCaCountry) {
		fields = append(fields, selfsignedissuer.FieldCaCountry)
	}
	if m.FieldCleared(selfsignedissuer.FieldCaProvince) {
		fields = append(fields, selfsignedissuer.FieldCaProvince)
	}
	if m.FieldCleared(selfsignedissuer.FieldCaLocality) {
		fields = append(fields, selfsignedissuer.FieldCaLocality)
	}
	if m.FieldCleared(selfsignedissuer.FieldCaCertificatePem) {
		fields = append(fields, selfsignedissuer.FieldCaCertificatePem)
	}
	if m.FieldCleared(selfsignedissuer.FieldCaPrivateKeyPem) {
		fields = append(fields, selfsignedissuer.FieldCaPrivateKeyPem)
	}
	if m.FieldCleared(selfsignedissuer.FieldCaCertificateFingerprint) {
		fields = append(fields, selfsignedissuer.FieldCaCertificateFingerprint)
	}
	if m.FieldCleared(selfsignedissuer.FieldCaExpiresAt) {
		fields = append(fields, selfsignedissuer.FieldCaExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SelfSignedIssuerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SelfSignedIssuerMutation) ClearField(name string) error {
	switch name {
	case selfsignedissuer.FieldDNSNames:
		m.ClearDNSNames()
		return nil
	case selfsignedissuer.FieldIPAddresses:
		m.ClearIPAddresses()
		return nil
	case selfsignedissuer.FieldCaOrganization:
		m.ClearCaOrganization()
		return nil
	case selfsignedissuer.FieldCaOrganizationalUnit:
		m.ClearCaOrganizationalUnit()
		return nil
	case selfsignedissuer.FieldCaCountry:
		m.ClearCaCountry()
		return nil
	case selfsignedissuer.FieldCaProvince:
		m.ClearCaProvince()
		return nil
	case selfsignedissuer.FieldCaLocality:
		m.ClearCaLocality()
		return nil
	case selfsignedissuer.FieldCaCertificatePem:
		m.ClearCaCertificatePem()
		return nil
	case selfsignedissuer.FieldCaPrivateKeyPem:
		m.ClearCaPrivateKeyPem()
		return nil
	case selfsignedissuer.FieldCaCertificateFingerprint:
		m.ClearCaCertificateFingerprint()
		return nil
	case selfsignedissuer.FieldCaExpiresAt:
		m.ClearCaExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown SelfSignedIssuer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SelfSignedIssuerMutation) ResetField(name string) error {
	switch name {
	case selfsignedissuer.FieldCommonName:
		m.ResetCommonName()
		return nil
	case selfsignedissuer.FieldDNSNames:
		m.ResetDNSNames()
		return nil
	case selfsignedissuer.FieldIPAddresses:
		m.ResetIPAddresses()
		return nil
	case selfsignedissuer.FieldCaCommonName:
		m.ResetCaCommonName()
		return nil
	case selfsignedissuer.FieldCaOrganization:
		m.ResetCaOrganization()
		return nil
	case selfsignedissuer.FieldCaOrganizationalUnit:
		m.ResetCaOrganizationalUnit()
		return nil
	case selfsignedissuer.FieldCaCountry:
		m.ResetCaCountry()
		return nil
	case selfsignedissuer.FieldCaProvince:
		m.ResetCaProvince()
		return nil
	case selfsignedissuer.FieldCaLocality:
		m.ResetCaLocality()
		return nil
	case selfsignedissuer.FieldCaValidityDays:
		m.ResetCaValidityDays()
		return nil
	case selfsignedissuer.FieldCaCertificatePem:
		m.ResetCaCertificatePem()
		return nil
	case selfsignedissuer.FieldCaPrivateKeyPem:
		m.ResetCaPrivateKeyPem()
		return nil
	case selfsignedissuer.FieldCaCertificateFingerprint:
		m.ResetCaCertificateFingerprint()
		return nil
	case selfsignedissuer.FieldCaExpiresAt:
		m.ResetCaExpiresAt()
		return nil
	case selfsignedissuer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case selfsignedissuer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SelfSignedIssuer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SelfSignedIssuerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.issuer != nil {
		edges = append(edges, selfsignedissuer.EdgeIssuer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SelfSignedIssuerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case selfsignedissuer.EdgeIssuer:
		if id := m.issuer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SelfSignedIssuerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SelfSignedIssuerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SelfSignedIssuerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedissuer {
		edges = append(edges, selfsignedissuer.EdgeIssuer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SelfSignedIssuerMutation) EdgeCleared(name string) bool {
	switch name {
	case selfsignedissuer.EdgeIssuer:
		return m.clearedissuer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SelfSignedIssuerMutation) ClearEdge(name string) error {
	switch name {
	case selfsignedissuer.EdgeIssuer:
		m.ClearIssuer()
		return nil
	}
	return fmt.Errorf("unknown SelfSignedIssuer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SelfSignedIssuerMutation) ResetEdge(name string) error {
	switch name {
	case selfsignedissuer.EdgeIssuer:
		m.ResetIssuer()
		return nil
	}
	return fmt.Errorf("unknown SelfSignedIssuer edge %s", name)
}

// TenantSecretMutation represents an operation that mutates the TenantSecret nodes in the graph.
type TenantSecretMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	create_by     *uint32
	addcreate_by  *int32
	update_by     *uint32
	addupdate_by  *int32
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	tenant_id     *uint32
	addtenant_id  *int32
	secret_hash   *string
	description   *string
	status        *tenantsecret.Status
	expires_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TenantSecret, error)
	predicates    []predicate.TenantSecret
}

var _ ent.Mutation = (*TenantSecretMutation)(nil)

// tenantsecretOption allows management of the mutation configuration using functional options.
type tenantsecretOption func(*TenantSecretMutation)

// newTenantSecretMutation creates new mutation for the TenantSecret entity.
func newTenantSecretMutation(c config, op Op, opts ...tenantsecretOption) *TenantSecretMutation {
	m := &TenantSecretMutation{
		config:        c,
		op:            op,
		typ:           TypeTenantSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantSecretID sets the ID field of the mutation.
func withTenantSecretID(id uint32) tenantsecretOption {
	return func(m *TenantSecretMutation) {
		var (
			err   error
			once  sync.Once
			value *TenantSecret
		)
		m.oldValue = func(ctx context.Context) (*TenantSecret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TenantSecret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenantSecret sets the old TenantSecret of the mutation.
func withTenantSecret(node *TenantSecret) tenantsecretOption {
	return func(m *TenantSecretMutation) {
		m.oldValue = func(context.Context) (*TenantSecret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantSecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantSecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TenantSecret entities.
func (m *TenantSecretMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantSecretMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantSecretMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TenantSecret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *TenantSecretMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *TenantSecretMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the TenantSecret entity.
// If the TenantSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSecretMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *TenantSecretMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *TenantSecretMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *TenantSecretMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[tenantsecret.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *TenantSecretMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[tenantsecret.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *TenantSecretMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, tenantsecret.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *TenantSecretMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *TenantSecretMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the TenantSecret entity.
// If the TenantSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSecretMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *TenantSecretMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *TenantSecretMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *TenantSecretMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[tenantsecret.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *TenantSecretMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[tenantsecret.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *TenantSecretMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, tenantsecret.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *TenantSecretMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TenantSecretMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TenantSecret entity.
// If the TenantSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSecretMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *TenantSecretMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[tenantsecret.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *TenantSecretMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[tenantsecret.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TenantSecretMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, tenantsecret.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *TenantSecretMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TenantSecretMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TenantSecret entity.
// If the TenantSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSecretMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *TenantSecretMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[tenantsecret.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *TenantSecretMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[tenantsecret.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TenantSecretMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, tenantsecret.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *TenantSecretMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *TenantSecretMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the TenantSecret entity.
// If the TenantSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSecretMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *TenantSecretMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[tenantsecret.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *TenantSecretMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[tenantsecret.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *TenantSecretMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, tenantsecret.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *TenantSecretMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TenantSecretMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TenantSecret entity.
// If the TenantSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSecretMutation) OldTenantID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *TenantSecretMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TenantSecretMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TenantSecretMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetSecretHash sets the "secret_hash" field.
func (m *TenantSecretMutation) SetSecretHash(s string) {
	m.secret_hash = &s
}

// SecretHash returns the value of the "secret_hash" field in the mutation.
func (m *TenantSecretMutation) SecretHash() (r string, exists bool) {
	v := m.secret_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretHash returns the old "secret_hash" field's value of the TenantSecret entity.
// If the TenantSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSecretMutation) OldSecretHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretHash: %w", err)
	}
	return oldValue.SecretHash, nil
}

// ResetSecretHash resets all changes to the "secret_hash" field.
func (m *TenantSecretMutation) ResetSecretHash() {
	m.secret_hash = nil
}

// SetDescription sets the "description" field.
func (m *TenantSecretMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TenantSecretMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TenantSecret entity.
// If the TenantSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSecretMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TenantSecretMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tenantsecret.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TenantSecretMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tenantsecret.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TenantSecretMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tenantsecret.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *TenantSecretMutation) SetStatus(t tenantsecret.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TenantSecretMutation) Status() (r tenantsecret.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TenantSecret entity.
// If the TenantSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSecretMutation) OldStatus(ctx context.Context) (v tenantsecret.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TenantSecretMutation) ResetStatus() {
	m.status = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *TenantSecretMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *TenantSecretMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the TenantSecret entity.
// If the TenantSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSecretMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *TenantSecretMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[tenantsecret.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *TenantSecretMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[tenantsecret.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *TenantSecretMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, tenantsecret.FieldExpiresAt)
}

// Where appends a list predicates to the TenantSecretMutation builder.
func (m *TenantSecretMutation) Where(ps ...predicate.TenantSecret) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantSecretMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantSecretMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TenantSecret, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantSecretMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantSecretMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TenantSecret).
func (m *TenantSecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantSecretMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_by != nil {
		fields = append(fields, tenantsecret.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, tenantsecret.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, tenantsecret.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tenantsecret.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, tenantsecret.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, tenantsecret.FieldTenantID)
	}
	if m.secret_hash != nil {
		fields = append(fields, tenantsecret.FieldSecretHash)
	}
	if m.description != nil {
		fields = append(fields, tenantsecret.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, tenantsecret.FieldStatus)
	}
	if m.expires_at != nil {
		fields = append(fields, tenantsecret.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantSecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenantsecret.FieldCreateBy:
		return m.CreateBy()
	case tenantsecret.FieldUpdateBy:
		return m.UpdateBy()
	case tenantsecret.FieldCreateTime:
		return m.CreateTime()
	case tenantsecret.FieldUpdateTime:
		return m.UpdateTime()
	case tenantsecret.FieldDeleteTime:
		return m.DeleteTime()
	case tenantsecret.FieldTenantID:
		return m.TenantID()
	case tenantsecret.FieldSecretHash:
		return m.SecretHash()
	case tenantsecret.FieldDescription:
		return m.Description()
	case tenantsecret.FieldStatus:
		return m.Status()
	case tenantsecret.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantSecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenantsecret.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case tenantsecret.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case tenantsecret.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tenantsecret.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tenantsecret.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case tenantsecret.FieldTenantID:
		return m.OldTenantID(ctx)
	case tenantsecret.FieldSecretHash:
		return m.OldSecretHash(ctx)
	case tenantsecret.FieldDescription:
		return m.OldDescription(ctx)
	case tenantsecret.FieldStatus:
		return m.OldStatus(ctx)
	case tenantsecret.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown TenantSecret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantSecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenantsecret.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case tenantsecret.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case tenantsecret.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tenantsecret.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tenantsecret.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case tenantsecret.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case tenantsecret.FieldSecretHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretHash(v)
		return nil
	case tenantsecret.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tenantsecret.FieldStatus:
		v, ok := value.(tenantsecret.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tenantsecret.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown TenantSecret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantSecretMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, tenantsecret.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, tenantsecret.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, tenantsecret.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantSecretMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tenantsecret.FieldCreateBy:
		return m.AddedCreateBy()
	case tenantsecret.FieldUpdateBy:
		return m.AddedUpdateBy()
	case tenantsecret.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantSecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tenantsecret.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case tenantsecret.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case tenantsecret.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown TenantSecret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantSecretMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenantsecret.FieldCreateBy) {
		fields = append(fields, tenantsecret.FieldCreateBy)
	}
	if m.FieldCleared(tenantsecret.FieldUpdateBy) {
		fields = append(fields, tenantsecret.FieldUpdateBy)
	}
	if m.FieldCleared(tenantsecret.FieldCreateTime) {
		fields = append(fields, tenantsecret.FieldCreateTime)
	}
	if m.FieldCleared(tenantsecret.FieldUpdateTime) {
		fields = append(fields, tenantsecret.FieldUpdateTime)
	}
	if m.FieldCleared(tenantsecret.FieldDeleteTime) {
		fields = append(fields, tenantsecret.FieldDeleteTime)
	}
	if m.FieldCleared(tenantsecret.FieldDescription) {
		fields = append(fields, tenantsecret.FieldDescription)
	}
	if m.FieldCleared(tenantsecret.FieldExpiresAt) {
		fields = append(fields, tenantsecret.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantSecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantSecretMutation) ClearField(name string) error {
	switch name {
	case tenantsecret.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case tenantsecret.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case tenantsecret.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case tenantsecret.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case tenantsecret.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case tenantsecret.FieldDescription:
		m.ClearDescription()
		return nil
	case tenantsecret.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown TenantSecret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantSecretMutation) ResetField(name string) error {
	switch name {
	case tenantsecret.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case tenantsecret.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case tenantsecret.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tenantsecret.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tenantsecret.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case tenantsecret.FieldTenantID:
		m.ResetTenantID()
		return nil
	case tenantsecret.FieldSecretHash:
		m.ResetSecretHash()
		return nil
	case tenantsecret.FieldDescription:
		m.ResetDescription()
		return nil
	case tenantsecret.FieldStatus:
		m.ResetStatus()
		return nil
	case tenantsecret.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown TenantSecret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantSecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantSecretMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantSecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantSecretMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantSecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantSecretMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantSecretMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TenantSecret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantSecretMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TenantSecret edge %s", name)
}
