// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/certificatedetails"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/issuedcertificate"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/lcmclient"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// IssuedCertificate is the model entity for the IssuedCertificate schema.
type IssuedCertificate struct {
	config `json:"-"`
	// ID of the ent.
	// Unique certificate identifier
	ID string `json:"id,omitempty"`
	// Legacy client identifier (deprecated - use lcm_client relationship)
	ClientID string `json:"client_id,omitempty"`
	// Name of the issuer that issued this certificate
	IssuerName string `json:"issuer_name,omitempty"`
	// Type of the issuer (e.g., 'self_signed', 'acme')
	IssuerType string `json:"issuer_type,omitempty"`
	// Tenant ID for multi-tenancy
	TenantID uint32 `json:"tenant_id,omitempty"`
	// Certificate common name
	CommonName string `json:"common_name,omitempty"`
	// Domain names covered by this certificate (DNS SANs)
	Domains []string `json:"domains,omitempty"`
	// IP addresses covered by this certificate (IP SANs)
	IPAddresses []string `json:"ip_addresses,omitempty"`
	// Current certificate status
	Status issuedcertificate.Status `json:"status,omitempty"`
	// Certificate in PEM format
	CertPem string `json:"cert_pem,omitempty"`
	// Private key in PEM format (encrypted, only for server-generated keys)
	PrivateKeyPem string `json:"private_key_pem,omitempty"`
	// True if private key was generated by server (no CSR provided)
	ServerGeneratedKey bool `json:"server_generated_key,omitempty"`
	// CA certificate chain in PEM format
	CaCertPem string `json:"ca_cert_pem,omitempty"`
	// Original Certificate Signing Request in PEM format
	CsrPem string `json:"csr_pem,omitempty"`
	// Certificate fingerprint/hash
	CertificateFingerprint string `json:"certificate_fingerprint,omitempty"`
	// Error message if certificate issuance failed
	ErrorMessage string `json:"error_message,omitempty"`
	// Type of key used
	KeyType issuedcertificate.KeyType `json:"key_type,omitempty"`
	// Size of the key in bits
	KeySize int32 `json:"key_size,omitempty"`
	// Whether auto-renewal is enabled
	AutoRenewEnabled bool `json:"auto_renew_enabled,omitempty"`
	// Days before expiry to start renewal process
	AutoRenewDaysBeforeExpiry int32 `json:"auto_renew_days_before_expiry,omitempty"`
	// Maximum number of renewal attempts
	AutoRenewMaxAttempts int32 `json:"auto_renew_max_attempts,omitempty"`
	// Interval between renewal retry attempts in seconds
	AutoRenewRetryIntervalSeconds int64 `json:"auto_renew_retry_interval_seconds,omitempty"`
	// Last time certificate was renewed
	LastRenewalAt time.Time `json:"last_renewal_at,omitempty"`
	// Number of renewal attempts made
	RenewalAttempts int32 `json:"renewal_attempts,omitempty"`
	// Certificate expiration time
	ExpiresAt time.Time `json:"expires_at,omitempty"`
	// Certificate revocation time
	RevokedAt time.Time `json:"revoked_at,omitempty"`
	// Reason for certificate revocation
	RevokedReason string `json:"revoked_reason,omitempty"`
	// Certificate creation time
	CreatedAt time.Time `json:"created_at,omitempty"`
	// Last update time
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the IssuedCertificateQuery when eager-loading is set.
	Edges                          IssuedCertificateEdges `json:"edges"`
	lcm_client_issued_certificates *uint32
	selectValues                   sql.SelectValues
}

// IssuedCertificateEdges holds the relations/edges for other nodes in the graph.
type IssuedCertificateEdges struct {
	// The LCM client that owns this certificate
	LcmClient *LcmClient `json:"lcm_client,omitempty"`
	// Detailed certificate information parsed from PEM
	CertificateDetails *CertificateDetails `json:"certificate_details,omitempty"`
	// Permissions granted for this certificate to other clients
	Permissions []*CertificatePermission `json:"permissions,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [3]bool
}

// LcmClientOrErr returns the LcmClient value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e IssuedCertificateEdges) LcmClientOrErr() (*LcmClient, error) {
	if e.LcmClient != nil {
		return e.LcmClient, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: lcmclient.Label}
	}
	return nil, &NotLoadedError{edge: "lcm_client"}
}

// CertificateDetailsOrErr returns the CertificateDetails value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e IssuedCertificateEdges) CertificateDetailsOrErr() (*CertificateDetails, error) {
	if e.CertificateDetails != nil {
		return e.CertificateDetails, nil
	} else if e.loadedTypes[1] {
		return nil, &NotFoundError{label: certificatedetails.Label}
	}
	return nil, &NotLoadedError{edge: "certificate_details"}
}

// PermissionsOrErr returns the Permissions value or an error if the edge
// was not loaded in eager-loading.
func (e IssuedCertificateEdges) PermissionsOrErr() ([]*CertificatePermission, error) {
	if e.loadedTypes[2] {
		return e.Permissions, nil
	}
	return nil, &NotLoadedError{edge: "permissions"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*IssuedCertificate) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case issuedcertificate.FieldDomains, issuedcertificate.FieldIPAddresses:
			values[i] = new([]byte)
		case issuedcertificate.FieldServerGeneratedKey, issuedcertificate.FieldAutoRenewEnabled:
			values[i] = new(sql.NullBool)
		case issuedcertificate.FieldTenantID, issuedcertificate.FieldKeySize, issuedcertificate.FieldAutoRenewDaysBeforeExpiry, issuedcertificate.FieldAutoRenewMaxAttempts, issuedcertificate.FieldAutoRenewRetryIntervalSeconds, issuedcertificate.FieldRenewalAttempts:
			values[i] = new(sql.NullInt64)
		case issuedcertificate.FieldID, issuedcertificate.FieldClientID, issuedcertificate.FieldIssuerName, issuedcertificate.FieldIssuerType, issuedcertificate.FieldCommonName, issuedcertificate.FieldStatus, issuedcertificate.FieldCertPem, issuedcertificate.FieldPrivateKeyPem, issuedcertificate.FieldCaCertPem, issuedcertificate.FieldCsrPem, issuedcertificate.FieldCertificateFingerprint, issuedcertificate.FieldErrorMessage, issuedcertificate.FieldKeyType, issuedcertificate.FieldRevokedReason:
			values[i] = new(sql.NullString)
		case issuedcertificate.FieldLastRenewalAt, issuedcertificate.FieldExpiresAt, issuedcertificate.FieldRevokedAt, issuedcertificate.FieldCreatedAt, issuedcertificate.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		case issuedcertificate.ForeignKeys[0]: // lcm_client_issued_certificates
			values[i] = new(sql.NullInt64)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the IssuedCertificate fields.
func (_m *IssuedCertificate) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case issuedcertificate.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				_m.ID = value.String
			}
		case issuedcertificate.FieldClientID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field client_id", values[i])
			} else if value.Valid {
				_m.ClientID = value.String
			}
		case issuedcertificate.FieldIssuerName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field issuer_name", values[i])
			} else if value.Valid {
				_m.IssuerName = value.String
			}
		case issuedcertificate.FieldIssuerType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field issuer_type", values[i])
			} else if value.Valid {
				_m.IssuerType = value.String
			}
		case issuedcertificate.FieldTenantID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_id", values[i])
			} else if value.Valid {
				_m.TenantID = uint32(value.Int64)
			}
		case issuedcertificate.FieldCommonName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field common_name", values[i])
			} else if value.Valid {
				_m.CommonName = value.String
			}
		case issuedcertificate.FieldDomains:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field domains", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.Domains); err != nil {
					return fmt.Errorf("unmarshal field domains: %w", err)
				}
			}
		case issuedcertificate.FieldIPAddresses:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field ip_addresses", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.IPAddresses); err != nil {
					return fmt.Errorf("unmarshal field ip_addresses: %w", err)
				}
			}
		case issuedcertificate.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				_m.Status = issuedcertificate.Status(value.String)
			}
		case issuedcertificate.FieldCertPem:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field cert_pem", values[i])
			} else if value.Valid {
				_m.CertPem = value.String
			}
		case issuedcertificate.FieldPrivateKeyPem:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field private_key_pem", values[i])
			} else if value.Valid {
				_m.PrivateKeyPem = value.String
			}
		case issuedcertificate.FieldServerGeneratedKey:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field server_generated_key", values[i])
			} else if value.Valid {
				_m.ServerGeneratedKey = value.Bool
			}
		case issuedcertificate.FieldCaCertPem:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field ca_cert_pem", values[i])
			} else if value.Valid {
				_m.CaCertPem = value.String
			}
		case issuedcertificate.FieldCsrPem:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field csr_pem", values[i])
			} else if value.Valid {
				_m.CsrPem = value.String
			}
		case issuedcertificate.FieldCertificateFingerprint:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field certificate_fingerprint", values[i])
			} else if value.Valid {
				_m.CertificateFingerprint = value.String
			}
		case issuedcertificate.FieldErrorMessage:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field error_message", values[i])
			} else if value.Valid {
				_m.ErrorMessage = value.String
			}
		case issuedcertificate.FieldKeyType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field key_type", values[i])
			} else if value.Valid {
				_m.KeyType = issuedcertificate.KeyType(value.String)
			}
		case issuedcertificate.FieldKeySize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field key_size", values[i])
			} else if value.Valid {
				_m.KeySize = int32(value.Int64)
			}
		case issuedcertificate.FieldAutoRenewEnabled:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field auto_renew_enabled", values[i])
			} else if value.Valid {
				_m.AutoRenewEnabled = value.Bool
			}
		case issuedcertificate.FieldAutoRenewDaysBeforeExpiry:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field auto_renew_days_before_expiry", values[i])
			} else if value.Valid {
				_m.AutoRenewDaysBeforeExpiry = int32(value.Int64)
			}
		case issuedcertificate.FieldAutoRenewMaxAttempts:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field auto_renew_max_attempts", values[i])
			} else if value.Valid {
				_m.AutoRenewMaxAttempts = int32(value.Int64)
			}
		case issuedcertificate.FieldAutoRenewRetryIntervalSeconds:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field auto_renew_retry_interval_seconds", values[i])
			} else if value.Valid {
				_m.AutoRenewRetryIntervalSeconds = value.Int64
			}
		case issuedcertificate.FieldLastRenewalAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field last_renewal_at", values[i])
			} else if value.Valid {
				_m.LastRenewalAt = value.Time
			}
		case issuedcertificate.FieldRenewalAttempts:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field renewal_attempts", values[i])
			} else if value.Valid {
				_m.RenewalAttempts = int32(value.Int64)
			}
		case issuedcertificate.FieldExpiresAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field expires_at", values[i])
			} else if value.Valid {
				_m.ExpiresAt = value.Time
			}
		case issuedcertificate.FieldRevokedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field revoked_at", values[i])
			} else if value.Valid {
				_m.RevokedAt = value.Time
			}
		case issuedcertificate.FieldRevokedReason:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field revoked_reason", values[i])
			} else if value.Valid {
				_m.RevokedReason = value.String
			}
		case issuedcertificate.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				_m.CreatedAt = value.Time
			}
		case issuedcertificate.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				_m.UpdatedAt = value.Time
			}
		case issuedcertificate.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field lcm_client_issued_certificates", value)
			} else if value.Valid {
				_m.lcm_client_issued_certificates = new(uint32)
				*_m.lcm_client_issued_certificates = uint32(value.Int64)
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the IssuedCertificate.
// This includes values selected through modifiers, order, etc.
func (_m *IssuedCertificate) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// QueryLcmClient queries the "lcm_client" edge of the IssuedCertificate entity.
func (_m *IssuedCertificate) QueryLcmClient() *LcmClientQuery {
	return NewIssuedCertificateClient(_m.config).QueryLcmClient(_m)
}

// QueryCertificateDetails queries the "certificate_details" edge of the IssuedCertificate entity.
func (_m *IssuedCertificate) QueryCertificateDetails() *CertificateDetailsQuery {
	return NewIssuedCertificateClient(_m.config).QueryCertificateDetails(_m)
}

// QueryPermissions queries the "permissions" edge of the IssuedCertificate entity.
func (_m *IssuedCertificate) QueryPermissions() *CertificatePermissionQuery {
	return NewIssuedCertificateClient(_m.config).QueryPermissions(_m)
}

// Update returns a builder for updating this IssuedCertificate.
// Note that you need to call IssuedCertificate.Unwrap() before calling this method if this IssuedCertificate
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *IssuedCertificate) Update() *IssuedCertificateUpdateOne {
	return NewIssuedCertificateClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the IssuedCertificate entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *IssuedCertificate) Unwrap() *IssuedCertificate {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("ent: IssuedCertificate is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *IssuedCertificate) String() string {
	var builder strings.Builder
	builder.WriteString("IssuedCertificate(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("client_id=")
	builder.WriteString(_m.ClientID)
	builder.WriteString(", ")
	builder.WriteString("issuer_name=")
	builder.WriteString(_m.IssuerName)
	builder.WriteString(", ")
	builder.WriteString("issuer_type=")
	builder.WriteString(_m.IssuerType)
	builder.WriteString(", ")
	builder.WriteString("tenant_id=")
	builder.WriteString(fmt.Sprintf("%v", _m.TenantID))
	builder.WriteString(", ")
	builder.WriteString("common_name=")
	builder.WriteString(_m.CommonName)
	builder.WriteString(", ")
	builder.WriteString("domains=")
	builder.WriteString(fmt.Sprintf("%v", _m.Domains))
	builder.WriteString(", ")
	builder.WriteString("ip_addresses=")
	builder.WriteString(fmt.Sprintf("%v", _m.IPAddresses))
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", _m.Status))
	builder.WriteString(", ")
	builder.WriteString("cert_pem=")
	builder.WriteString(_m.CertPem)
	builder.WriteString(", ")
	builder.WriteString("private_key_pem=")
	builder.WriteString(_m.PrivateKeyPem)
	builder.WriteString(", ")
	builder.WriteString("server_generated_key=")
	builder.WriteString(fmt.Sprintf("%v", _m.ServerGeneratedKey))
	builder.WriteString(", ")
	builder.WriteString("ca_cert_pem=")
	builder.WriteString(_m.CaCertPem)
	builder.WriteString(", ")
	builder.WriteString("csr_pem=")
	builder.WriteString(_m.CsrPem)
	builder.WriteString(", ")
	builder.WriteString("certificate_fingerprint=")
	builder.WriteString(_m.CertificateFingerprint)
	builder.WriteString(", ")
	builder.WriteString("error_message=")
	builder.WriteString(_m.ErrorMessage)
	builder.WriteString(", ")
	builder.WriteString("key_type=")
	builder.WriteString(fmt.Sprintf("%v", _m.KeyType))
	builder.WriteString(", ")
	builder.WriteString("key_size=")
	builder.WriteString(fmt.Sprintf("%v", _m.KeySize))
	builder.WriteString(", ")
	builder.WriteString("auto_renew_enabled=")
	builder.WriteString(fmt.Sprintf("%v", _m.AutoRenewEnabled))
	builder.WriteString(", ")
	builder.WriteString("auto_renew_days_before_expiry=")
	builder.WriteString(fmt.Sprintf("%v", _m.AutoRenewDaysBeforeExpiry))
	builder.WriteString(", ")
	builder.WriteString("auto_renew_max_attempts=")
	builder.WriteString(fmt.Sprintf("%v", _m.AutoRenewMaxAttempts))
	builder.WriteString(", ")
	builder.WriteString("auto_renew_retry_interval_seconds=")
	builder.WriteString(fmt.Sprintf("%v", _m.AutoRenewRetryIntervalSeconds))
	builder.WriteString(", ")
	builder.WriteString("last_renewal_at=")
	builder.WriteString(_m.LastRenewalAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("renewal_attempts=")
	builder.WriteString(fmt.Sprintf("%v", _m.RenewalAttempts))
	builder.WriteString(", ")
	builder.WriteString("expires_at=")
	builder.WriteString(_m.ExpiresAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("revoked_at=")
	builder.WriteString(_m.RevokedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("revoked_reason=")
	builder.WriteString(_m.RevokedReason)
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// IssuedCertificates is a parsable slice of IssuedCertificate.
type IssuedCertificates []*IssuedCertificate
