// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/migrate"

	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/acmeissuer"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/auditlog"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/certificatedetails"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/certificatepermission"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/certificaterenewal"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/certificaterequest"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/clientissuer"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/issuedcertificate"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/issuer"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/lcmca"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/lcmclient"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/mtlscertificate"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/mtlscertificaterequest"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/selfsignedissuer"
	"github.com/go-tangra/go-tangra-portal/app/lcm/service/internal/data/ent/tenantsecret"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AcmeIssuer is the client for interacting with the AcmeIssuer builders.
	AcmeIssuer *AcmeIssuerClient
	// AuditLog is the client for interacting with the AuditLog builders.
	AuditLog *AuditLogClient
	// CertificateDetails is the client for interacting with the CertificateDetails builders.
	CertificateDetails *CertificateDetailsClient
	// CertificatePermission is the client for interacting with the CertificatePermission builders.
	CertificatePermission *CertificatePermissionClient
	// CertificateRenewal is the client for interacting with the CertificateRenewal builders.
	CertificateRenewal *CertificateRenewalClient
	// CertificateRequest is the client for interacting with the CertificateRequest builders.
	CertificateRequest *CertificateRequestClient
	// ClientIssuer is the client for interacting with the ClientIssuer builders.
	ClientIssuer *ClientIssuerClient
	// IssuedCertificate is the client for interacting with the IssuedCertificate builders.
	IssuedCertificate *IssuedCertificateClient
	// Issuer is the client for interacting with the Issuer builders.
	Issuer *IssuerClient
	// LcmCa is the client for interacting with the LcmCa builders.
	LcmCa *LcmCaClient
	// LcmClient is the client for interacting with the LcmClient builders.
	LcmClient *LcmClientClient
	// MtlsCertificate is the client for interacting with the MtlsCertificate builders.
	MtlsCertificate *MtlsCertificateClient
	// MtlsCertificateRequest is the client for interacting with the MtlsCertificateRequest builders.
	MtlsCertificateRequest *MtlsCertificateRequestClient
	// SelfSignedIssuer is the client for interacting with the SelfSignedIssuer builders.
	SelfSignedIssuer *SelfSignedIssuerClient
	// TenantSecret is the client for interacting with the TenantSecret builders.
	TenantSecret *TenantSecretClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AcmeIssuer = NewAcmeIssuerClient(c.config)
	c.AuditLog = NewAuditLogClient(c.config)
	c.CertificateDetails = NewCertificateDetailsClient(c.config)
	c.CertificatePermission = NewCertificatePermissionClient(c.config)
	c.CertificateRenewal = NewCertificateRenewalClient(c.config)
	c.CertificateRequest = NewCertificateRequestClient(c.config)
	c.ClientIssuer = NewClientIssuerClient(c.config)
	c.IssuedCertificate = NewIssuedCertificateClient(c.config)
	c.Issuer = NewIssuerClient(c.config)
	c.LcmCa = NewLcmCaClient(c.config)
	c.LcmClient = NewLcmClientClient(c.config)
	c.MtlsCertificate = NewMtlsCertificateClient(c.config)
	c.MtlsCertificateRequest = NewMtlsCertificateRequestClient(c.config)
	c.SelfSignedIssuer = NewSelfSignedIssuerClient(c.config)
	c.TenantSecret = NewTenantSecretClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		AcmeIssuer:             NewAcmeIssuerClient(cfg),
		AuditLog:               NewAuditLogClient(cfg),
		CertificateDetails:     NewCertificateDetailsClient(cfg),
		CertificatePermission:  NewCertificatePermissionClient(cfg),
		CertificateRenewal:     NewCertificateRenewalClient(cfg),
		CertificateRequest:     NewCertificateRequestClient(cfg),
		ClientIssuer:           NewClientIssuerClient(cfg),
		IssuedCertificate:      NewIssuedCertificateClient(cfg),
		Issuer:                 NewIssuerClient(cfg),
		LcmCa:                  NewLcmCaClient(cfg),
		LcmClient:              NewLcmClientClient(cfg),
		MtlsCertificate:        NewMtlsCertificateClient(cfg),
		MtlsCertificateRequest: NewMtlsCertificateRequestClient(cfg),
		SelfSignedIssuer:       NewSelfSignedIssuerClient(cfg),
		TenantSecret:           NewTenantSecretClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		AcmeIssuer:             NewAcmeIssuerClient(cfg),
		AuditLog:               NewAuditLogClient(cfg),
		CertificateDetails:     NewCertificateDetailsClient(cfg),
		CertificatePermission:  NewCertificatePermissionClient(cfg),
		CertificateRenewal:     NewCertificateRenewalClient(cfg),
		CertificateRequest:     NewCertificateRequestClient(cfg),
		ClientIssuer:           NewClientIssuerClient(cfg),
		IssuedCertificate:      NewIssuedCertificateClient(cfg),
		Issuer:                 NewIssuerClient(cfg),
		LcmCa:                  NewLcmCaClient(cfg),
		LcmClient:              NewLcmClientClient(cfg),
		MtlsCertificate:        NewMtlsCertificateClient(cfg),
		MtlsCertificateRequest: NewMtlsCertificateRequestClient(cfg),
		SelfSignedIssuer:       NewSelfSignedIssuerClient(cfg),
		TenantSecret:           NewTenantSecretClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AcmeIssuer.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AcmeIssuer, c.AuditLog, c.CertificateDetails, c.CertificatePermission,
		c.CertificateRenewal, c.CertificateRequest, c.ClientIssuer,
		c.IssuedCertificate, c.Issuer, c.LcmCa, c.LcmClient, c.MtlsCertificate,
		c.MtlsCertificateRequest, c.SelfSignedIssuer, c.TenantSecret,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AcmeIssuer, c.AuditLog, c.CertificateDetails, c.CertificatePermission,
		c.CertificateRenewal, c.CertificateRequest, c.ClientIssuer,
		c.IssuedCertificate, c.Issuer, c.LcmCa, c.LcmClient, c.MtlsCertificate,
		c.MtlsCertificateRequest, c.SelfSignedIssuer, c.TenantSecret,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AcmeIssuerMutation:
		return c.AcmeIssuer.mutate(ctx, m)
	case *AuditLogMutation:
		return c.AuditLog.mutate(ctx, m)
	case *CertificateDetailsMutation:
		return c.CertificateDetails.mutate(ctx, m)
	case *CertificatePermissionMutation:
		return c.CertificatePermission.mutate(ctx, m)
	case *CertificateRenewalMutation:
		return c.CertificateRenewal.mutate(ctx, m)
	case *CertificateRequestMutation:
		return c.CertificateRequest.mutate(ctx, m)
	case *ClientIssuerMutation:
		return c.ClientIssuer.mutate(ctx, m)
	case *IssuedCertificateMutation:
		return c.IssuedCertificate.mutate(ctx, m)
	case *IssuerMutation:
		return c.Issuer.mutate(ctx, m)
	case *LcmCaMutation:
		return c.LcmCa.mutate(ctx, m)
	case *LcmClientMutation:
		return c.LcmClient.mutate(ctx, m)
	case *MtlsCertificateMutation:
		return c.MtlsCertificate.mutate(ctx, m)
	case *MtlsCertificateRequestMutation:
		return c.MtlsCertificateRequest.mutate(ctx, m)
	case *SelfSignedIssuerMutation:
		return c.SelfSignedIssuer.mutate(ctx, m)
	case *TenantSecretMutation:
		return c.TenantSecret.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AcmeIssuerClient is a client for the AcmeIssuer schema.
type AcmeIssuerClient struct {
	config
}

// NewAcmeIssuerClient returns a client for the AcmeIssuer from the given config.
func NewAcmeIssuerClient(c config) *AcmeIssuerClient {
	return &AcmeIssuerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `acmeissuer.Hooks(f(g(h())))`.
func (c *AcmeIssuerClient) Use(hooks ...Hook) {
	c.hooks.AcmeIssuer = append(c.hooks.AcmeIssuer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `acmeissuer.Intercept(f(g(h())))`.
func (c *AcmeIssuerClient) Intercept(interceptors ...Interceptor) {
	c.inters.AcmeIssuer = append(c.inters.AcmeIssuer, interceptors...)
}

// Create returns a builder for creating a AcmeIssuer entity.
func (c *AcmeIssuerClient) Create() *AcmeIssuerCreate {
	mutation := newAcmeIssuerMutation(c.config, OpCreate)
	return &AcmeIssuerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AcmeIssuer entities.
func (c *AcmeIssuerClient) CreateBulk(builders ...*AcmeIssuerCreate) *AcmeIssuerCreateBulk {
	return &AcmeIssuerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AcmeIssuerClient) MapCreateBulk(slice any, setFunc func(*AcmeIssuerCreate, int)) *AcmeIssuerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AcmeIssuerCreateBulk{err: fmt.Errorf("calling to AcmeIssuerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AcmeIssuerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AcmeIssuerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AcmeIssuer.
func (c *AcmeIssuerClient) Update() *AcmeIssuerUpdate {
	mutation := newAcmeIssuerMutation(c.config, OpUpdate)
	return &AcmeIssuerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AcmeIssuerClient) UpdateOne(_m *AcmeIssuer) *AcmeIssuerUpdateOne {
	mutation := newAcmeIssuerMutation(c.config, OpUpdateOne, withAcmeIssuer(_m))
	return &AcmeIssuerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AcmeIssuerClient) UpdateOneID(id int) *AcmeIssuerUpdateOne {
	mutation := newAcmeIssuerMutation(c.config, OpUpdateOne, withAcmeIssuerID(id))
	return &AcmeIssuerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AcmeIssuer.
func (c *AcmeIssuerClient) Delete() *AcmeIssuerDelete {
	mutation := newAcmeIssuerMutation(c.config, OpDelete)
	return &AcmeIssuerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AcmeIssuerClient) DeleteOne(_m *AcmeIssuer) *AcmeIssuerDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AcmeIssuerClient) DeleteOneID(id int) *AcmeIssuerDeleteOne {
	builder := c.Delete().Where(acmeissuer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AcmeIssuerDeleteOne{builder}
}

// Query returns a query builder for AcmeIssuer.
func (c *AcmeIssuerClient) Query() *AcmeIssuerQuery {
	return &AcmeIssuerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAcmeIssuer},
		inters: c.Interceptors(),
	}
}

// Get returns a AcmeIssuer entity by its id.
func (c *AcmeIssuerClient) Get(ctx context.Context, id int) (*AcmeIssuer, error) {
	return c.Query().Where(acmeissuer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AcmeIssuerClient) GetX(ctx context.Context, id int) *AcmeIssuer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIssuer queries the issuer edge of a AcmeIssuer.
func (c *AcmeIssuerClient) QueryIssuer(_m *AcmeIssuer) *IssuerQuery {
	query := (&IssuerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(acmeissuer.Table, acmeissuer.FieldID, id),
			sqlgraph.To(issuer.Table, issuer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, acmeissuer.IssuerTable, acmeissuer.IssuerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AcmeIssuerClient) Hooks() []Hook {
	return c.hooks.AcmeIssuer
}

// Interceptors returns the client interceptors.
func (c *AcmeIssuerClient) Interceptors() []Interceptor {
	return c.inters.AcmeIssuer
}

func (c *AcmeIssuerClient) mutate(ctx context.Context, m *AcmeIssuerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AcmeIssuerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AcmeIssuerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AcmeIssuerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AcmeIssuerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AcmeIssuer mutation op: %q", m.Op())
	}
}

// AuditLogClient is a client for the AuditLog schema.
type AuditLogClient struct {
	config
}

// NewAuditLogClient returns a client for the AuditLog from the given config.
func NewAuditLogClient(c config) *AuditLogClient {
	return &AuditLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `auditlog.Hooks(f(g(h())))`.
func (c *AuditLogClient) Use(hooks ...Hook) {
	c.hooks.AuditLog = append(c.hooks.AuditLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `auditlog.Intercept(f(g(h())))`.
func (c *AuditLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuditLog = append(c.inters.AuditLog, interceptors...)
}

// Create returns a builder for creating a AuditLog entity.
func (c *AuditLogClient) Create() *AuditLogCreate {
	mutation := newAuditLogMutation(c.config, OpCreate)
	return &AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuditLog entities.
func (c *AuditLogClient) CreateBulk(builders ...*AuditLogCreate) *AuditLogCreateBulk {
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuditLogClient) MapCreateBulk(slice any, setFunc func(*AuditLogCreate, int)) *AuditLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuditLogCreateBulk{err: fmt.Errorf("calling to AuditLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuditLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuditLog.
func (c *AuditLogClient) Update() *AuditLogUpdate {
	mutation := newAuditLogMutation(c.config, OpUpdate)
	return &AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuditLogClient) UpdateOne(_m *AuditLog) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLog(_m))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuditLogClient) UpdateOneID(id uint32) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLogID(id))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuditLog.
func (c *AuditLogClient) Delete() *AuditLogDelete {
	mutation := newAuditLogMutation(c.config, OpDelete)
	return &AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuditLogClient) DeleteOne(_m *AuditLog) *AuditLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuditLogClient) DeleteOneID(id uint32) *AuditLogDeleteOne {
	builder := c.Delete().Where(auditlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuditLogDeleteOne{builder}
}

// Query returns a query builder for AuditLog.
func (c *AuditLogClient) Query() *AuditLogQuery {
	return &AuditLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuditLog},
		inters: c.Interceptors(),
	}
}

// Get returns a AuditLog entity by its id.
func (c *AuditLogClient) Get(ctx context.Context, id uint32) (*AuditLog, error) {
	return c.Query().Where(auditlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuditLogClient) GetX(ctx context.Context, id uint32) *AuditLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuditLogClient) Hooks() []Hook {
	hooks := c.hooks.AuditLog
	return append(hooks[:len(hooks):len(hooks)], auditlog.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AuditLogClient) Interceptors() []Interceptor {
	return c.inters.AuditLog
}

func (c *AuditLogClient) mutate(ctx context.Context, m *AuditLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuditLog mutation op: %q", m.Op())
	}
}

// CertificateDetailsClient is a client for the CertificateDetails schema.
type CertificateDetailsClient struct {
	config
}

// NewCertificateDetailsClient returns a client for the CertificateDetails from the given config.
func NewCertificateDetailsClient(c config) *CertificateDetailsClient {
	return &CertificateDetailsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certificatedetails.Hooks(f(g(h())))`.
func (c *CertificateDetailsClient) Use(hooks ...Hook) {
	c.hooks.CertificateDetails = append(c.hooks.CertificateDetails, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certificatedetails.Intercept(f(g(h())))`.
func (c *CertificateDetailsClient) Intercept(interceptors ...Interceptor) {
	c.inters.CertificateDetails = append(c.inters.CertificateDetails, interceptors...)
}

// Create returns a builder for creating a CertificateDetails entity.
func (c *CertificateDetailsClient) Create() *CertificateDetailsCreate {
	mutation := newCertificateDetailsMutation(c.config, OpCreate)
	return &CertificateDetailsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CertificateDetails entities.
func (c *CertificateDetailsClient) CreateBulk(builders ...*CertificateDetailsCreate) *CertificateDetailsCreateBulk {
	return &CertificateDetailsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertificateDetailsClient) MapCreateBulk(slice any, setFunc func(*CertificateDetailsCreate, int)) *CertificateDetailsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertificateDetailsCreateBulk{err: fmt.Errorf("calling to CertificateDetailsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertificateDetailsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertificateDetailsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CertificateDetails.
func (c *CertificateDetailsClient) Update() *CertificateDetailsUpdate {
	mutation := newCertificateDetailsMutation(c.config, OpUpdate)
	return &CertificateDetailsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertificateDetailsClient) UpdateOne(_m *CertificateDetails) *CertificateDetailsUpdateOne {
	mutation := newCertificateDetailsMutation(c.config, OpUpdateOne, withCertificateDetails(_m))
	return &CertificateDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertificateDetailsClient) UpdateOneID(id uint32) *CertificateDetailsUpdateOne {
	mutation := newCertificateDetailsMutation(c.config, OpUpdateOne, withCertificateDetailsID(id))
	return &CertificateDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CertificateDetails.
func (c *CertificateDetailsClient) Delete() *CertificateDetailsDelete {
	mutation := newCertificateDetailsMutation(c.config, OpDelete)
	return &CertificateDetailsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertificateDetailsClient) DeleteOne(_m *CertificateDetails) *CertificateDetailsDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertificateDetailsClient) DeleteOneID(id uint32) *CertificateDetailsDeleteOne {
	builder := c.Delete().Where(certificatedetails.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertificateDetailsDeleteOne{builder}
}

// Query returns a query builder for CertificateDetails.
func (c *CertificateDetailsClient) Query() *CertificateDetailsQuery {
	return &CertificateDetailsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertificateDetails},
		inters: c.Interceptors(),
	}
}

// Get returns a CertificateDetails entity by its id.
func (c *CertificateDetailsClient) Get(ctx context.Context, id uint32) (*CertificateDetails, error) {
	return c.Query().Where(certificatedetails.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertificateDetailsClient) GetX(ctx context.Context, id uint32) *CertificateDetails {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIssuedCertificate queries the issued_certificate edge of a CertificateDetails.
func (c *CertificateDetailsClient) QueryIssuedCertificate(_m *CertificateDetails) *IssuedCertificateQuery {
	query := (&IssuedCertificateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certificatedetails.Table, certificatedetails.FieldID, id),
			sqlgraph.To(issuedcertificate.Table, issuedcertificate.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, certificatedetails.IssuedCertificateTable, certificatedetails.IssuedCertificateColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertificateDetailsClient) Hooks() []Hook {
	return c.hooks.CertificateDetails
}

// Interceptors returns the client interceptors.
func (c *CertificateDetailsClient) Interceptors() []Interceptor {
	return c.inters.CertificateDetails
}

func (c *CertificateDetailsClient) mutate(ctx context.Context, m *CertificateDetailsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertificateDetailsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertificateDetailsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertificateDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertificateDetailsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CertificateDetails mutation op: %q", m.Op())
	}
}

// CertificatePermissionClient is a client for the CertificatePermission schema.
type CertificatePermissionClient struct {
	config
}

// NewCertificatePermissionClient returns a client for the CertificatePermission from the given config.
func NewCertificatePermissionClient(c config) *CertificatePermissionClient {
	return &CertificatePermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certificatepermission.Hooks(f(g(h())))`.
func (c *CertificatePermissionClient) Use(hooks ...Hook) {
	c.hooks.CertificatePermission = append(c.hooks.CertificatePermission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certificatepermission.Intercept(f(g(h())))`.
func (c *CertificatePermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.CertificatePermission = append(c.inters.CertificatePermission, interceptors...)
}

// Create returns a builder for creating a CertificatePermission entity.
func (c *CertificatePermissionClient) Create() *CertificatePermissionCreate {
	mutation := newCertificatePermissionMutation(c.config, OpCreate)
	return &CertificatePermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CertificatePermission entities.
func (c *CertificatePermissionClient) CreateBulk(builders ...*CertificatePermissionCreate) *CertificatePermissionCreateBulk {
	return &CertificatePermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertificatePermissionClient) MapCreateBulk(slice any, setFunc func(*CertificatePermissionCreate, int)) *CertificatePermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertificatePermissionCreateBulk{err: fmt.Errorf("calling to CertificatePermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertificatePermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertificatePermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CertificatePermission.
func (c *CertificatePermissionClient) Update() *CertificatePermissionUpdate {
	mutation := newCertificatePermissionMutation(c.config, OpUpdate)
	return &CertificatePermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertificatePermissionClient) UpdateOne(_m *CertificatePermission) *CertificatePermissionUpdateOne {
	mutation := newCertificatePermissionMutation(c.config, OpUpdateOne, withCertificatePermission(_m))
	return &CertificatePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertificatePermissionClient) UpdateOneID(id uint32) *CertificatePermissionUpdateOne {
	mutation := newCertificatePermissionMutation(c.config, OpUpdateOne, withCertificatePermissionID(id))
	return &CertificatePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CertificatePermission.
func (c *CertificatePermissionClient) Delete() *CertificatePermissionDelete {
	mutation := newCertificatePermissionMutation(c.config, OpDelete)
	return &CertificatePermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertificatePermissionClient) DeleteOne(_m *CertificatePermission) *CertificatePermissionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertificatePermissionClient) DeleteOneID(id uint32) *CertificatePermissionDeleteOne {
	builder := c.Delete().Where(certificatepermission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertificatePermissionDeleteOne{builder}
}

// Query returns a query builder for CertificatePermission.
func (c *CertificatePermissionClient) Query() *CertificatePermissionQuery {
	return &CertificatePermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertificatePermission},
		inters: c.Interceptors(),
	}
}

// Get returns a CertificatePermission entity by its id.
func (c *CertificatePermissionClient) Get(ctx context.Context, id uint32) (*CertificatePermission, error) {
	return c.Query().Where(certificatepermission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertificatePermissionClient) GetX(ctx context.Context, id uint32) *CertificatePermission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIssuedCertificate queries the issued_certificate edge of a CertificatePermission.
func (c *CertificatePermissionClient) QueryIssuedCertificate(_m *CertificatePermission) *IssuedCertificateQuery {
	query := (&IssuedCertificateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certificatepermission.Table, certificatepermission.FieldID, id),
			sqlgraph.To(issuedcertificate.Table, issuedcertificate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certificatepermission.IssuedCertificateTable, certificatepermission.IssuedCertificateColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGrantee queries the grantee edge of a CertificatePermission.
func (c *CertificatePermissionClient) QueryGrantee(_m *CertificatePermission) *LcmClientQuery {
	query := (&LcmClientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certificatepermission.Table, certificatepermission.FieldID, id),
			sqlgraph.To(lcmclient.Table, lcmclient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certificatepermission.GranteeTable, certificatepermission.GranteeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertificatePermissionClient) Hooks() []Hook {
	hooks := c.hooks.CertificatePermission
	return append(hooks[:len(hooks):len(hooks)], certificatepermission.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CertificatePermissionClient) Interceptors() []Interceptor {
	return c.inters.CertificatePermission
}

func (c *CertificatePermissionClient) mutate(ctx context.Context, m *CertificatePermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertificatePermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertificatePermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertificatePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertificatePermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CertificatePermission mutation op: %q", m.Op())
	}
}

// CertificateRenewalClient is a client for the CertificateRenewal schema.
type CertificateRenewalClient struct {
	config
}

// NewCertificateRenewalClient returns a client for the CertificateRenewal from the given config.
func NewCertificateRenewalClient(c config) *CertificateRenewalClient {
	return &CertificateRenewalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certificaterenewal.Hooks(f(g(h())))`.
func (c *CertificateRenewalClient) Use(hooks ...Hook) {
	c.hooks.CertificateRenewal = append(c.hooks.CertificateRenewal, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certificaterenewal.Intercept(f(g(h())))`.
func (c *CertificateRenewalClient) Intercept(interceptors ...Interceptor) {
	c.inters.CertificateRenewal = append(c.inters.CertificateRenewal, interceptors...)
}

// Create returns a builder for creating a CertificateRenewal entity.
func (c *CertificateRenewalClient) Create() *CertificateRenewalCreate {
	mutation := newCertificateRenewalMutation(c.config, OpCreate)
	return &CertificateRenewalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CertificateRenewal entities.
func (c *CertificateRenewalClient) CreateBulk(builders ...*CertificateRenewalCreate) *CertificateRenewalCreateBulk {
	return &CertificateRenewalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertificateRenewalClient) MapCreateBulk(slice any, setFunc func(*CertificateRenewalCreate, int)) *CertificateRenewalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertificateRenewalCreateBulk{err: fmt.Errorf("calling to CertificateRenewalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertificateRenewalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertificateRenewalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CertificateRenewal.
func (c *CertificateRenewalClient) Update() *CertificateRenewalUpdate {
	mutation := newCertificateRenewalMutation(c.config, OpUpdate)
	return &CertificateRenewalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertificateRenewalClient) UpdateOne(_m *CertificateRenewal) *CertificateRenewalUpdateOne {
	mutation := newCertificateRenewalMutation(c.config, OpUpdateOne, withCertificateRenewal(_m))
	return &CertificateRenewalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertificateRenewalClient) UpdateOneID(id int) *CertificateRenewalUpdateOne {
	mutation := newCertificateRenewalMutation(c.config, OpUpdateOne, withCertificateRenewalID(id))
	return &CertificateRenewalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CertificateRenewal.
func (c *CertificateRenewalClient) Delete() *CertificateRenewalDelete {
	mutation := newCertificateRenewalMutation(c.config, OpDelete)
	return &CertificateRenewalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertificateRenewalClient) DeleteOne(_m *CertificateRenewal) *CertificateRenewalDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertificateRenewalClient) DeleteOneID(id int) *CertificateRenewalDeleteOne {
	builder := c.Delete().Where(certificaterenewal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertificateRenewalDeleteOne{builder}
}

// Query returns a query builder for CertificateRenewal.
func (c *CertificateRenewalClient) Query() *CertificateRenewalQuery {
	return &CertificateRenewalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertificateRenewal},
		inters: c.Interceptors(),
	}
}

// Get returns a CertificateRenewal entity by its id.
func (c *CertificateRenewalClient) Get(ctx context.Context, id int) (*CertificateRenewal, error) {
	return c.Query().Where(certificaterenewal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertificateRenewalClient) GetX(ctx context.Context, id int) *CertificateRenewal {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIssuedCertificate queries the issued_certificate edge of a CertificateRenewal.
func (c *CertificateRenewalClient) QueryIssuedCertificate(_m *CertificateRenewal) *IssuedCertificateQuery {
	query := (&IssuedCertificateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certificaterenewal.Table, certificaterenewal.FieldID, id),
			sqlgraph.To(issuedcertificate.Table, issuedcertificate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certificaterenewal.IssuedCertificateTable, certificaterenewal.IssuedCertificateColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertificateRenewalClient) Hooks() []Hook {
	return c.hooks.CertificateRenewal
}

// Interceptors returns the client interceptors.
func (c *CertificateRenewalClient) Interceptors() []Interceptor {
	return c.inters.CertificateRenewal
}

func (c *CertificateRenewalClient) mutate(ctx context.Context, m *CertificateRenewalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertificateRenewalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertificateRenewalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertificateRenewalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertificateRenewalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CertificateRenewal mutation op: %q", m.Op())
	}
}

// CertificateRequestClient is a client for the CertificateRequest schema.
type CertificateRequestClient struct {
	config
}

// NewCertificateRequestClient returns a client for the CertificateRequest from the given config.
func NewCertificateRequestClient(c config) *CertificateRequestClient {
	return &CertificateRequestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certificaterequest.Hooks(f(g(h())))`.
func (c *CertificateRequestClient) Use(hooks ...Hook) {
	c.hooks.CertificateRequest = append(c.hooks.CertificateRequest, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certificaterequest.Intercept(f(g(h())))`.
func (c *CertificateRequestClient) Intercept(interceptors ...Interceptor) {
	c.inters.CertificateRequest = append(c.inters.CertificateRequest, interceptors...)
}

// Create returns a builder for creating a CertificateRequest entity.
func (c *CertificateRequestClient) Create() *CertificateRequestCreate {
	mutation := newCertificateRequestMutation(c.config, OpCreate)
	return &CertificateRequestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CertificateRequest entities.
func (c *CertificateRequestClient) CreateBulk(builders ...*CertificateRequestCreate) *CertificateRequestCreateBulk {
	return &CertificateRequestCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertificateRequestClient) MapCreateBulk(slice any, setFunc func(*CertificateRequestCreate, int)) *CertificateRequestCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertificateRequestCreateBulk{err: fmt.Errorf("calling to CertificateRequestClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertificateRequestCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertificateRequestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CertificateRequest.
func (c *CertificateRequestClient) Update() *CertificateRequestUpdate {
	mutation := newCertificateRequestMutation(c.config, OpUpdate)
	return &CertificateRequestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertificateRequestClient) UpdateOne(_m *CertificateRequest) *CertificateRequestUpdateOne {
	mutation := newCertificateRequestMutation(c.config, OpUpdateOne, withCertificateRequest(_m))
	return &CertificateRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertificateRequestClient) UpdateOneID(id int) *CertificateRequestUpdateOne {
	mutation := newCertificateRequestMutation(c.config, OpUpdateOne, withCertificateRequestID(id))
	return &CertificateRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CertificateRequest.
func (c *CertificateRequestClient) Delete() *CertificateRequestDelete {
	mutation := newCertificateRequestMutation(c.config, OpDelete)
	return &CertificateRequestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertificateRequestClient) DeleteOne(_m *CertificateRequest) *CertificateRequestDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertificateRequestClient) DeleteOneID(id int) *CertificateRequestDeleteOne {
	builder := c.Delete().Where(certificaterequest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertificateRequestDeleteOne{builder}
}

// Query returns a query builder for CertificateRequest.
func (c *CertificateRequestClient) Query() *CertificateRequestQuery {
	return &CertificateRequestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertificateRequest},
		inters: c.Interceptors(),
	}
}

// Get returns a CertificateRequest entity by its id.
func (c *CertificateRequestClient) Get(ctx context.Context, id int) (*CertificateRequest, error) {
	return c.Query().Where(certificaterequest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertificateRequestClient) GetX(ctx context.Context, id int) *CertificateRequest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIssuer queries the issuer edge of a CertificateRequest.
func (c *CertificateRequestClient) QueryIssuer(_m *CertificateRequest) *IssuerQuery {
	query := (&IssuerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certificaterequest.Table, certificaterequest.FieldID, id),
			sqlgraph.To(issuer.Table, issuer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certificaterequest.IssuerTable, certificaterequest.IssuerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLcmClient queries the lcm_client edge of a CertificateRequest.
func (c *CertificateRequestClient) QueryLcmClient(_m *CertificateRequest) *LcmClientQuery {
	query := (&LcmClientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certificaterequest.Table, certificaterequest.FieldID, id),
			sqlgraph.To(lcmclient.Table, lcmclient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, certificaterequest.LcmClientTable, certificaterequest.LcmClientColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertificateRequestClient) Hooks() []Hook {
	return c.hooks.CertificateRequest
}

// Interceptors returns the client interceptors.
func (c *CertificateRequestClient) Interceptors() []Interceptor {
	return c.inters.CertificateRequest
}

func (c *CertificateRequestClient) mutate(ctx context.Context, m *CertificateRequestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertificateRequestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertificateRequestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertificateRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertificateRequestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CertificateRequest mutation op: %q", m.Op())
	}
}

// ClientIssuerClient is a client for the ClientIssuer schema.
type ClientIssuerClient struct {
	config
}

// NewClientIssuerClient returns a client for the ClientIssuer from the given config.
func NewClientIssuerClient(c config) *ClientIssuerClient {
	return &ClientIssuerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `clientissuer.Hooks(f(g(h())))`.
func (c *ClientIssuerClient) Use(hooks ...Hook) {
	c.hooks.ClientIssuer = append(c.hooks.ClientIssuer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `clientissuer.Intercept(f(g(h())))`.
func (c *ClientIssuerClient) Intercept(interceptors ...Interceptor) {
	c.inters.ClientIssuer = append(c.inters.ClientIssuer, interceptors...)
}

// Create returns a builder for creating a ClientIssuer entity.
func (c *ClientIssuerClient) Create() *ClientIssuerCreate {
	mutation := newClientIssuerMutation(c.config, OpCreate)
	return &ClientIssuerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ClientIssuer entities.
func (c *ClientIssuerClient) CreateBulk(builders ...*ClientIssuerCreate) *ClientIssuerCreateBulk {
	return &ClientIssuerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ClientIssuerClient) MapCreateBulk(slice any, setFunc func(*ClientIssuerCreate, int)) *ClientIssuerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ClientIssuerCreateBulk{err: fmt.Errorf("calling to ClientIssuerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ClientIssuerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ClientIssuerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ClientIssuer.
func (c *ClientIssuerClient) Update() *ClientIssuerUpdate {
	mutation := newClientIssuerMutation(c.config, OpUpdate)
	return &ClientIssuerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClientIssuerClient) UpdateOne(_m *ClientIssuer) *ClientIssuerUpdateOne {
	mutation := newClientIssuerMutation(c.config, OpUpdateOne, withClientIssuer(_m))
	return &ClientIssuerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClientIssuerClient) UpdateOneID(id int) *ClientIssuerUpdateOne {
	mutation := newClientIssuerMutation(c.config, OpUpdateOne, withClientIssuerID(id))
	return &ClientIssuerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ClientIssuer.
func (c *ClientIssuerClient) Delete() *ClientIssuerDelete {
	mutation := newClientIssuerMutation(c.config, OpDelete)
	return &ClientIssuerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClientIssuerClient) DeleteOne(_m *ClientIssuer) *ClientIssuerDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClientIssuerClient) DeleteOneID(id int) *ClientIssuerDeleteOne {
	builder := c.Delete().Where(clientissuer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClientIssuerDeleteOne{builder}
}

// Query returns a query builder for ClientIssuer.
func (c *ClientIssuerClient) Query() *ClientIssuerQuery {
	return &ClientIssuerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClientIssuer},
		inters: c.Interceptors(),
	}
}

// Get returns a ClientIssuer entity by its id.
func (c *ClientIssuerClient) Get(ctx context.Context, id int) (*ClientIssuer, error) {
	return c.Query().Where(clientissuer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClientIssuerClient) GetX(ctx context.Context, id int) *ClientIssuer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIssuer queries the issuer edge of a ClientIssuer.
func (c *ClientIssuerClient) QueryIssuer(_m *ClientIssuer) *IssuerQuery {
	query := (&IssuerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clientissuer.Table, clientissuer.FieldID, id),
			sqlgraph.To(issuer.Table, issuer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, clientissuer.IssuerTable, clientissuer.IssuerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLcmClient queries the lcm_client edge of a ClientIssuer.
func (c *ClientIssuerClient) QueryLcmClient(_m *ClientIssuer) *LcmClientQuery {
	query := (&LcmClientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clientissuer.Table, clientissuer.FieldID, id),
			sqlgraph.To(lcmclient.Table, lcmclient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, clientissuer.LcmClientTable, clientissuer.LcmClientColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClientIssuerClient) Hooks() []Hook {
	return c.hooks.ClientIssuer
}

// Interceptors returns the client interceptors.
func (c *ClientIssuerClient) Interceptors() []Interceptor {
	return c.inters.ClientIssuer
}

func (c *ClientIssuerClient) mutate(ctx context.Context, m *ClientIssuerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClientIssuerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClientIssuerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClientIssuerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClientIssuerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ClientIssuer mutation op: %q", m.Op())
	}
}

// IssuedCertificateClient is a client for the IssuedCertificate schema.
type IssuedCertificateClient struct {
	config
}

// NewIssuedCertificateClient returns a client for the IssuedCertificate from the given config.
func NewIssuedCertificateClient(c config) *IssuedCertificateClient {
	return &IssuedCertificateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `issuedcertificate.Hooks(f(g(h())))`.
func (c *IssuedCertificateClient) Use(hooks ...Hook) {
	c.hooks.IssuedCertificate = append(c.hooks.IssuedCertificate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `issuedcertificate.Intercept(f(g(h())))`.
func (c *IssuedCertificateClient) Intercept(interceptors ...Interceptor) {
	c.inters.IssuedCertificate = append(c.inters.IssuedCertificate, interceptors...)
}

// Create returns a builder for creating a IssuedCertificate entity.
func (c *IssuedCertificateClient) Create() *IssuedCertificateCreate {
	mutation := newIssuedCertificateMutation(c.config, OpCreate)
	return &IssuedCertificateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IssuedCertificate entities.
func (c *IssuedCertificateClient) CreateBulk(builders ...*IssuedCertificateCreate) *IssuedCertificateCreateBulk {
	return &IssuedCertificateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IssuedCertificateClient) MapCreateBulk(slice any, setFunc func(*IssuedCertificateCreate, int)) *IssuedCertificateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IssuedCertificateCreateBulk{err: fmt.Errorf("calling to IssuedCertificateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IssuedCertificateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IssuedCertificateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IssuedCertificate.
func (c *IssuedCertificateClient) Update() *IssuedCertificateUpdate {
	mutation := newIssuedCertificateMutation(c.config, OpUpdate)
	return &IssuedCertificateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IssuedCertificateClient) UpdateOne(_m *IssuedCertificate) *IssuedCertificateUpdateOne {
	mutation := newIssuedCertificateMutation(c.config, OpUpdateOne, withIssuedCertificate(_m))
	return &IssuedCertificateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IssuedCertificateClient) UpdateOneID(id string) *IssuedCertificateUpdateOne {
	mutation := newIssuedCertificateMutation(c.config, OpUpdateOne, withIssuedCertificateID(id))
	return &IssuedCertificateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IssuedCertificate.
func (c *IssuedCertificateClient) Delete() *IssuedCertificateDelete {
	mutation := newIssuedCertificateMutation(c.config, OpDelete)
	return &IssuedCertificateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IssuedCertificateClient) DeleteOne(_m *IssuedCertificate) *IssuedCertificateDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IssuedCertificateClient) DeleteOneID(id string) *IssuedCertificateDeleteOne {
	builder := c.Delete().Where(issuedcertificate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IssuedCertificateDeleteOne{builder}
}

// Query returns a query builder for IssuedCertificate.
func (c *IssuedCertificateClient) Query() *IssuedCertificateQuery {
	return &IssuedCertificateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIssuedCertificate},
		inters: c.Interceptors(),
	}
}

// Get returns a IssuedCertificate entity by its id.
func (c *IssuedCertificateClient) Get(ctx context.Context, id string) (*IssuedCertificate, error) {
	return c.Query().Where(issuedcertificate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IssuedCertificateClient) GetX(ctx context.Context, id string) *IssuedCertificate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLcmClient queries the lcm_client edge of a IssuedCertificate.
func (c *IssuedCertificateClient) QueryLcmClient(_m *IssuedCertificate) *LcmClientQuery {
	query := (&LcmClientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(issuedcertificate.Table, issuedcertificate.FieldID, id),
			sqlgraph.To(lcmclient.Table, lcmclient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, issuedcertificate.LcmClientTable, issuedcertificate.LcmClientColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCertificateDetails queries the certificate_details edge of a IssuedCertificate.
func (c *IssuedCertificateClient) QueryCertificateDetails(_m *IssuedCertificate) *CertificateDetailsQuery {
	query := (&CertificateDetailsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(issuedcertificate.Table, issuedcertificate.FieldID, id),
			sqlgraph.To(certificatedetails.Table, certificatedetails.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, issuedcertificate.CertificateDetailsTable, issuedcertificate.CertificateDetailsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermissions queries the permissions edge of a IssuedCertificate.
func (c *IssuedCertificateClient) QueryPermissions(_m *IssuedCertificate) *CertificatePermissionQuery {
	query := (&CertificatePermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(issuedcertificate.Table, issuedcertificate.FieldID, id),
			sqlgraph.To(certificatepermission.Table, certificatepermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, issuedcertificate.PermissionsTable, issuedcertificate.PermissionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IssuedCertificateClient) Hooks() []Hook {
	return c.hooks.IssuedCertificate
}

// Interceptors returns the client interceptors.
func (c *IssuedCertificateClient) Interceptors() []Interceptor {
	return c.inters.IssuedCertificate
}

func (c *IssuedCertificateClient) mutate(ctx context.Context, m *IssuedCertificateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IssuedCertificateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IssuedCertificateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IssuedCertificateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IssuedCertificateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IssuedCertificate mutation op: %q", m.Op())
	}
}

// IssuerClient is a client for the Issuer schema.
type IssuerClient struct {
	config
}

// NewIssuerClient returns a client for the Issuer from the given config.
func NewIssuerClient(c config) *IssuerClient {
	return &IssuerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `issuer.Hooks(f(g(h())))`.
func (c *IssuerClient) Use(hooks ...Hook) {
	c.hooks.Issuer = append(c.hooks.Issuer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `issuer.Intercept(f(g(h())))`.
func (c *IssuerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Issuer = append(c.inters.Issuer, interceptors...)
}

// Create returns a builder for creating a Issuer entity.
func (c *IssuerClient) Create() *IssuerCreate {
	mutation := newIssuerMutation(c.config, OpCreate)
	return &IssuerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Issuer entities.
func (c *IssuerClient) CreateBulk(builders ...*IssuerCreate) *IssuerCreateBulk {
	return &IssuerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IssuerClient) MapCreateBulk(slice any, setFunc func(*IssuerCreate, int)) *IssuerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IssuerCreateBulk{err: fmt.Errorf("calling to IssuerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IssuerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IssuerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Issuer.
func (c *IssuerClient) Update() *IssuerUpdate {
	mutation := newIssuerMutation(c.config, OpUpdate)
	return &IssuerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IssuerClient) UpdateOne(_m *Issuer) *IssuerUpdateOne {
	mutation := newIssuerMutation(c.config, OpUpdateOne, withIssuer(_m))
	return &IssuerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IssuerClient) UpdateOneID(id uint32) *IssuerUpdateOne {
	mutation := newIssuerMutation(c.config, OpUpdateOne, withIssuerID(id))
	return &IssuerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Issuer.
func (c *IssuerClient) Delete() *IssuerDelete {
	mutation := newIssuerMutation(c.config, OpDelete)
	return &IssuerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IssuerClient) DeleteOne(_m *Issuer) *IssuerDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IssuerClient) DeleteOneID(id uint32) *IssuerDeleteOne {
	builder := c.Delete().Where(issuer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IssuerDeleteOne{builder}
}

// Query returns a query builder for Issuer.
func (c *IssuerClient) Query() *IssuerQuery {
	return &IssuerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIssuer},
		inters: c.Interceptors(),
	}
}

// Get returns a Issuer entity by its id.
func (c *IssuerClient) Get(ctx context.Context, id uint32) (*Issuer, error) {
	return c.Query().Where(issuer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IssuerClient) GetX(ctx context.Context, id uint32) *Issuer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySelfSignedConfigs queries the self_signed_configs edge of a Issuer.
func (c *IssuerClient) QuerySelfSignedConfigs(_m *Issuer) *SelfSignedIssuerQuery {
	query := (&SelfSignedIssuerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(issuer.Table, issuer.FieldID, id),
			sqlgraph.To(selfsignedissuer.Table, selfsignedissuer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, issuer.SelfSignedConfigsTable, issuer.SelfSignedConfigsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAcmeConfigs queries the acme_configs edge of a Issuer.
func (c *IssuerClient) QueryAcmeConfigs(_m *Issuer) *AcmeIssuerQuery {
	query := (&AcmeIssuerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(issuer.Table, issuer.FieldID, id),
			sqlgraph.To(acmeissuer.Table, acmeissuer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, issuer.AcmeConfigsTable, issuer.AcmeConfigsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCertificateRequests queries the certificate_requests edge of a Issuer.
func (c *IssuerClient) QueryCertificateRequests(_m *Issuer) *CertificateRequestQuery {
	query := (&CertificateRequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(issuer.Table, issuer.FieldID, id),
			sqlgraph.To(certificaterequest.Table, certificaterequest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, issuer.CertificateRequestsTable, issuer.CertificateRequestsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClientAssociations queries the client_associations edge of a Issuer.
func (c *IssuerClient) QueryClientAssociations(_m *Issuer) *ClientIssuerQuery {
	query := (&ClientIssuerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(issuer.Table, issuer.FieldID, id),
			sqlgraph.To(clientissuer.Table, clientissuer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, issuer.ClientAssociationsTable, issuer.ClientAssociationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLcmClient queries the lcm_client edge of a Issuer.
func (c *IssuerClient) QueryLcmClient(_m *Issuer) *LcmClientQuery {
	query := (&LcmClientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(issuer.Table, issuer.FieldID, id),
			sqlgraph.To(lcmclient.Table, lcmclient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, issuer.LcmClientTable, issuer.LcmClientColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IssuerClient) Hooks() []Hook {
	hooks := c.hooks.Issuer
	return append(hooks[:len(hooks):len(hooks)], issuer.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IssuerClient) Interceptors() []Interceptor {
	return c.inters.Issuer
}

func (c *IssuerClient) mutate(ctx context.Context, m *IssuerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IssuerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IssuerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IssuerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IssuerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Issuer mutation op: %q", m.Op())
	}
}

// LcmCaClient is a client for the LcmCa schema.
type LcmCaClient struct {
	config
}

// NewLcmCaClient returns a client for the LcmCa from the given config.
func NewLcmCaClient(c config) *LcmCaClient {
	return &LcmCaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lcmca.Hooks(f(g(h())))`.
func (c *LcmCaClient) Use(hooks ...Hook) {
	c.hooks.LcmCa = append(c.hooks.LcmCa, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lcmca.Intercept(f(g(h())))`.
func (c *LcmCaClient) Intercept(interceptors ...Interceptor) {
	c.inters.LcmCa = append(c.inters.LcmCa, interceptors...)
}

// Create returns a builder for creating a LcmCa entity.
func (c *LcmCaClient) Create() *LcmCaCreate {
	mutation := newLcmCaMutation(c.config, OpCreate)
	return &LcmCaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LcmCa entities.
func (c *LcmCaClient) CreateBulk(builders ...*LcmCaCreate) *LcmCaCreateBulk {
	return &LcmCaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LcmCaClient) MapCreateBulk(slice any, setFunc func(*LcmCaCreate, int)) *LcmCaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LcmCaCreateBulk{err: fmt.Errorf("calling to LcmCaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LcmCaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LcmCaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LcmCa.
func (c *LcmCaClient) Update() *LcmCaUpdate {
	mutation := newLcmCaMutation(c.config, OpUpdate)
	return &LcmCaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LcmCaClient) UpdateOne(_m *LcmCa) *LcmCaUpdateOne {
	mutation := newLcmCaMutation(c.config, OpUpdateOne, withLcmCa(_m))
	return &LcmCaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LcmCaClient) UpdateOneID(id uint32) *LcmCaUpdateOne {
	mutation := newLcmCaMutation(c.config, OpUpdateOne, withLcmCaID(id))
	return &LcmCaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LcmCa.
func (c *LcmCaClient) Delete() *LcmCaDelete {
	mutation := newLcmCaMutation(c.config, OpDelete)
	return &LcmCaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LcmCaClient) DeleteOne(_m *LcmCa) *LcmCaDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LcmCaClient) DeleteOneID(id uint32) *LcmCaDeleteOne {
	builder := c.Delete().Where(lcmca.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LcmCaDeleteOne{builder}
}

// Query returns a query builder for LcmCa.
func (c *LcmCaClient) Query() *LcmCaQuery {
	return &LcmCaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLcmCa},
		inters: c.Interceptors(),
	}
}

// Get returns a LcmCa entity by its id.
func (c *LcmCaClient) Get(ctx context.Context, id uint32) (*LcmCa, error) {
	return c.Query().Where(lcmca.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LcmCaClient) GetX(ctx context.Context, id uint32) *LcmCa {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLcmClient queries the lcm_client edge of a LcmCa.
func (c *LcmCaClient) QueryLcmClient(_m *LcmCa) *LcmClientQuery {
	query := (&LcmClientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lcmca.Table, lcmca.FieldID, id),
			sqlgraph.To(lcmclient.Table, lcmclient.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, lcmca.LcmClientTable, lcmca.LcmClientColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LcmCaClient) Hooks() []Hook {
	hooks := c.hooks.LcmCa
	return append(hooks[:len(hooks):len(hooks)], lcmca.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *LcmCaClient) Interceptors() []Interceptor {
	return c.inters.LcmCa
}

func (c *LcmCaClient) mutate(ctx context.Context, m *LcmCaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LcmCaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LcmCaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LcmCaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LcmCaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LcmCa mutation op: %q", m.Op())
	}
}

// LcmClientClient is a client for the LcmClient schema.
type LcmClientClient struct {
	config
}

// NewLcmClientClient returns a client for the LcmClient from the given config.
func NewLcmClientClient(c config) *LcmClientClient {
	return &LcmClientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lcmclient.Hooks(f(g(h())))`.
func (c *LcmClientClient) Use(hooks ...Hook) {
	c.hooks.LcmClient = append(c.hooks.LcmClient, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lcmclient.Intercept(f(g(h())))`.
func (c *LcmClientClient) Intercept(interceptors ...Interceptor) {
	c.inters.LcmClient = append(c.inters.LcmClient, interceptors...)
}

// Create returns a builder for creating a LcmClient entity.
func (c *LcmClientClient) Create() *LcmClientCreate {
	mutation := newLcmClientMutation(c.config, OpCreate)
	return &LcmClientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LcmClient entities.
func (c *LcmClientClient) CreateBulk(builders ...*LcmClientCreate) *LcmClientCreateBulk {
	return &LcmClientCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LcmClientClient) MapCreateBulk(slice any, setFunc func(*LcmClientCreate, int)) *LcmClientCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LcmClientCreateBulk{err: fmt.Errorf("calling to LcmClientClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LcmClientCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LcmClientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LcmClient.
func (c *LcmClientClient) Update() *LcmClientUpdate {
	mutation := newLcmClientMutation(c.config, OpUpdate)
	return &LcmClientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LcmClientClient) UpdateOne(_m *LcmClient) *LcmClientUpdateOne {
	mutation := newLcmClientMutation(c.config, OpUpdateOne, withLcmClient(_m))
	return &LcmClientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LcmClientClient) UpdateOneID(id uint32) *LcmClientUpdateOne {
	mutation := newLcmClientMutation(c.config, OpUpdateOne, withLcmClientID(id))
	return &LcmClientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LcmClient.
func (c *LcmClientClient) Delete() *LcmClientDelete {
	mutation := newLcmClientMutation(c.config, OpDelete)
	return &LcmClientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LcmClientClient) DeleteOne(_m *LcmClient) *LcmClientDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LcmClientClient) DeleteOneID(id uint32) *LcmClientDeleteOne {
	builder := c.Delete().Where(lcmclient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LcmClientDeleteOne{builder}
}

// Query returns a query builder for LcmClient.
func (c *LcmClientClient) Query() *LcmClientQuery {
	return &LcmClientQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLcmClient},
		inters: c.Interceptors(),
	}
}

// Get returns a LcmClient entity by its id.
func (c *LcmClientClient) Get(ctx context.Context, id uint32) (*LcmClient, error) {
	return c.Query().Where(lcmclient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LcmClientClient) GetX(ctx context.Context, id uint32) *LcmClient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMtlsCertificates queries the mtls_certificates edge of a LcmClient.
func (c *LcmClientClient) QueryMtlsCertificates(_m *LcmClient) *MtlsCertificateQuery {
	query := (&MtlsCertificateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lcmclient.Table, lcmclient.FieldID, id),
			sqlgraph.To(mtlscertificate.Table, mtlscertificate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lcmclient.MtlsCertificatesTable, lcmclient.MtlsCertificatesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMtlsCertificateRequests queries the mtls_certificate_requests edge of a LcmClient.
func (c *LcmClientClient) QueryMtlsCertificateRequests(_m *LcmClient) *MtlsCertificateRequestQuery {
	query := (&MtlsCertificateRequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lcmclient.Table, lcmclient.FieldID, id),
			sqlgraph.To(mtlscertificaterequest.Table, mtlscertificaterequest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lcmclient.MtlsCertificateRequestsTable, lcmclient.MtlsCertificateRequestsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnedIssuers queries the owned_issuers edge of a LcmClient.
func (c *LcmClientClient) QueryOwnedIssuers(_m *LcmClient) *IssuerQuery {
	query := (&IssuerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lcmclient.Table, lcmclient.FieldID, id),
			sqlgraph.To(issuer.Table, issuer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lcmclient.OwnedIssuersTable, lcmclient.OwnedIssuersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCertificateRequests queries the certificate_requests edge of a LcmClient.
func (c *LcmClientClient) QueryCertificateRequests(_m *LcmClient) *CertificateRequestQuery {
	query := (&CertificateRequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lcmclient.Table, lcmclient.FieldID, id),
			sqlgraph.To(certificaterequest.Table, certificaterequest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lcmclient.CertificateRequestsTable, lcmclient.CertificateRequestsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIssuedCertificates queries the issued_certificates edge of a LcmClient.
func (c *LcmClientClient) QueryIssuedCertificates(_m *LcmClient) *IssuedCertificateQuery {
	query := (&IssuedCertificateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lcmclient.Table, lcmclient.FieldID, id),
			sqlgraph.To(issuedcertificate.Table, issuedcertificate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lcmclient.IssuedCertificatesTable, lcmclient.IssuedCertificatesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClientIssuerAssociations queries the client_issuer_associations edge of a LcmClient.
func (c *LcmClientClient) QueryClientIssuerAssociations(_m *LcmClient) *ClientIssuerQuery {
	query := (&ClientIssuerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lcmclient.Table, lcmclient.FieldID, id),
			sqlgraph.To(clientissuer.Table, clientissuer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, lcmclient.ClientIssuerAssociationsTable, lcmclient.ClientIssuerAssociationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLcmCa queries the lcm_ca edge of a LcmClient.
func (c *LcmClientClient) QueryLcmCa(_m *LcmClient) *LcmCaQuery {
	query := (&LcmCaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lcmclient.Table, lcmclient.FieldID, id),
			sqlgraph.To(lcmca.Table, lcmca.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, lcmclient.LcmCaTable, lcmclient.LcmCaColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCertificateGrants queries the certificate_grants edge of a LcmClient.
func (c *LcmClientClient) QueryCertificateGrants(_m *LcmClient) *CertificatePermissionQuery {
	query := (&CertificatePermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lcmclient.Table, lcmclient.FieldID, id),
			sqlgraph.To(certificatepermission.Table, certificatepermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, lcmclient.CertificateGrantsTable, lcmclient.CertificateGrantsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LcmClientClient) Hooks() []Hook {
	hooks := c.hooks.LcmClient
	return append(hooks[:len(hooks):len(hooks)], lcmclient.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *LcmClientClient) Interceptors() []Interceptor {
	return c.inters.LcmClient
}

func (c *LcmClientClient) mutate(ctx context.Context, m *LcmClientMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LcmClientCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LcmClientUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LcmClientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LcmClientDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LcmClient mutation op: %q", m.Op())
	}
}

// MtlsCertificateClient is a client for the MtlsCertificate schema.
type MtlsCertificateClient struct {
	config
}

// NewMtlsCertificateClient returns a client for the MtlsCertificate from the given config.
func NewMtlsCertificateClient(c config) *MtlsCertificateClient {
	return &MtlsCertificateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mtlscertificate.Hooks(f(g(h())))`.
func (c *MtlsCertificateClient) Use(hooks ...Hook) {
	c.hooks.MtlsCertificate = append(c.hooks.MtlsCertificate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mtlscertificate.Intercept(f(g(h())))`.
func (c *MtlsCertificateClient) Intercept(interceptors ...Interceptor) {
	c.inters.MtlsCertificate = append(c.inters.MtlsCertificate, interceptors...)
}

// Create returns a builder for creating a MtlsCertificate entity.
func (c *MtlsCertificateClient) Create() *MtlsCertificateCreate {
	mutation := newMtlsCertificateMutation(c.config, OpCreate)
	return &MtlsCertificateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MtlsCertificate entities.
func (c *MtlsCertificateClient) CreateBulk(builders ...*MtlsCertificateCreate) *MtlsCertificateCreateBulk {
	return &MtlsCertificateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MtlsCertificateClient) MapCreateBulk(slice any, setFunc func(*MtlsCertificateCreate, int)) *MtlsCertificateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MtlsCertificateCreateBulk{err: fmt.Errorf("calling to MtlsCertificateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MtlsCertificateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MtlsCertificateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MtlsCertificate.
func (c *MtlsCertificateClient) Update() *MtlsCertificateUpdate {
	mutation := newMtlsCertificateMutation(c.config, OpUpdate)
	return &MtlsCertificateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MtlsCertificateClient) UpdateOne(_m *MtlsCertificate) *MtlsCertificateUpdateOne {
	mutation := newMtlsCertificateMutation(c.config, OpUpdateOne, withMtlsCertificate(_m))
	return &MtlsCertificateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MtlsCertificateClient) UpdateOneID(id uint32) *MtlsCertificateUpdateOne {
	mutation := newMtlsCertificateMutation(c.config, OpUpdateOne, withMtlsCertificateID(id))
	return &MtlsCertificateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MtlsCertificate.
func (c *MtlsCertificateClient) Delete() *MtlsCertificateDelete {
	mutation := newMtlsCertificateMutation(c.config, OpDelete)
	return &MtlsCertificateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MtlsCertificateClient) DeleteOne(_m *MtlsCertificate) *MtlsCertificateDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MtlsCertificateClient) DeleteOneID(id uint32) *MtlsCertificateDeleteOne {
	builder := c.Delete().Where(mtlscertificate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MtlsCertificateDeleteOne{builder}
}

// Query returns a query builder for MtlsCertificate.
func (c *MtlsCertificateClient) Query() *MtlsCertificateQuery {
	return &MtlsCertificateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMtlsCertificate},
		inters: c.Interceptors(),
	}
}

// Get returns a MtlsCertificate entity by its id.
func (c *MtlsCertificateClient) Get(ctx context.Context, id uint32) (*MtlsCertificate, error) {
	return c.Query().Where(mtlscertificate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MtlsCertificateClient) GetX(ctx context.Context, id uint32) *MtlsCertificate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLcmClient queries the lcm_client edge of a MtlsCertificate.
func (c *MtlsCertificateClient) QueryLcmClient(_m *MtlsCertificate) *LcmClientQuery {
	query := (&LcmClientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mtlscertificate.Table, mtlscertificate.FieldID, id),
			sqlgraph.To(lcmclient.Table, lcmclient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mtlscertificate.LcmClientTable, mtlscertificate.LcmClientColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MtlsCertificateClient) Hooks() []Hook {
	hooks := c.hooks.MtlsCertificate
	return append(hooks[:len(hooks):len(hooks)], mtlscertificate.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MtlsCertificateClient) Interceptors() []Interceptor {
	return c.inters.MtlsCertificate
}

func (c *MtlsCertificateClient) mutate(ctx context.Context, m *MtlsCertificateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MtlsCertificateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MtlsCertificateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MtlsCertificateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MtlsCertificateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MtlsCertificate mutation op: %q", m.Op())
	}
}

// MtlsCertificateRequestClient is a client for the MtlsCertificateRequest schema.
type MtlsCertificateRequestClient struct {
	config
}

// NewMtlsCertificateRequestClient returns a client for the MtlsCertificateRequest from the given config.
func NewMtlsCertificateRequestClient(c config) *MtlsCertificateRequestClient {
	return &MtlsCertificateRequestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mtlscertificaterequest.Hooks(f(g(h())))`.
func (c *MtlsCertificateRequestClient) Use(hooks ...Hook) {
	c.hooks.MtlsCertificateRequest = append(c.hooks.MtlsCertificateRequest, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mtlscertificaterequest.Intercept(f(g(h())))`.
func (c *MtlsCertificateRequestClient) Intercept(interceptors ...Interceptor) {
	c.inters.MtlsCertificateRequest = append(c.inters.MtlsCertificateRequest, interceptors...)
}

// Create returns a builder for creating a MtlsCertificateRequest entity.
func (c *MtlsCertificateRequestClient) Create() *MtlsCertificateRequestCreate {
	mutation := newMtlsCertificateRequestMutation(c.config, OpCreate)
	return &MtlsCertificateRequestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MtlsCertificateRequest entities.
func (c *MtlsCertificateRequestClient) CreateBulk(builders ...*MtlsCertificateRequestCreate) *MtlsCertificateRequestCreateBulk {
	return &MtlsCertificateRequestCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MtlsCertificateRequestClient) MapCreateBulk(slice any, setFunc func(*MtlsCertificateRequestCreate, int)) *MtlsCertificateRequestCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MtlsCertificateRequestCreateBulk{err: fmt.Errorf("calling to MtlsCertificateRequestClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MtlsCertificateRequestCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MtlsCertificateRequestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MtlsCertificateRequest.
func (c *MtlsCertificateRequestClient) Update() *MtlsCertificateRequestUpdate {
	mutation := newMtlsCertificateRequestMutation(c.config, OpUpdate)
	return &MtlsCertificateRequestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MtlsCertificateRequestClient) UpdateOne(_m *MtlsCertificateRequest) *MtlsCertificateRequestUpdateOne {
	mutation := newMtlsCertificateRequestMutation(c.config, OpUpdateOne, withMtlsCertificateRequest(_m))
	return &MtlsCertificateRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MtlsCertificateRequestClient) UpdateOneID(id uint32) *MtlsCertificateRequestUpdateOne {
	mutation := newMtlsCertificateRequestMutation(c.config, OpUpdateOne, withMtlsCertificateRequestID(id))
	return &MtlsCertificateRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MtlsCertificateRequest.
func (c *MtlsCertificateRequestClient) Delete() *MtlsCertificateRequestDelete {
	mutation := newMtlsCertificateRequestMutation(c.config, OpDelete)
	return &MtlsCertificateRequestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MtlsCertificateRequestClient) DeleteOne(_m *MtlsCertificateRequest) *MtlsCertificateRequestDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MtlsCertificateRequestClient) DeleteOneID(id uint32) *MtlsCertificateRequestDeleteOne {
	builder := c.Delete().Where(mtlscertificaterequest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MtlsCertificateRequestDeleteOne{builder}
}

// Query returns a query builder for MtlsCertificateRequest.
func (c *MtlsCertificateRequestClient) Query() *MtlsCertificateRequestQuery {
	return &MtlsCertificateRequestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMtlsCertificateRequest},
		inters: c.Interceptors(),
	}
}

// Get returns a MtlsCertificateRequest entity by its id.
func (c *MtlsCertificateRequestClient) Get(ctx context.Context, id uint32) (*MtlsCertificateRequest, error) {
	return c.Query().Where(mtlscertificaterequest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MtlsCertificateRequestClient) GetX(ctx context.Context, id uint32) *MtlsCertificateRequest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLcmClient queries the lcm_client edge of a MtlsCertificateRequest.
func (c *MtlsCertificateRequestClient) QueryLcmClient(_m *MtlsCertificateRequest) *LcmClientQuery {
	query := (&LcmClientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mtlscertificaterequest.Table, mtlscertificaterequest.FieldID, id),
			sqlgraph.To(lcmclient.Table, lcmclient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mtlscertificaterequest.LcmClientTable, mtlscertificaterequest.LcmClientColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MtlsCertificateRequestClient) Hooks() []Hook {
	hooks := c.hooks.MtlsCertificateRequest
	return append(hooks[:len(hooks):len(hooks)], mtlscertificaterequest.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MtlsCertificateRequestClient) Interceptors() []Interceptor {
	return c.inters.MtlsCertificateRequest
}

func (c *MtlsCertificateRequestClient) mutate(ctx context.Context, m *MtlsCertificateRequestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MtlsCertificateRequestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MtlsCertificateRequestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MtlsCertificateRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MtlsCertificateRequestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MtlsCertificateRequest mutation op: %q", m.Op())
	}
}

// SelfSignedIssuerClient is a client for the SelfSignedIssuer schema.
type SelfSignedIssuerClient struct {
	config
}

// NewSelfSignedIssuerClient returns a client for the SelfSignedIssuer from the given config.
func NewSelfSignedIssuerClient(c config) *SelfSignedIssuerClient {
	return &SelfSignedIssuerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `selfsignedissuer.Hooks(f(g(h())))`.
func (c *SelfSignedIssuerClient) Use(hooks ...Hook) {
	c.hooks.SelfSignedIssuer = append(c.hooks.SelfSignedIssuer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `selfsignedissuer.Intercept(f(g(h())))`.
func (c *SelfSignedIssuerClient) Intercept(interceptors ...Interceptor) {
	c.inters.SelfSignedIssuer = append(c.inters.SelfSignedIssuer, interceptors...)
}

// Create returns a builder for creating a SelfSignedIssuer entity.
func (c *SelfSignedIssuerClient) Create() *SelfSignedIssuerCreate {
	mutation := newSelfSignedIssuerMutation(c.config, OpCreate)
	return &SelfSignedIssuerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SelfSignedIssuer entities.
func (c *SelfSignedIssuerClient) CreateBulk(builders ...*SelfSignedIssuerCreate) *SelfSignedIssuerCreateBulk {
	return &SelfSignedIssuerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SelfSignedIssuerClient) MapCreateBulk(slice any, setFunc func(*SelfSignedIssuerCreate, int)) *SelfSignedIssuerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SelfSignedIssuerCreateBulk{err: fmt.Errorf("calling to SelfSignedIssuerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SelfSignedIssuerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SelfSignedIssuerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SelfSignedIssuer.
func (c *SelfSignedIssuerClient) Update() *SelfSignedIssuerUpdate {
	mutation := newSelfSignedIssuerMutation(c.config, OpUpdate)
	return &SelfSignedIssuerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SelfSignedIssuerClient) UpdateOne(_m *SelfSignedIssuer) *SelfSignedIssuerUpdateOne {
	mutation := newSelfSignedIssuerMutation(c.config, OpUpdateOne, withSelfSignedIssuer(_m))
	return &SelfSignedIssuerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SelfSignedIssuerClient) UpdateOneID(id int) *SelfSignedIssuerUpdateOne {
	mutation := newSelfSignedIssuerMutation(c.config, OpUpdateOne, withSelfSignedIssuerID(id))
	return &SelfSignedIssuerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SelfSignedIssuer.
func (c *SelfSignedIssuerClient) Delete() *SelfSignedIssuerDelete {
	mutation := newSelfSignedIssuerMutation(c.config, OpDelete)
	return &SelfSignedIssuerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SelfSignedIssuerClient) DeleteOne(_m *SelfSignedIssuer) *SelfSignedIssuerDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SelfSignedIssuerClient) DeleteOneID(id int) *SelfSignedIssuerDeleteOne {
	builder := c.Delete().Where(selfsignedissuer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SelfSignedIssuerDeleteOne{builder}
}

// Query returns a query builder for SelfSignedIssuer.
func (c *SelfSignedIssuerClient) Query() *SelfSignedIssuerQuery {
	return &SelfSignedIssuerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSelfSignedIssuer},
		inters: c.Interceptors(),
	}
}

// Get returns a SelfSignedIssuer entity by its id.
func (c *SelfSignedIssuerClient) Get(ctx context.Context, id int) (*SelfSignedIssuer, error) {
	return c.Query().Where(selfsignedissuer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SelfSignedIssuerClient) GetX(ctx context.Context, id int) *SelfSignedIssuer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIssuer queries the issuer edge of a SelfSignedIssuer.
func (c *SelfSignedIssuerClient) QueryIssuer(_m *SelfSignedIssuer) *IssuerQuery {
	query := (&IssuerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(selfsignedissuer.Table, selfsignedissuer.FieldID, id),
			sqlgraph.To(issuer.Table, issuer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, selfsignedissuer.IssuerTable, selfsignedissuer.IssuerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SelfSignedIssuerClient) Hooks() []Hook {
	return c.hooks.SelfSignedIssuer
}

// Interceptors returns the client interceptors.
func (c *SelfSignedIssuerClient) Interceptors() []Interceptor {
	return c.inters.SelfSignedIssuer
}

func (c *SelfSignedIssuerClient) mutate(ctx context.Context, m *SelfSignedIssuerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SelfSignedIssuerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SelfSignedIssuerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SelfSignedIssuerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SelfSignedIssuerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SelfSignedIssuer mutation op: %q", m.Op())
	}
}

// TenantSecretClient is a client for the TenantSecret schema.
type TenantSecretClient struct {
	config
}

// NewTenantSecretClient returns a client for the TenantSecret from the given config.
func NewTenantSecretClient(c config) *TenantSecretClient {
	return &TenantSecretClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tenantsecret.Hooks(f(g(h())))`.
func (c *TenantSecretClient) Use(hooks ...Hook) {
	c.hooks.TenantSecret = append(c.hooks.TenantSecret, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tenantsecret.Intercept(f(g(h())))`.
func (c *TenantSecretClient) Intercept(interceptors ...Interceptor) {
	c.inters.TenantSecret = append(c.inters.TenantSecret, interceptors...)
}

// Create returns a builder for creating a TenantSecret entity.
func (c *TenantSecretClient) Create() *TenantSecretCreate {
	mutation := newTenantSecretMutation(c.config, OpCreate)
	return &TenantSecretCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TenantSecret entities.
func (c *TenantSecretClient) CreateBulk(builders ...*TenantSecretCreate) *TenantSecretCreateBulk {
	return &TenantSecretCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TenantSecretClient) MapCreateBulk(slice any, setFunc func(*TenantSecretCreate, int)) *TenantSecretCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TenantSecretCreateBulk{err: fmt.Errorf("calling to TenantSecretClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TenantSecretCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TenantSecretCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TenantSecret.
func (c *TenantSecretClient) Update() *TenantSecretUpdate {
	mutation := newTenantSecretMutation(c.config, OpUpdate)
	return &TenantSecretUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TenantSecretClient) UpdateOne(_m *TenantSecret) *TenantSecretUpdateOne {
	mutation := newTenantSecretMutation(c.config, OpUpdateOne, withTenantSecret(_m))
	return &TenantSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TenantSecretClient) UpdateOneID(id uint32) *TenantSecretUpdateOne {
	mutation := newTenantSecretMutation(c.config, OpUpdateOne, withTenantSecretID(id))
	return &TenantSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TenantSecret.
func (c *TenantSecretClient) Delete() *TenantSecretDelete {
	mutation := newTenantSecretMutation(c.config, OpDelete)
	return &TenantSecretDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TenantSecretClient) DeleteOne(_m *TenantSecret) *TenantSecretDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TenantSecretClient) DeleteOneID(id uint32) *TenantSecretDeleteOne {
	builder := c.Delete().Where(tenantsecret.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TenantSecretDeleteOne{builder}
}

// Query returns a query builder for TenantSecret.
func (c *TenantSecretClient) Query() *TenantSecretQuery {
	return &TenantSecretQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTenantSecret},
		inters: c.Interceptors(),
	}
}

// Get returns a TenantSecret entity by its id.
func (c *TenantSecretClient) Get(ctx context.Context, id uint32) (*TenantSecret, error) {
	return c.Query().Where(tenantsecret.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TenantSecretClient) GetX(ctx context.Context, id uint32) *TenantSecret {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TenantSecretClient) Hooks() []Hook {
	return c.hooks.TenantSecret
}

// Interceptors returns the client interceptors.
func (c *TenantSecretClient) Interceptors() []Interceptor {
	return c.inters.TenantSecret
}

func (c *TenantSecretClient) mutate(ctx context.Context, m *TenantSecretMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TenantSecretCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TenantSecretUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TenantSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TenantSecretDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TenantSecret mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AcmeIssuer, AuditLog, CertificateDetails, CertificatePermission,
		CertificateRenewal, CertificateRequest, ClientIssuer, IssuedCertificate,
		Issuer, LcmCa, LcmClient, MtlsCertificate, MtlsCertificateRequest,
		SelfSignedIssuer, TenantSecret []ent.Hook
	}
	inters struct {
		AcmeIssuer, AuditLog, CertificateDetails, CertificatePermission,
		CertificateRenewal, CertificateRequest, ClientIssuer, IssuedCertificate,
		Issuer, LcmCa, LcmClient, MtlsCertificate, MtlsCertificateRequest,
		SelfSignedIssuer, TenantSecret []ent.Interceptor
	}
)
