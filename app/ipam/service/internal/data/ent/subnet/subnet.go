// Code generated by ent, DO NOT EDIT.

package subnet

import (
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the subnet type in the database.
	Label = "subnet"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldCreateBy holds the string denoting the create_by field in the database.
	FieldCreateBy = "create_by"
	// FieldUpdateBy holds the string denoting the update_by field in the database.
	FieldUpdateBy = "update_by"
	// FieldCreateTime holds the string denoting the create_time field in the database.
	FieldCreateTime = "create_time"
	// FieldUpdateTime holds the string denoting the update_time field in the database.
	FieldUpdateTime = "update_time"
	// FieldDeleteTime holds the string denoting the delete_time field in the database.
	FieldDeleteTime = "delete_time"
	// FieldTenantID holds the string denoting the tenant_id field in the database.
	FieldTenantID = "tenant_id"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldCidr holds the string denoting the cidr field in the database.
	FieldCidr = "cidr"
	// FieldDescription holds the string denoting the description field in the database.
	FieldDescription = "description"
	// FieldGateway holds the string denoting the gateway field in the database.
	FieldGateway = "gateway"
	// FieldDNSServers holds the string denoting the dns_servers field in the database.
	FieldDNSServers = "dns_servers"
	// FieldVlanID holds the string denoting the vlan_id field in the database.
	FieldVlanID = "vlan_id"
	// FieldParentID holds the string denoting the parent_id field in the database.
	FieldParentID = "parent_id"
	// FieldLocationID holds the string denoting the location_id field in the database.
	FieldLocationID = "location_id"
	// FieldStatus holds the string denoting the status field in the database.
	FieldStatus = "status"
	// FieldIPVersion holds the string denoting the ip_version field in the database.
	FieldIPVersion = "ip_version"
	// FieldNetworkAddress holds the string denoting the network_address field in the database.
	FieldNetworkAddress = "network_address"
	// FieldBroadcastAddress holds the string denoting the broadcast_address field in the database.
	FieldBroadcastAddress = "broadcast_address"
	// FieldMask holds the string denoting the mask field in the database.
	FieldMask = "mask"
	// FieldPrefixLength holds the string denoting the prefix_length field in the database.
	FieldPrefixLength = "prefix_length"
	// FieldTotalAddresses holds the string denoting the total_addresses field in the database.
	FieldTotalAddresses = "total_addresses"
	// FieldTags holds the string denoting the tags field in the database.
	FieldTags = "tags"
	// FieldMetadata holds the string denoting the metadata field in the database.
	FieldMetadata = "metadata"
	// EdgeAddresses holds the string denoting the addresses edge name in mutations.
	EdgeAddresses = "addresses"
	// EdgeParent holds the string denoting the parent edge name in mutations.
	EdgeParent = "parent"
	// EdgeChildren holds the string denoting the children edge name in mutations.
	EdgeChildren = "children"
	// EdgeVlan holds the string denoting the vlan edge name in mutations.
	EdgeVlan = "vlan"
	// EdgeLocation holds the string denoting the location edge name in mutations.
	EdgeLocation = "location"
	// EdgeScanJobs holds the string denoting the scan_jobs edge name in mutations.
	EdgeScanJobs = "scan_jobs"
	// Table holds the table name of the subnet in the database.
	Table = "ipam_subnets"
	// AddressesTable is the table that holds the addresses relation/edge.
	AddressesTable = "ipam_ip_addresses"
	// AddressesInverseTable is the table name for the IpAddress entity.
	// It exists in this package in order to avoid circular dependency with the "ipaddress" package.
	AddressesInverseTable = "ipam_ip_addresses"
	// AddressesColumn is the table column denoting the addresses relation/edge.
	AddressesColumn = "subnet_id"
	// ParentTable is the table that holds the parent relation/edge.
	ParentTable = "ipam_subnets"
	// ParentColumn is the table column denoting the parent relation/edge.
	ParentColumn = "parent_id"
	// ChildrenTable is the table that holds the children relation/edge.
	ChildrenTable = "ipam_subnets"
	// ChildrenColumn is the table column denoting the children relation/edge.
	ChildrenColumn = "parent_id"
	// VlanTable is the table that holds the vlan relation/edge.
	VlanTable = "ipam_subnets"
	// VlanInverseTable is the table name for the Vlan entity.
	// It exists in this package in order to avoid circular dependency with the "vlan" package.
	VlanInverseTable = "ipam_vlans"
	// VlanColumn is the table column denoting the vlan relation/edge.
	VlanColumn = "vlan_id"
	// LocationTable is the table that holds the location relation/edge.
	LocationTable = "ipam_subnets"
	// LocationInverseTable is the table name for the Location entity.
	// It exists in this package in order to avoid circular dependency with the "location" package.
	LocationInverseTable = "ipam_locations"
	// LocationColumn is the table column denoting the location relation/edge.
	LocationColumn = "location_id"
	// ScanJobsTable is the table that holds the scan_jobs relation/edge.
	ScanJobsTable = "ipam_ip_scan_jobs"
	// ScanJobsInverseTable is the table name for the IpScanJob entity.
	// It exists in this package in order to avoid circular dependency with the "ipscanjob" package.
	ScanJobsInverseTable = "ipam_ip_scan_jobs"
	// ScanJobsColumn is the table column denoting the scan_jobs relation/edge.
	ScanJobsColumn = "subnet_id"
)

// Columns holds all SQL columns for subnet fields.
var Columns = []string{
	FieldID,
	FieldCreateBy,
	FieldUpdateBy,
	FieldCreateTime,
	FieldUpdateTime,
	FieldDeleteTime,
	FieldTenantID,
	FieldName,
	FieldCidr,
	FieldDescription,
	FieldGateway,
	FieldDNSServers,
	FieldVlanID,
	FieldParentID,
	FieldLocationID,
	FieldStatus,
	FieldIPVersion,
	FieldNetworkAddress,
	FieldBroadcastAddress,
	FieldMask,
	FieldPrefixLength,
	FieldTotalAddresses,
	FieldTags,
	FieldMetadata,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// Note that the variables below are initialized by the runtime
// package on the initialization of the application. Therefore,
// it should be imported in the main as follows:
//
//	import _ "github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/runtime"
var (
	Hooks  [1]ent.Hook
	Policy ent.Policy
	// DefaultTenantID holds the default value on creation for the "tenant_id" field.
	DefaultTenantID uint32
	// NameValidator is a validator for the "name" field. It is called by the builders before save.
	NameValidator func(string) error
	// CidrValidator is a validator for the "cidr" field. It is called by the builders before save.
	CidrValidator func(string) error
	// DefaultStatus holds the default value on creation for the "status" field.
	DefaultStatus int32
	// DefaultIPVersion holds the default value on creation for the "ip_version" field.
	DefaultIPVersion int32
	// DefaultTotalAddresses holds the default value on creation for the "total_addresses" field.
	DefaultTotalAddresses int64
	// IDValidator is a validator for the "id" field. It is called by the builders before save.
	IDValidator func(string) error
)

// OrderOption defines the ordering options for the Subnet queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByCreateBy orders the results by the create_by field.
func ByCreateBy(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreateBy, opts...).ToFunc()
}

// ByUpdateBy orders the results by the update_by field.
func ByUpdateBy(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdateBy, opts...).ToFunc()
}

// ByCreateTime orders the results by the create_time field.
func ByCreateTime(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreateTime, opts...).ToFunc()
}

// ByUpdateTime orders the results by the update_time field.
func ByUpdateTime(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdateTime, opts...).ToFunc()
}

// ByDeleteTime orders the results by the delete_time field.
func ByDeleteTime(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDeleteTime, opts...).ToFunc()
}

// ByTenantID orders the results by the tenant_id field.
func ByTenantID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTenantID, opts...).ToFunc()
}

// ByName orders the results by the name field.
func ByName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldName, opts...).ToFunc()
}

// ByCidr orders the results by the cidr field.
func ByCidr(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCidr, opts...).ToFunc()
}

// ByDescription orders the results by the description field.
func ByDescription(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDescription, opts...).ToFunc()
}

// ByGateway orders the results by the gateway field.
func ByGateway(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldGateway, opts...).ToFunc()
}

// ByDNSServers orders the results by the dns_servers field.
func ByDNSServers(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDNSServers, opts...).ToFunc()
}

// ByVlanID orders the results by the vlan_id field.
func ByVlanID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldVlanID, opts...).ToFunc()
}

// ByParentID orders the results by the parent_id field.
func ByParentID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldParentID, opts...).ToFunc()
}

// ByLocationID orders the results by the location_id field.
func ByLocationID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldLocationID, opts...).ToFunc()
}

// ByStatus orders the results by the status field.
func ByStatus(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStatus, opts...).ToFunc()
}

// ByIPVersion orders the results by the ip_version field.
func ByIPVersion(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIPVersion, opts...).ToFunc()
}

// ByNetworkAddress orders the results by the network_address field.
func ByNetworkAddress(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNetworkAddress, opts...).ToFunc()
}

// ByBroadcastAddress orders the results by the broadcast_address field.
func ByBroadcastAddress(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBroadcastAddress, opts...).ToFunc()
}

// ByMask orders the results by the mask field.
func ByMask(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMask, opts...).ToFunc()
}

// ByPrefixLength orders the results by the prefix_length field.
func ByPrefixLength(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPrefixLength, opts...).ToFunc()
}

// ByTotalAddresses orders the results by the total_addresses field.
func ByTotalAddresses(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTotalAddresses, opts...).ToFunc()
}

// ByTags orders the results by the tags field.
func ByTags(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTags, opts...).ToFunc()
}

// ByMetadata orders the results by the metadata field.
func ByMetadata(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMetadata, opts...).ToFunc()
}

// ByAddressesCount orders the results by addresses count.
func ByAddressesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAddressesStep(), opts...)
	}
}

// ByAddresses orders the results by addresses terms.
func ByAddresses(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAddressesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByParentField orders the results by parent field.
func ByParentField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newParentStep(), sql.OrderByField(field, opts...))
	}
}

// ByChildrenCount orders the results by children count.
func ByChildrenCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newChildrenStep(), opts...)
	}
}

// ByChildren orders the results by children terms.
func ByChildren(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newChildrenStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByVlanField orders the results by vlan field.
func ByVlanField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newVlanStep(), sql.OrderByField(field, opts...))
	}
}

// ByLocationField orders the results by location field.
func ByLocationField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newLocationStep(), sql.OrderByField(field, opts...))
	}
}

// ByScanJobsCount orders the results by scan_jobs count.
func ByScanJobsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newScanJobsStep(), opts...)
	}
}

// ByScanJobs orders the results by scan_jobs terms.
func ByScanJobs(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newScanJobsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newAddressesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AddressesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, AddressesTable, AddressesColumn),
	)
}
func newParentStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(Table, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, ParentTable, ParentColumn),
	)
}
func newChildrenStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(Table, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, ChildrenTable, ChildrenColumn),
	)
}
func newVlanStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(VlanInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, VlanTable, VlanColumn),
	)
}
func newLocationStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(LocationInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, LocationTable, LocationColumn),
	)
}
func newScanJobsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ScanJobsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, ScanJobsTable, ScanJobsColumn),
	)
}
