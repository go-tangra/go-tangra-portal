// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/auditlog"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/device"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/deviceinterface"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/dnsconfig"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/hostgroup"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/hostgroupmember"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/ipaddress"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/ipgroup"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/ipgroupmember"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/ipscanjob"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/location"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/predicate"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/subnet"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/vlan"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuditLog        = "AuditLog"
	TypeDevice          = "Device"
	TypeDeviceInterface = "DeviceInterface"
	TypeDnsConfig       = "DnsConfig"
	TypeHostGroup       = "HostGroup"
	TypeHostGroupMember = "HostGroupMember"
	TypeIpAddress       = "IpAddress"
	TypeIpGroup         = "IpGroup"
	TypeIpGroupMember   = "IpGroupMember"
	TypeIpScanJob       = "IpScanJob"
	TypeLocation        = "Location"
	TypeSubnet          = "Subnet"
	TypeVlan            = "Vlan"
)

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	create_time          *time.Time
	update_time          *time.Time
	delete_time          *time.Time
	tenant_id            *uint32
	addtenant_id         *int32
	audit_id             *string
	request_id           *string
	operation            *string
	service_name         *string
	client_id            *string
	client_common_name   *string
	client_organization  *string
	client_serial_number *string
	is_authenticated     *bool
	success              *bool
	error_code           *int32
	adderror_code        *int32
	error_message        *string
	latency_ms           *int64
	addlatency_ms        *int64
	peer_address         *string
	geo_location         *map[string]string
	log_hash             *string
	signature            *[]byte
	metadata             *map[string]string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*AuditLog, error)
	predicates           []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id uint32) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditLog entities.
func (m *AuditLogMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AuditLogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AuditLogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AuditLogMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[auditlog.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AuditLogMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AuditLogMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, auditlog.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AuditLogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AuditLogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AuditLogMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[auditlog.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AuditLogMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AuditLogMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, auditlog.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *AuditLogMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *AuditLogMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *AuditLogMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[auditlog.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *AuditLogMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *AuditLogMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, auditlog.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *AuditLogMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AuditLogMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *AuditLogMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *AuditLogMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[auditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, auditlog.FieldTenantID)
}

// SetAuditID sets the "audit_id" field.
func (m *AuditLogMutation) SetAuditID(s string) {
	m.audit_id = &s
}

// AuditID returns the value of the "audit_id" field in the mutation.
func (m *AuditLogMutation) AuditID() (r string, exists bool) {
	v := m.audit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditID returns the old "audit_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAuditID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditID: %w", err)
	}
	return oldValue.AuditID, nil
}

// ResetAuditID resets all changes to the "audit_id" field.
func (m *AuditLogMutation) ResetAuditID() {
	m.audit_id = nil
}

// SetRequestID sets the "request_id" field.
func (m *AuditLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *AuditLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *AuditLogMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[auditlog.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *AuditLogMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *AuditLogMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, auditlog.FieldRequestID)
}

// SetOperation sets the "operation" field.
func (m *AuditLogMutation) SetOperation(s string) {
	m.operation = &s
}

// Operation returns the value of the "operation" field in the mutation.
func (m *AuditLogMutation) Operation() (r string, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldOperation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *AuditLogMutation) ResetOperation() {
	m.operation = nil
}

// SetServiceName sets the "service_name" field.
func (m *AuditLogMutation) SetServiceName(s string) {
	m.service_name = &s
}

// ServiceName returns the value of the "service_name" field in the mutation.
func (m *AuditLogMutation) ServiceName() (r string, exists bool) {
	v := m.service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceName returns the old "service_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldServiceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceName: %w", err)
	}
	return oldValue.ServiceName, nil
}

// ResetServiceName resets all changes to the "service_name" field.
func (m *AuditLogMutation) ResetServiceName() {
	m.service_name = nil
}

// SetClientID sets the "client_id" field.
func (m *AuditLogMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AuditLogMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *AuditLogMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[auditlog.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *AuditLogMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AuditLogMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, auditlog.FieldClientID)
}

// SetClientCommonName sets the "client_common_name" field.
func (m *AuditLogMutation) SetClientCommonName(s string) {
	m.client_common_name = &s
}

// ClientCommonName returns the value of the "client_common_name" field in the mutation.
func (m *AuditLogMutation) ClientCommonName() (r string, exists bool) {
	v := m.client_common_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientCommonName returns the old "client_common_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientCommonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientCommonName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientCommonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientCommonName: %w", err)
	}
	return oldValue.ClientCommonName, nil
}

// ClearClientCommonName clears the value of the "client_common_name" field.
func (m *AuditLogMutation) ClearClientCommonName() {
	m.client_common_name = nil
	m.clearedFields[auditlog.FieldClientCommonName] = struct{}{}
}

// ClientCommonNameCleared returns if the "client_common_name" field was cleared in this mutation.
func (m *AuditLogMutation) ClientCommonNameCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientCommonName]
	return ok
}

// ResetClientCommonName resets all changes to the "client_common_name" field.
func (m *AuditLogMutation) ResetClientCommonName() {
	m.client_common_name = nil
	delete(m.clearedFields, auditlog.FieldClientCommonName)
}

// SetClientOrganization sets the "client_organization" field.
func (m *AuditLogMutation) SetClientOrganization(s string) {
	m.client_organization = &s
}

// ClientOrganization returns the value of the "client_organization" field in the mutation.
func (m *AuditLogMutation) ClientOrganization() (r string, exists bool) {
	v := m.client_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldClientOrganization returns the old "client_organization" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientOrganization: %w", err)
	}
	return oldValue.ClientOrganization, nil
}

// ClearClientOrganization clears the value of the "client_organization" field.
func (m *AuditLogMutation) ClearClientOrganization() {
	m.client_organization = nil
	m.clearedFields[auditlog.FieldClientOrganization] = struct{}{}
}

// ClientOrganizationCleared returns if the "client_organization" field was cleared in this mutation.
func (m *AuditLogMutation) ClientOrganizationCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientOrganization]
	return ok
}

// ResetClientOrganization resets all changes to the "client_organization" field.
func (m *AuditLogMutation) ResetClientOrganization() {
	m.client_organization = nil
	delete(m.clearedFields, auditlog.FieldClientOrganization)
}

// SetClientSerialNumber sets the "client_serial_number" field.
func (m *AuditLogMutation) SetClientSerialNumber(s string) {
	m.client_serial_number = &s
}

// ClientSerialNumber returns the value of the "client_serial_number" field in the mutation.
func (m *AuditLogMutation) ClientSerialNumber() (r string, exists bool) {
	v := m.client_serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSerialNumber returns the old "client_serial_number" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSerialNumber: %w", err)
	}
	return oldValue.ClientSerialNumber, nil
}

// ClearClientSerialNumber clears the value of the "client_serial_number" field.
func (m *AuditLogMutation) ClearClientSerialNumber() {
	m.client_serial_number = nil
	m.clearedFields[auditlog.FieldClientSerialNumber] = struct{}{}
}

// ClientSerialNumberCleared returns if the "client_serial_number" field was cleared in this mutation.
func (m *AuditLogMutation) ClientSerialNumberCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientSerialNumber]
	return ok
}

// ResetClientSerialNumber resets all changes to the "client_serial_number" field.
func (m *AuditLogMutation) ResetClientSerialNumber() {
	m.client_serial_number = nil
	delete(m.clearedFields, auditlog.FieldClientSerialNumber)
}

// SetIsAuthenticated sets the "is_authenticated" field.
func (m *AuditLogMutation) SetIsAuthenticated(b bool) {
	m.is_authenticated = &b
}

// IsAuthenticated returns the value of the "is_authenticated" field in the mutation.
func (m *AuditLogMutation) IsAuthenticated() (r bool, exists bool) {
	v := m.is_authenticated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAuthenticated returns the old "is_authenticated" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIsAuthenticated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAuthenticated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAuthenticated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAuthenticated: %w", err)
	}
	return oldValue.IsAuthenticated, nil
}

// ResetIsAuthenticated resets all changes to the "is_authenticated" field.
func (m *AuditLogMutation) ResetIsAuthenticated() {
	m.is_authenticated = nil
}

// SetSuccess sets the "success" field.
func (m *AuditLogMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *AuditLogMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *AuditLogMutation) ResetSuccess() {
	m.success = nil
}

// SetErrorCode sets the "error_code" field.
func (m *AuditLogMutation) SetErrorCode(i int32) {
	m.error_code = &i
	m.adderror_code = nil
}

// ErrorCode returns the value of the "error_code" field in the mutation.
func (m *AuditLogMutation) ErrorCode() (r int32, exists bool) {
	v := m.error_code
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "error_code" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorCode(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// AddErrorCode adds i to the "error_code" field.
func (m *AuditLogMutation) AddErrorCode(i int32) {
	if m.adderror_code != nil {
		*m.adderror_code += i
	} else {
		m.adderror_code = &i
	}
}

// AddedErrorCode returns the value that was added to the "error_code" field in this mutation.
func (m *AuditLogMutation) AddedErrorCode() (r int32, exists bool) {
	v := m.adderror_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearErrorCode clears the value of the "error_code" field.
func (m *AuditLogMutation) ClearErrorCode() {
	m.error_code = nil
	m.adderror_code = nil
	m.clearedFields[auditlog.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "error_code" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "error_code" field.
func (m *AuditLogMutation) ResetErrorCode() {
	m.error_code = nil
	m.adderror_code = nil
	delete(m.clearedFields, auditlog.FieldErrorCode)
}

// SetErrorMessage sets the "error_message" field.
func (m *AuditLogMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AuditLogMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AuditLogMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[auditlog.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AuditLogMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, auditlog.FieldErrorMessage)
}

// SetLatencyMs sets the "latency_ms" field.
func (m *AuditLogMutation) SetLatencyMs(i int64) {
	m.latency_ms = &i
	m.addlatency_ms = nil
}

// LatencyMs returns the value of the "latency_ms" field in the mutation.
func (m *AuditLogMutation) LatencyMs() (r int64, exists bool) {
	v := m.latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldLatencyMs returns the old "latency_ms" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldLatencyMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatencyMs: %w", err)
	}
	return oldValue.LatencyMs, nil
}

// AddLatencyMs adds i to the "latency_ms" field.
func (m *AuditLogMutation) AddLatencyMs(i int64) {
	if m.addlatency_ms != nil {
		*m.addlatency_ms += i
	} else {
		m.addlatency_ms = &i
	}
}

// AddedLatencyMs returns the value that was added to the "latency_ms" field in this mutation.
func (m *AuditLogMutation) AddedLatencyMs() (r int64, exists bool) {
	v := m.addlatency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatencyMs resets all changes to the "latency_ms" field.
func (m *AuditLogMutation) ResetLatencyMs() {
	m.latency_ms = nil
	m.addlatency_ms = nil
}

// SetPeerAddress sets the "peer_address" field.
func (m *AuditLogMutation) SetPeerAddress(s string) {
	m.peer_address = &s
}

// PeerAddress returns the value of the "peer_address" field in the mutation.
func (m *AuditLogMutation) PeerAddress() (r string, exists bool) {
	v := m.peer_address
	if v == nil {
		return
	}
	return *v, true
}

// OldPeerAddress returns the old "peer_address" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldPeerAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeerAddress: %w", err)
	}
	return oldValue.PeerAddress, nil
}

// ClearPeerAddress clears the value of the "peer_address" field.
func (m *AuditLogMutation) ClearPeerAddress() {
	m.peer_address = nil
	m.clearedFields[auditlog.FieldPeerAddress] = struct{}{}
}

// PeerAddressCleared returns if the "peer_address" field was cleared in this mutation.
func (m *AuditLogMutation) PeerAddressCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldPeerAddress]
	return ok
}

// ResetPeerAddress resets all changes to the "peer_address" field.
func (m *AuditLogMutation) ResetPeerAddress() {
	m.peer_address = nil
	delete(m.clearedFields, auditlog.FieldPeerAddress)
}

// SetGeoLocation sets the "geo_location" field.
func (m *AuditLogMutation) SetGeoLocation(value map[string]string) {
	m.geo_location = &value
}

// GeoLocation returns the value of the "geo_location" field in the mutation.
func (m *AuditLogMutation) GeoLocation() (r map[string]string, exists bool) {
	v := m.geo_location
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoLocation returns the old "geo_location" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldGeoLocation(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoLocation: %w", err)
	}
	return oldValue.GeoLocation, nil
}

// ClearGeoLocation clears the value of the "geo_location" field.
func (m *AuditLogMutation) ClearGeoLocation() {
	m.geo_location = nil
	m.clearedFields[auditlog.FieldGeoLocation] = struct{}{}
}

// GeoLocationCleared returns if the "geo_location" field was cleared in this mutation.
func (m *AuditLogMutation) GeoLocationCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldGeoLocation]
	return ok
}

// ResetGeoLocation resets all changes to the "geo_location" field.
func (m *AuditLogMutation) ResetGeoLocation() {
	m.geo_location = nil
	delete(m.clearedFields, auditlog.FieldGeoLocation)
}

// SetLogHash sets the "log_hash" field.
func (m *AuditLogMutation) SetLogHash(s string) {
	m.log_hash = &s
}

// LogHash returns the value of the "log_hash" field in the mutation.
func (m *AuditLogMutation) LogHash() (r string, exists bool) {
	v := m.log_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldLogHash returns the old "log_hash" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldLogHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogHash: %w", err)
	}
	return oldValue.LogHash, nil
}

// ClearLogHash clears the value of the "log_hash" field.
func (m *AuditLogMutation) ClearLogHash() {
	m.log_hash = nil
	m.clearedFields[auditlog.FieldLogHash] = struct{}{}
}

// LogHashCleared returns if the "log_hash" field was cleared in this mutation.
func (m *AuditLogMutation) LogHashCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldLogHash]
	return ok
}

// ResetLogHash resets all changes to the "log_hash" field.
func (m *AuditLogMutation) ResetLogHash() {
	m.log_hash = nil
	delete(m.clearedFields, auditlog.FieldLogHash)
}

// SetSignature sets the "signature" field.
func (m *AuditLogMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *AuditLogMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *AuditLogMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[auditlog.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *AuditLogMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *AuditLogMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, auditlog.FieldSignature)
}

// SetMetadata sets the "metadata" field.
func (m *AuditLogMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuditLogMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AuditLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[auditlog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AuditLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuditLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, auditlog.FieldMetadata)
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.create_time != nil {
		fields = append(fields, auditlog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, auditlog.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, auditlog.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.audit_id != nil {
		fields = append(fields, auditlog.FieldAuditID)
	}
	if m.request_id != nil {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.operation != nil {
		fields = append(fields, auditlog.FieldOperation)
	}
	if m.service_name != nil {
		fields = append(fields, auditlog.FieldServiceName)
	}
	if m.client_id != nil {
		fields = append(fields, auditlog.FieldClientID)
	}
	if m.client_common_name != nil {
		fields = append(fields, auditlog.FieldClientCommonName)
	}
	if m.client_organization != nil {
		fields = append(fields, auditlog.FieldClientOrganization)
	}
	if m.client_serial_number != nil {
		fields = append(fields, auditlog.FieldClientSerialNumber)
	}
	if m.is_authenticated != nil {
		fields = append(fields, auditlog.FieldIsAuthenticated)
	}
	if m.success != nil {
		fields = append(fields, auditlog.FieldSuccess)
	}
	if m.error_code != nil {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.error_message != nil {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.latency_ms != nil {
		fields = append(fields, auditlog.FieldLatencyMs)
	}
	if m.peer_address != nil {
		fields = append(fields, auditlog.FieldPeerAddress)
	}
	if m.geo_location != nil {
		fields = append(fields, auditlog.FieldGeoLocation)
	}
	if m.log_hash != nil {
		fields = append(fields, auditlog.FieldLogHash)
	}
	if m.signature != nil {
		fields = append(fields, auditlog.FieldSignature)
	}
	if m.metadata != nil {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldCreateTime:
		return m.CreateTime()
	case auditlog.FieldUpdateTime:
		return m.UpdateTime()
	case auditlog.FieldDeleteTime:
		return m.DeleteTime()
	case auditlog.FieldTenantID:
		return m.TenantID()
	case auditlog.FieldAuditID:
		return m.AuditID()
	case auditlog.FieldRequestID:
		return m.RequestID()
	case auditlog.FieldOperation:
		return m.Operation()
	case auditlog.FieldServiceName:
		return m.ServiceName()
	case auditlog.FieldClientID:
		return m.ClientID()
	case auditlog.FieldClientCommonName:
		return m.ClientCommonName()
	case auditlog.FieldClientOrganization:
		return m.ClientOrganization()
	case auditlog.FieldClientSerialNumber:
		return m.ClientSerialNumber()
	case auditlog.FieldIsAuthenticated:
		return m.IsAuthenticated()
	case auditlog.FieldSuccess:
		return m.Success()
	case auditlog.FieldErrorCode:
		return m.ErrorCode()
	case auditlog.FieldErrorMessage:
		return m.ErrorMessage()
	case auditlog.FieldLatencyMs:
		return m.LatencyMs()
	case auditlog.FieldPeerAddress:
		return m.PeerAddress()
	case auditlog.FieldGeoLocation:
		return m.GeoLocation()
	case auditlog.FieldLogHash:
		return m.LogHash()
	case auditlog.FieldSignature:
		return m.Signature()
	case auditlog.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case auditlog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case auditlog.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case auditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case auditlog.FieldAuditID:
		return m.OldAuditID(ctx)
	case auditlog.FieldRequestID:
		return m.OldRequestID(ctx)
	case auditlog.FieldOperation:
		return m.OldOperation(ctx)
	case auditlog.FieldServiceName:
		return m.OldServiceName(ctx)
	case auditlog.FieldClientID:
		return m.OldClientID(ctx)
	case auditlog.FieldClientCommonName:
		return m.OldClientCommonName(ctx)
	case auditlog.FieldClientOrganization:
		return m.OldClientOrganization(ctx)
	case auditlog.FieldClientSerialNumber:
		return m.OldClientSerialNumber(ctx)
	case auditlog.FieldIsAuthenticated:
		return m.OldIsAuthenticated(ctx)
	case auditlog.FieldSuccess:
		return m.OldSuccess(ctx)
	case auditlog.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case auditlog.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case auditlog.FieldLatencyMs:
		return m.OldLatencyMs(ctx)
	case auditlog.FieldPeerAddress:
		return m.OldPeerAddress(ctx)
	case auditlog.FieldGeoLocation:
		return m.OldGeoLocation(ctx)
	case auditlog.FieldLogHash:
		return m.OldLogHash(ctx)
	case auditlog.FieldSignature:
		return m.OldSignature(ctx)
	case auditlog.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case auditlog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case auditlog.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case auditlog.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case auditlog.FieldAuditID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditID(v)
		return nil
	case auditlog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case auditlog.FieldOperation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case auditlog.FieldServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceName(v)
		return nil
	case auditlog.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case auditlog.FieldClientCommonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientCommonName(v)
		return nil
	case auditlog.FieldClientOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientOrganization(v)
		return nil
	case auditlog.FieldClientSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSerialNumber(v)
		return nil
	case auditlog.FieldIsAuthenticated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAuthenticated(v)
		return nil
	case auditlog.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case auditlog.FieldErrorCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case auditlog.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case auditlog.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatencyMs(v)
		return nil
	case auditlog.FieldPeerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeerAddress(v)
		return nil
	case auditlog.FieldGeoLocation:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoLocation(v)
		return nil
	case auditlog.FieldLogHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogHash(v)
		return nil
	case auditlog.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case auditlog.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.adderror_code != nil {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.addlatency_ms != nil {
		fields = append(fields, auditlog.FieldLatencyMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldTenantID:
		return m.AddedTenantID()
	case auditlog.FieldErrorCode:
		return m.AddedErrorCode()
	case auditlog.FieldLatencyMs:
		return m.AddedLatencyMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case auditlog.FieldErrorCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrorCode(v)
		return nil
	case auditlog.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldCreateTime) {
		fields = append(fields, auditlog.FieldCreateTime)
	}
	if m.FieldCleared(auditlog.FieldUpdateTime) {
		fields = append(fields, auditlog.FieldUpdateTime)
	}
	if m.FieldCleared(auditlog.FieldDeleteTime) {
		fields = append(fields, auditlog.FieldDeleteTime)
	}
	if m.FieldCleared(auditlog.FieldTenantID) {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.FieldCleared(auditlog.FieldRequestID) {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.FieldCleared(auditlog.FieldClientID) {
		fields = append(fields, auditlog.FieldClientID)
	}
	if m.FieldCleared(auditlog.FieldClientCommonName) {
		fields = append(fields, auditlog.FieldClientCommonName)
	}
	if m.FieldCleared(auditlog.FieldClientOrganization) {
		fields = append(fields, auditlog.FieldClientOrganization)
	}
	if m.FieldCleared(auditlog.FieldClientSerialNumber) {
		fields = append(fields, auditlog.FieldClientSerialNumber)
	}
	if m.FieldCleared(auditlog.FieldErrorCode) {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.FieldCleared(auditlog.FieldErrorMessage) {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.FieldCleared(auditlog.FieldPeerAddress) {
		fields = append(fields, auditlog.FieldPeerAddress)
	}
	if m.FieldCleared(auditlog.FieldGeoLocation) {
		fields = append(fields, auditlog.FieldGeoLocation)
	}
	if m.FieldCleared(auditlog.FieldLogHash) {
		fields = append(fields, auditlog.FieldLogHash)
	}
	if m.FieldCleared(auditlog.FieldSignature) {
		fields = append(fields, auditlog.FieldSignature)
	}
	if m.FieldCleared(auditlog.FieldMetadata) {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case auditlog.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case auditlog.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case auditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case auditlog.FieldRequestID:
		m.ClearRequestID()
		return nil
	case auditlog.FieldClientID:
		m.ClearClientID()
		return nil
	case auditlog.FieldClientCommonName:
		m.ClearClientCommonName()
		return nil
	case auditlog.FieldClientOrganization:
		m.ClearClientOrganization()
		return nil
	case auditlog.FieldClientSerialNumber:
		m.ClearClientSerialNumber()
		return nil
	case auditlog.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	case auditlog.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case auditlog.FieldPeerAddress:
		m.ClearPeerAddress()
		return nil
	case auditlog.FieldGeoLocation:
		m.ClearGeoLocation()
		return nil
	case auditlog.FieldLogHash:
		m.ClearLogHash()
		return nil
	case auditlog.FieldSignature:
		m.ClearSignature()
		return nil
	case auditlog.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case auditlog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case auditlog.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case auditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case auditlog.FieldAuditID:
		m.ResetAuditID()
		return nil
	case auditlog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case auditlog.FieldOperation:
		m.ResetOperation()
		return nil
	case auditlog.FieldServiceName:
		m.ResetServiceName()
		return nil
	case auditlog.FieldClientID:
		m.ResetClientID()
		return nil
	case auditlog.FieldClientCommonName:
		m.ResetClientCommonName()
		return nil
	case auditlog.FieldClientOrganization:
		m.ResetClientOrganization()
		return nil
	case auditlog.FieldClientSerialNumber:
		m.ResetClientSerialNumber()
		return nil
	case auditlog.FieldIsAuthenticated:
		m.ResetIsAuthenticated()
		return nil
	case auditlog.FieldSuccess:
		m.ResetSuccess()
		return nil
	case auditlog.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case auditlog.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case auditlog.FieldLatencyMs:
		m.ResetLatencyMs()
		return nil
	case auditlog.FieldPeerAddress:
		m.ResetPeerAddress()
		return nil
	case auditlog.FieldGeoLocation:
		m.ResetGeoLocation()
		return nil
	case auditlog.FieldLogHash:
		m.ResetLogHash()
		return nil
	case auditlog.FieldSignature:
		m.ResetSignature()
		return nil
	case auditlog.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	create_by          *uint32
	addcreate_by       *int32
	update_by          *uint32
	addupdate_by       *int32
	create_time        *time.Time
	update_time        *time.Time
	delete_time        *time.Time
	tenant_id          *uint32
	addtenant_id       *int32
	name               *string
	device_type        *int32
	adddevice_type     *int32
	description        *string
	manufacturer       *string
	model              *string
	serial_number      *string
	asset_tag          *string
	rack_id            *string
	rack_position      *int32
	addrack_position   *int32
	device_height_u    *int32
	adddevice_height_u *int32
	status             *int32
	addstatus          *int32
	primary_ip         *string
	primary_ipv6       *string
	management_ip      *string
	os_type            *string
	os_version         *string
	firmware_version   *string
	contact            *string
	tags               *string
	metadata           *string
	notes              *string
	last_seen          *time.Time
	clearedFields      map[string]struct{}
	addresses          map[string]struct{}
	removedaddresses   map[string]struct{}
	clearedaddresses   bool
	interfaces         map[string]struct{}
	removedinterfaces  map[string]struct{}
	clearedinterfaces  bool
	location           *string
	clearedlocation    bool
	done               bool
	oldValue           func(context.Context) (*Device, error)
	predicates         []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id string) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Device entities.
func (m *DeviceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Device.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *DeviceMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *DeviceMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *DeviceMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *DeviceMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *DeviceMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[device.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *DeviceMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[device.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *DeviceMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, device.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *DeviceMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *DeviceMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *DeviceMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *DeviceMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *DeviceMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[device.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *DeviceMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[device.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *DeviceMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, device.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *DeviceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DeviceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *DeviceMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[device.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *DeviceMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[device.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DeviceMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, device.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *DeviceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DeviceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *DeviceMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[device.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *DeviceMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[device.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DeviceMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, device.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *DeviceMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *DeviceMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *DeviceMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[device.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *DeviceMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[device.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *DeviceMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, device.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *DeviceMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeviceMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *DeviceMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DeviceMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *DeviceMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[device.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *DeviceMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[device.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeviceMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, device.FieldTenantID)
}

// SetName sets the "name" field.
func (m *DeviceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeviceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeviceMutation) ResetName() {
	m.name = nil
}

// SetDeviceType sets the "device_type" field.
func (m *DeviceMutation) SetDeviceType(i int32) {
	m.device_type = &i
	m.adddevice_type = nil
}

// DeviceType returns the value of the "device_type" field in the mutation.
func (m *DeviceMutation) DeviceType() (r int32, exists bool) {
	v := m.device_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceType returns the old "device_type" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceType: %w", err)
	}
	return oldValue.DeviceType, nil
}

// AddDeviceType adds i to the "device_type" field.
func (m *DeviceMutation) AddDeviceType(i int32) {
	if m.adddevice_type != nil {
		*m.adddevice_type += i
	} else {
		m.adddevice_type = &i
	}
}

// AddedDeviceType returns the value that was added to the "device_type" field in this mutation.
func (m *DeviceMutation) AddedDeviceType() (r int32, exists bool) {
	v := m.adddevice_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceType resets all changes to the "device_type" field.
func (m *DeviceMutation) ResetDeviceType() {
	m.device_type = nil
	m.adddevice_type = nil
}

// SetDescription sets the "description" field.
func (m *DeviceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DeviceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DeviceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[device.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DeviceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[device.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DeviceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, device.FieldDescription)
}

// SetManufacturer sets the "manufacturer" field.
func (m *DeviceMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *DeviceMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ClearManufacturer clears the value of the "manufacturer" field.
func (m *DeviceMutation) ClearManufacturer() {
	m.manufacturer = nil
	m.clearedFields[device.FieldManufacturer] = struct{}{}
}

// ManufacturerCleared returns if the "manufacturer" field was cleared in this mutation.
func (m *DeviceMutation) ManufacturerCleared() bool {
	_, ok := m.clearedFields[device.FieldManufacturer]
	return ok
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *DeviceMutation) ResetManufacturer() {
	m.manufacturer = nil
	delete(m.clearedFields, device.FieldManufacturer)
}

// SetModel sets the "model" field.
func (m *DeviceMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *DeviceMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *DeviceMutation) ClearModel() {
	m.model = nil
	m.clearedFields[device.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *DeviceMutation) ModelCleared() bool {
	_, ok := m.clearedFields[device.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *DeviceMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, device.FieldModel)
}

// SetSerialNumber sets the "serial_number" field.
func (m *DeviceMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *DeviceMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ClearSerialNumber clears the value of the "serial_number" field.
func (m *DeviceMutation) ClearSerialNumber() {
	m.serial_number = nil
	m.clearedFields[device.FieldSerialNumber] = struct{}{}
}

// SerialNumberCleared returns if the "serial_number" field was cleared in this mutation.
func (m *DeviceMutation) SerialNumberCleared() bool {
	_, ok := m.clearedFields[device.FieldSerialNumber]
	return ok
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *DeviceMutation) ResetSerialNumber() {
	m.serial_number = nil
	delete(m.clearedFields, device.FieldSerialNumber)
}

// SetAssetTag sets the "asset_tag" field.
func (m *DeviceMutation) SetAssetTag(s string) {
	m.asset_tag = &s
}

// AssetTag returns the value of the "asset_tag" field in the mutation.
func (m *DeviceMutation) AssetTag() (r string, exists bool) {
	v := m.asset_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetTag returns the old "asset_tag" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldAssetTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetTag: %w", err)
	}
	return oldValue.AssetTag, nil
}

// ClearAssetTag clears the value of the "asset_tag" field.
func (m *DeviceMutation) ClearAssetTag() {
	m.asset_tag = nil
	m.clearedFields[device.FieldAssetTag] = struct{}{}
}

// AssetTagCleared returns if the "asset_tag" field was cleared in this mutation.
func (m *DeviceMutation) AssetTagCleared() bool {
	_, ok := m.clearedFields[device.FieldAssetTag]
	return ok
}

// ResetAssetTag resets all changes to the "asset_tag" field.
func (m *DeviceMutation) ResetAssetTag() {
	m.asset_tag = nil
	delete(m.clearedFields, device.FieldAssetTag)
}

// SetLocationID sets the "location_id" field.
func (m *DeviceMutation) SetLocationID(s string) {
	m.location = &s
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *DeviceMutation) LocationID() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldLocationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ClearLocationID clears the value of the "location_id" field.
func (m *DeviceMutation) ClearLocationID() {
	m.location = nil
	m.clearedFields[device.FieldLocationID] = struct{}{}
}

// LocationIDCleared returns if the "location_id" field was cleared in this mutation.
func (m *DeviceMutation) LocationIDCleared() bool {
	_, ok := m.clearedFields[device.FieldLocationID]
	return ok
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *DeviceMutation) ResetLocationID() {
	m.location = nil
	delete(m.clearedFields, device.FieldLocationID)
}

// SetRackID sets the "rack_id" field.
func (m *DeviceMutation) SetRackID(s string) {
	m.rack_id = &s
}

// RackID returns the value of the "rack_id" field in the mutation.
func (m *DeviceMutation) RackID() (r string, exists bool) {
	v := m.rack_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRackID returns the old "rack_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldRackID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRackID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRackID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRackID: %w", err)
	}
	return oldValue.RackID, nil
}

// ClearRackID clears the value of the "rack_id" field.
func (m *DeviceMutation) ClearRackID() {
	m.rack_id = nil
	m.clearedFields[device.FieldRackID] = struct{}{}
}

// RackIDCleared returns if the "rack_id" field was cleared in this mutation.
func (m *DeviceMutation) RackIDCleared() bool {
	_, ok := m.clearedFields[device.FieldRackID]
	return ok
}

// ResetRackID resets all changes to the "rack_id" field.
func (m *DeviceMutation) ResetRackID() {
	m.rack_id = nil
	delete(m.clearedFields, device.FieldRackID)
}

// SetRackPosition sets the "rack_position" field.
func (m *DeviceMutation) SetRackPosition(i int32) {
	m.rack_position = &i
	m.addrack_position = nil
}

// RackPosition returns the value of the "rack_position" field in the mutation.
func (m *DeviceMutation) RackPosition() (r int32, exists bool) {
	v := m.rack_position
	if v == nil {
		return
	}
	return *v, true
}

// OldRackPosition returns the old "rack_position" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldRackPosition(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRackPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRackPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRackPosition: %w", err)
	}
	return oldValue.RackPosition, nil
}

// AddRackPosition adds i to the "rack_position" field.
func (m *DeviceMutation) AddRackPosition(i int32) {
	if m.addrack_position != nil {
		*m.addrack_position += i
	} else {
		m.addrack_position = &i
	}
}

// AddedRackPosition returns the value that was added to the "rack_position" field in this mutation.
func (m *DeviceMutation) AddedRackPosition() (r int32, exists bool) {
	v := m.addrack_position
	if v == nil {
		return
	}
	return *v, true
}

// ClearRackPosition clears the value of the "rack_position" field.
func (m *DeviceMutation) ClearRackPosition() {
	m.rack_position = nil
	m.addrack_position = nil
	m.clearedFields[device.FieldRackPosition] = struct{}{}
}

// RackPositionCleared returns if the "rack_position" field was cleared in this mutation.
func (m *DeviceMutation) RackPositionCleared() bool {
	_, ok := m.clearedFields[device.FieldRackPosition]
	return ok
}

// ResetRackPosition resets all changes to the "rack_position" field.
func (m *DeviceMutation) ResetRackPosition() {
	m.rack_position = nil
	m.addrack_position = nil
	delete(m.clearedFields, device.FieldRackPosition)
}

// SetDeviceHeightU sets the "device_height_u" field.
func (m *DeviceMutation) SetDeviceHeightU(i int32) {
	m.device_height_u = &i
	m.adddevice_height_u = nil
}

// DeviceHeightU returns the value of the "device_height_u" field in the mutation.
func (m *DeviceMutation) DeviceHeightU() (r int32, exists bool) {
	v := m.device_height_u
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceHeightU returns the old "device_height_u" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceHeightU(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceHeightU is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceHeightU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceHeightU: %w", err)
	}
	return oldValue.DeviceHeightU, nil
}

// AddDeviceHeightU adds i to the "device_height_u" field.
func (m *DeviceMutation) AddDeviceHeightU(i int32) {
	if m.adddevice_height_u != nil {
		*m.adddevice_height_u += i
	} else {
		m.adddevice_height_u = &i
	}
}

// AddedDeviceHeightU returns the value that was added to the "device_height_u" field in this mutation.
func (m *DeviceMutation) AddedDeviceHeightU() (r int32, exists bool) {
	v := m.adddevice_height_u
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeviceHeightU clears the value of the "device_height_u" field.
func (m *DeviceMutation) ClearDeviceHeightU() {
	m.device_height_u = nil
	m.adddevice_height_u = nil
	m.clearedFields[device.FieldDeviceHeightU] = struct{}{}
}

// DeviceHeightUCleared returns if the "device_height_u" field was cleared in this mutation.
func (m *DeviceMutation) DeviceHeightUCleared() bool {
	_, ok := m.clearedFields[device.FieldDeviceHeightU]
	return ok
}

// ResetDeviceHeightU resets all changes to the "device_height_u" field.
func (m *DeviceMutation) ResetDeviceHeightU() {
	m.device_height_u = nil
	m.adddevice_height_u = nil
	delete(m.clearedFields, device.FieldDeviceHeightU)
}

// SetStatus sets the "status" field.
func (m *DeviceMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DeviceMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DeviceMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DeviceMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *DeviceMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetPrimaryIP sets the "primary_ip" field.
func (m *DeviceMutation) SetPrimaryIP(s string) {
	m.primary_ip = &s
}

// PrimaryIP returns the value of the "primary_ip" field in the mutation.
func (m *DeviceMutation) PrimaryIP() (r string, exists bool) {
	v := m.primary_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryIP returns the old "primary_ip" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldPrimaryIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryIP: %w", err)
	}
	return oldValue.PrimaryIP, nil
}

// ClearPrimaryIP clears the value of the "primary_ip" field.
func (m *DeviceMutation) ClearPrimaryIP() {
	m.primary_ip = nil
	m.clearedFields[device.FieldPrimaryIP] = struct{}{}
}

// PrimaryIPCleared returns if the "primary_ip" field was cleared in this mutation.
func (m *DeviceMutation) PrimaryIPCleared() bool {
	_, ok := m.clearedFields[device.FieldPrimaryIP]
	return ok
}

// ResetPrimaryIP resets all changes to the "primary_ip" field.
func (m *DeviceMutation) ResetPrimaryIP() {
	m.primary_ip = nil
	delete(m.clearedFields, device.FieldPrimaryIP)
}

// SetPrimaryIpv6 sets the "primary_ipv6" field.
func (m *DeviceMutation) SetPrimaryIpv6(s string) {
	m.primary_ipv6 = &s
}

// PrimaryIpv6 returns the value of the "primary_ipv6" field in the mutation.
func (m *DeviceMutation) PrimaryIpv6() (r string, exists bool) {
	v := m.primary_ipv6
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryIpv6 returns the old "primary_ipv6" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldPrimaryIpv6(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryIpv6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryIpv6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryIpv6: %w", err)
	}
	return oldValue.PrimaryIpv6, nil
}

// ClearPrimaryIpv6 clears the value of the "primary_ipv6" field.
func (m *DeviceMutation) ClearPrimaryIpv6() {
	m.primary_ipv6 = nil
	m.clearedFields[device.FieldPrimaryIpv6] = struct{}{}
}

// PrimaryIpv6Cleared returns if the "primary_ipv6" field was cleared in this mutation.
func (m *DeviceMutation) PrimaryIpv6Cleared() bool {
	_, ok := m.clearedFields[device.FieldPrimaryIpv6]
	return ok
}

// ResetPrimaryIpv6 resets all changes to the "primary_ipv6" field.
func (m *DeviceMutation) ResetPrimaryIpv6() {
	m.primary_ipv6 = nil
	delete(m.clearedFields, device.FieldPrimaryIpv6)
}

// SetManagementIP sets the "management_ip" field.
func (m *DeviceMutation) SetManagementIP(s string) {
	m.management_ip = &s
}

// ManagementIP returns the value of the "management_ip" field in the mutation.
func (m *DeviceMutation) ManagementIP() (r string, exists bool) {
	v := m.management_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldManagementIP returns the old "management_ip" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldManagementIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagementIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagementIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagementIP: %w", err)
	}
	return oldValue.ManagementIP, nil
}

// ClearManagementIP clears the value of the "management_ip" field.
func (m *DeviceMutation) ClearManagementIP() {
	m.management_ip = nil
	m.clearedFields[device.FieldManagementIP] = struct{}{}
}

// ManagementIPCleared returns if the "management_ip" field was cleared in this mutation.
func (m *DeviceMutation) ManagementIPCleared() bool {
	_, ok := m.clearedFields[device.FieldManagementIP]
	return ok
}

// ResetManagementIP resets all changes to the "management_ip" field.
func (m *DeviceMutation) ResetManagementIP() {
	m.management_ip = nil
	delete(m.clearedFields, device.FieldManagementIP)
}

// SetOsType sets the "os_type" field.
func (m *DeviceMutation) SetOsType(s string) {
	m.os_type = &s
}

// OsType returns the value of the "os_type" field in the mutation.
func (m *DeviceMutation) OsType() (r string, exists bool) {
	v := m.os_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOsType returns the old "os_type" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldOsType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsType: %w", err)
	}
	return oldValue.OsType, nil
}

// ClearOsType clears the value of the "os_type" field.
func (m *DeviceMutation) ClearOsType() {
	m.os_type = nil
	m.clearedFields[device.FieldOsType] = struct{}{}
}

// OsTypeCleared returns if the "os_type" field was cleared in this mutation.
func (m *DeviceMutation) OsTypeCleared() bool {
	_, ok := m.clearedFields[device.FieldOsType]
	return ok
}

// ResetOsType resets all changes to the "os_type" field.
func (m *DeviceMutation) ResetOsType() {
	m.os_type = nil
	delete(m.clearedFields, device.FieldOsType)
}

// SetOsVersion sets the "os_version" field.
func (m *DeviceMutation) SetOsVersion(s string) {
	m.os_version = &s
}

// OsVersion returns the value of the "os_version" field in the mutation.
func (m *DeviceMutation) OsVersion() (r string, exists bool) {
	v := m.os_version
	if v == nil {
		return
	}
	return *v, true
}

// OldOsVersion returns the old "os_version" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldOsVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsVersion: %w", err)
	}
	return oldValue.OsVersion, nil
}

// ClearOsVersion clears the value of the "os_version" field.
func (m *DeviceMutation) ClearOsVersion() {
	m.os_version = nil
	m.clearedFields[device.FieldOsVersion] = struct{}{}
}

// OsVersionCleared returns if the "os_version" field was cleared in this mutation.
func (m *DeviceMutation) OsVersionCleared() bool {
	_, ok := m.clearedFields[device.FieldOsVersion]
	return ok
}

// ResetOsVersion resets all changes to the "os_version" field.
func (m *DeviceMutation) ResetOsVersion() {
	m.os_version = nil
	delete(m.clearedFields, device.FieldOsVersion)
}

// SetFirmwareVersion sets the "firmware_version" field.
func (m *DeviceMutation) SetFirmwareVersion(s string) {
	m.firmware_version = &s
}

// FirmwareVersion returns the value of the "firmware_version" field in the mutation.
func (m *DeviceMutation) FirmwareVersion() (r string, exists bool) {
	v := m.firmware_version
	if v == nil {
		return
	}
	return *v, true
}

// OldFirmwareVersion returns the old "firmware_version" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldFirmwareVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirmwareVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirmwareVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirmwareVersion: %w", err)
	}
	return oldValue.FirmwareVersion, nil
}

// ClearFirmwareVersion clears the value of the "firmware_version" field.
func (m *DeviceMutation) ClearFirmwareVersion() {
	m.firmware_version = nil
	m.clearedFields[device.FieldFirmwareVersion] = struct{}{}
}

// FirmwareVersionCleared returns if the "firmware_version" field was cleared in this mutation.
func (m *DeviceMutation) FirmwareVersionCleared() bool {
	_, ok := m.clearedFields[device.FieldFirmwareVersion]
	return ok
}

// ResetFirmwareVersion resets all changes to the "firmware_version" field.
func (m *DeviceMutation) ResetFirmwareVersion() {
	m.firmware_version = nil
	delete(m.clearedFields, device.FieldFirmwareVersion)
}

// SetContact sets the "contact" field.
func (m *DeviceMutation) SetContact(s string) {
	m.contact = &s
}

// Contact returns the value of the "contact" field in the mutation.
func (m *DeviceMutation) Contact() (r string, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old "contact" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// ClearContact clears the value of the "contact" field.
func (m *DeviceMutation) ClearContact() {
	m.contact = nil
	m.clearedFields[device.FieldContact] = struct{}{}
}

// ContactCleared returns if the "contact" field was cleared in this mutation.
func (m *DeviceMutation) ContactCleared() bool {
	_, ok := m.clearedFields[device.FieldContact]
	return ok
}

// ResetContact resets all changes to the "contact" field.
func (m *DeviceMutation) ResetContact() {
	m.contact = nil
	delete(m.clearedFields, device.FieldContact)
}

// SetTags sets the "tags" field.
func (m *DeviceMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *DeviceMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *DeviceMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[device.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *DeviceMutation) TagsCleared() bool {
	_, ok := m.clearedFields[device.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *DeviceMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, device.FieldTags)
}

// SetMetadata sets the "metadata" field.
func (m *DeviceMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *DeviceMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *DeviceMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[device.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *DeviceMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[device.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *DeviceMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, device.FieldMetadata)
}

// SetNotes sets the "notes" field.
func (m *DeviceMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *DeviceMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *DeviceMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[device.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *DeviceMutation) NotesCleared() bool {
	_, ok := m.clearedFields[device.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *DeviceMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, device.FieldNotes)
}

// SetLastSeen sets the "last_seen" field.
func (m *DeviceMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *DeviceMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldLastSeen(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ClearLastSeen clears the value of the "last_seen" field.
func (m *DeviceMutation) ClearLastSeen() {
	m.last_seen = nil
	m.clearedFields[device.FieldLastSeen] = struct{}{}
}

// LastSeenCleared returns if the "last_seen" field was cleared in this mutation.
func (m *DeviceMutation) LastSeenCleared() bool {
	_, ok := m.clearedFields[device.FieldLastSeen]
	return ok
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *DeviceMutation) ResetLastSeen() {
	m.last_seen = nil
	delete(m.clearedFields, device.FieldLastSeen)
}

// AddAddressIDs adds the "addresses" edge to the IpAddress entity by ids.
func (m *DeviceMutation) AddAddressIDs(ids ...string) {
	if m.addresses == nil {
		m.addresses = make(map[string]struct{})
	}
	for i := range ids {
		m.addresses[ids[i]] = struct{}{}
	}
}

// ClearAddresses clears the "addresses" edge to the IpAddress entity.
func (m *DeviceMutation) ClearAddresses() {
	m.clearedaddresses = true
}

// AddressesCleared reports if the "addresses" edge to the IpAddress entity was cleared.
func (m *DeviceMutation) AddressesCleared() bool {
	return m.clearedaddresses
}

// RemoveAddressIDs removes the "addresses" edge to the IpAddress entity by IDs.
func (m *DeviceMutation) RemoveAddressIDs(ids ...string) {
	if m.removedaddresses == nil {
		m.removedaddresses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.addresses, ids[i])
		m.removedaddresses[ids[i]] = struct{}{}
	}
}

// RemovedAddresses returns the removed IDs of the "addresses" edge to the IpAddress entity.
func (m *DeviceMutation) RemovedAddressesIDs() (ids []string) {
	for id := range m.removedaddresses {
		ids = append(ids, id)
	}
	return
}

// AddressesIDs returns the "addresses" edge IDs in the mutation.
func (m *DeviceMutation) AddressesIDs() (ids []string) {
	for id := range m.addresses {
		ids = append(ids, id)
	}
	return
}

// ResetAddresses resets all changes to the "addresses" edge.
func (m *DeviceMutation) ResetAddresses() {
	m.addresses = nil
	m.clearedaddresses = false
	m.removedaddresses = nil
}

// AddInterfaceIDs adds the "interfaces" edge to the DeviceInterface entity by ids.
func (m *DeviceMutation) AddInterfaceIDs(ids ...string) {
	if m.interfaces == nil {
		m.interfaces = make(map[string]struct{})
	}
	for i := range ids {
		m.interfaces[ids[i]] = struct{}{}
	}
}

// ClearInterfaces clears the "interfaces" edge to the DeviceInterface entity.
func (m *DeviceMutation) ClearInterfaces() {
	m.clearedinterfaces = true
}

// InterfacesCleared reports if the "interfaces" edge to the DeviceInterface entity was cleared.
func (m *DeviceMutation) InterfacesCleared() bool {
	return m.clearedinterfaces
}

// RemoveInterfaceIDs removes the "interfaces" edge to the DeviceInterface entity by IDs.
func (m *DeviceMutation) RemoveInterfaceIDs(ids ...string) {
	if m.removedinterfaces == nil {
		m.removedinterfaces = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.interfaces, ids[i])
		m.removedinterfaces[ids[i]] = struct{}{}
	}
}

// RemovedInterfaces returns the removed IDs of the "interfaces" edge to the DeviceInterface entity.
func (m *DeviceMutation) RemovedInterfacesIDs() (ids []string) {
	for id := range m.removedinterfaces {
		ids = append(ids, id)
	}
	return
}

// InterfacesIDs returns the "interfaces" edge IDs in the mutation.
func (m *DeviceMutation) InterfacesIDs() (ids []string) {
	for id := range m.interfaces {
		ids = append(ids, id)
	}
	return
}

// ResetInterfaces resets all changes to the "interfaces" edge.
func (m *DeviceMutation) ResetInterfaces() {
	m.interfaces = nil
	m.clearedinterfaces = false
	m.removedinterfaces = nil
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *DeviceMutation) ClearLocation() {
	m.clearedlocation = true
	m.clearedFields[device.FieldLocationID] = struct{}{}
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *DeviceMutation) LocationCleared() bool {
	return m.LocationIDCleared() || m.clearedlocation
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) LocationIDs() (ids []string) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *DeviceMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// Where appends a list predicates to the DeviceMutation builder.
func (m *DeviceMutation) Where(ps ...predicate.Device) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Device, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.create_by != nil {
		fields = append(fields, device.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, device.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, device.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, device.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, device.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, device.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, device.FieldName)
	}
	if m.device_type != nil {
		fields = append(fields, device.FieldDeviceType)
	}
	if m.description != nil {
		fields = append(fields, device.FieldDescription)
	}
	if m.manufacturer != nil {
		fields = append(fields, device.FieldManufacturer)
	}
	if m.model != nil {
		fields = append(fields, device.FieldModel)
	}
	if m.serial_number != nil {
		fields = append(fields, device.FieldSerialNumber)
	}
	if m.asset_tag != nil {
		fields = append(fields, device.FieldAssetTag)
	}
	if m.location != nil {
		fields = append(fields, device.FieldLocationID)
	}
	if m.rack_id != nil {
		fields = append(fields, device.FieldRackID)
	}
	if m.rack_position != nil {
		fields = append(fields, device.FieldRackPosition)
	}
	if m.device_height_u != nil {
		fields = append(fields, device.FieldDeviceHeightU)
	}
	if m.status != nil {
		fields = append(fields, device.FieldStatus)
	}
	if m.primary_ip != nil {
		fields = append(fields, device.FieldPrimaryIP)
	}
	if m.primary_ipv6 != nil {
		fields = append(fields, device.FieldPrimaryIpv6)
	}
	if m.management_ip != nil {
		fields = append(fields, device.FieldManagementIP)
	}
	if m.os_type != nil {
		fields = append(fields, device.FieldOsType)
	}
	if m.os_version != nil {
		fields = append(fields, device.FieldOsVersion)
	}
	if m.firmware_version != nil {
		fields = append(fields, device.FieldFirmwareVersion)
	}
	if m.contact != nil {
		fields = append(fields, device.FieldContact)
	}
	if m.tags != nil {
		fields = append(fields, device.FieldTags)
	}
	if m.metadata != nil {
		fields = append(fields, device.FieldMetadata)
	}
	if m.notes != nil {
		fields = append(fields, device.FieldNotes)
	}
	if m.last_seen != nil {
		fields = append(fields, device.FieldLastSeen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldCreateBy:
		return m.CreateBy()
	case device.FieldUpdateBy:
		return m.UpdateBy()
	case device.FieldCreateTime:
		return m.CreateTime()
	case device.FieldUpdateTime:
		return m.UpdateTime()
	case device.FieldDeleteTime:
		return m.DeleteTime()
	case device.FieldTenantID:
		return m.TenantID()
	case device.FieldName:
		return m.Name()
	case device.FieldDeviceType:
		return m.DeviceType()
	case device.FieldDescription:
		return m.Description()
	case device.FieldManufacturer:
		return m.Manufacturer()
	case device.FieldModel:
		return m.Model()
	case device.FieldSerialNumber:
		return m.SerialNumber()
	case device.FieldAssetTag:
		return m.AssetTag()
	case device.FieldLocationID:
		return m.LocationID()
	case device.FieldRackID:
		return m.RackID()
	case device.FieldRackPosition:
		return m.RackPosition()
	case device.FieldDeviceHeightU:
		return m.DeviceHeightU()
	case device.FieldStatus:
		return m.Status()
	case device.FieldPrimaryIP:
		return m.PrimaryIP()
	case device.FieldPrimaryIpv6:
		return m.PrimaryIpv6()
	case device.FieldManagementIP:
		return m.ManagementIP()
	case device.FieldOsType:
		return m.OsType()
	case device.FieldOsVersion:
		return m.OsVersion()
	case device.FieldFirmwareVersion:
		return m.FirmwareVersion()
	case device.FieldContact:
		return m.Contact()
	case device.FieldTags:
		return m.Tags()
	case device.FieldMetadata:
		return m.Metadata()
	case device.FieldNotes:
		return m.Notes()
	case device.FieldLastSeen:
		return m.LastSeen()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case device.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case device.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case device.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case device.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case device.FieldTenantID:
		return m.OldTenantID(ctx)
	case device.FieldName:
		return m.OldName(ctx)
	case device.FieldDeviceType:
		return m.OldDeviceType(ctx)
	case device.FieldDescription:
		return m.OldDescription(ctx)
	case device.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case device.FieldModel:
		return m.OldModel(ctx)
	case device.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case device.FieldAssetTag:
		return m.OldAssetTag(ctx)
	case device.FieldLocationID:
		return m.OldLocationID(ctx)
	case device.FieldRackID:
		return m.OldRackID(ctx)
	case device.FieldRackPosition:
		return m.OldRackPosition(ctx)
	case device.FieldDeviceHeightU:
		return m.OldDeviceHeightU(ctx)
	case device.FieldStatus:
		return m.OldStatus(ctx)
	case device.FieldPrimaryIP:
		return m.OldPrimaryIP(ctx)
	case device.FieldPrimaryIpv6:
		return m.OldPrimaryIpv6(ctx)
	case device.FieldManagementIP:
		return m.OldManagementIP(ctx)
	case device.FieldOsType:
		return m.OldOsType(ctx)
	case device.FieldOsVersion:
		return m.OldOsVersion(ctx)
	case device.FieldFirmwareVersion:
		return m.OldFirmwareVersion(ctx)
	case device.FieldContact:
		return m.OldContact(ctx)
	case device.FieldTags:
		return m.OldTags(ctx)
	case device.FieldMetadata:
		return m.OldMetadata(ctx)
	case device.FieldNotes:
		return m.OldNotes(ctx)
	case device.FieldLastSeen:
		return m.OldLastSeen(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case device.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case device.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case device.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case device.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case device.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case device.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case device.FieldDeviceType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceType(v)
		return nil
	case device.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case device.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case device.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case device.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case device.FieldAssetTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetTag(v)
		return nil
	case device.FieldLocationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case device.FieldRackID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRackID(v)
		return nil
	case device.FieldRackPosition:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRackPosition(v)
		return nil
	case device.FieldDeviceHeightU:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceHeightU(v)
		return nil
	case device.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case device.FieldPrimaryIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryIP(v)
		return nil
	case device.FieldPrimaryIpv6:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryIpv6(v)
		return nil
	case device.FieldManagementIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagementIP(v)
		return nil
	case device.FieldOsType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsType(v)
		return nil
	case device.FieldOsVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsVersion(v)
		return nil
	case device.FieldFirmwareVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirmwareVersion(v)
		return nil
	case device.FieldContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case device.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case device.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case device.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case device.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, device.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, device.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, device.FieldTenantID)
	}
	if m.adddevice_type != nil {
		fields = append(fields, device.FieldDeviceType)
	}
	if m.addrack_position != nil {
		fields = append(fields, device.FieldRackPosition)
	}
	if m.adddevice_height_u != nil {
		fields = append(fields, device.FieldDeviceHeightU)
	}
	if m.addstatus != nil {
		fields = append(fields, device.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case device.FieldCreateBy:
		return m.AddedCreateBy()
	case device.FieldUpdateBy:
		return m.AddedUpdateBy()
	case device.FieldTenantID:
		return m.AddedTenantID()
	case device.FieldDeviceType:
		return m.AddedDeviceType()
	case device.FieldRackPosition:
		return m.AddedRackPosition()
	case device.FieldDeviceHeightU:
		return m.AddedDeviceHeightU()
	case device.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case device.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case device.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case device.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case device.FieldDeviceType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceType(v)
		return nil
	case device.FieldRackPosition:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRackPosition(v)
		return nil
	case device.FieldDeviceHeightU:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceHeightU(v)
		return nil
	case device.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(device.FieldCreateBy) {
		fields = append(fields, device.FieldCreateBy)
	}
	if m.FieldCleared(device.FieldUpdateBy) {
		fields = append(fields, device.FieldUpdateBy)
	}
	if m.FieldCleared(device.FieldCreateTime) {
		fields = append(fields, device.FieldCreateTime)
	}
	if m.FieldCleared(device.FieldUpdateTime) {
		fields = append(fields, device.FieldUpdateTime)
	}
	if m.FieldCleared(device.FieldDeleteTime) {
		fields = append(fields, device.FieldDeleteTime)
	}
	if m.FieldCleared(device.FieldTenantID) {
		fields = append(fields, device.FieldTenantID)
	}
	if m.FieldCleared(device.FieldDescription) {
		fields = append(fields, device.FieldDescription)
	}
	if m.FieldCleared(device.FieldManufacturer) {
		fields = append(fields, device.FieldManufacturer)
	}
	if m.FieldCleared(device.FieldModel) {
		fields = append(fields, device.FieldModel)
	}
	if m.FieldCleared(device.FieldSerialNumber) {
		fields = append(fields, device.FieldSerialNumber)
	}
	if m.FieldCleared(device.FieldAssetTag) {
		fields = append(fields, device.FieldAssetTag)
	}
	if m.FieldCleared(device.FieldLocationID) {
		fields = append(fields, device.FieldLocationID)
	}
	if m.FieldCleared(device.FieldRackID) {
		fields = append(fields, device.FieldRackID)
	}
	if m.FieldCleared(device.FieldRackPosition) {
		fields = append(fields, device.FieldRackPosition)
	}
	if m.FieldCleared(device.FieldDeviceHeightU) {
		fields = append(fields, device.FieldDeviceHeightU)
	}
	if m.FieldCleared(device.FieldPrimaryIP) {
		fields = append(fields, device.FieldPrimaryIP)
	}
	if m.FieldCleared(device.FieldPrimaryIpv6) {
		fields = append(fields, device.FieldPrimaryIpv6)
	}
	if m.FieldCleared(device.FieldManagementIP) {
		fields = append(fields, device.FieldManagementIP)
	}
	if m.FieldCleared(device.FieldOsType) {
		fields = append(fields, device.FieldOsType)
	}
	if m.FieldCleared(device.FieldOsVersion) {
		fields = append(fields, device.FieldOsVersion)
	}
	if m.FieldCleared(device.FieldFirmwareVersion) {
		fields = append(fields, device.FieldFirmwareVersion)
	}
	if m.FieldCleared(device.FieldContact) {
		fields = append(fields, device.FieldContact)
	}
	if m.FieldCleared(device.FieldTags) {
		fields = append(fields, device.FieldTags)
	}
	if m.FieldCleared(device.FieldMetadata) {
		fields = append(fields, device.FieldMetadata)
	}
	if m.FieldCleared(device.FieldNotes) {
		fields = append(fields, device.FieldNotes)
	}
	if m.FieldCleared(device.FieldLastSeen) {
		fields = append(fields, device.FieldLastSeen)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	switch name {
	case device.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case device.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case device.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case device.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case device.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case device.FieldTenantID:
		m.ClearTenantID()
		return nil
	case device.FieldDescription:
		m.ClearDescription()
		return nil
	case device.FieldManufacturer:
		m.ClearManufacturer()
		return nil
	case device.FieldModel:
		m.ClearModel()
		return nil
	case device.FieldSerialNumber:
		m.ClearSerialNumber()
		return nil
	case device.FieldAssetTag:
		m.ClearAssetTag()
		return nil
	case device.FieldLocationID:
		m.ClearLocationID()
		return nil
	case device.FieldRackID:
		m.ClearRackID()
		return nil
	case device.FieldRackPosition:
		m.ClearRackPosition()
		return nil
	case device.FieldDeviceHeightU:
		m.ClearDeviceHeightU()
		return nil
	case device.FieldPrimaryIP:
		m.ClearPrimaryIP()
		return nil
	case device.FieldPrimaryIpv6:
		m.ClearPrimaryIpv6()
		return nil
	case device.FieldManagementIP:
		m.ClearManagementIP()
		return nil
	case device.FieldOsType:
		m.ClearOsType()
		return nil
	case device.FieldOsVersion:
		m.ClearOsVersion()
		return nil
	case device.FieldFirmwareVersion:
		m.ClearFirmwareVersion()
		return nil
	case device.FieldContact:
		m.ClearContact()
		return nil
	case device.FieldTags:
		m.ClearTags()
		return nil
	case device.FieldMetadata:
		m.ClearMetadata()
		return nil
	case device.FieldNotes:
		m.ClearNotes()
		return nil
	case device.FieldLastSeen:
		m.ClearLastSeen()
		return nil
	}
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case device.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case device.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case device.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case device.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case device.FieldTenantID:
		m.ResetTenantID()
		return nil
	case device.FieldName:
		m.ResetName()
		return nil
	case device.FieldDeviceType:
		m.ResetDeviceType()
		return nil
	case device.FieldDescription:
		m.ResetDescription()
		return nil
	case device.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case device.FieldModel:
		m.ResetModel()
		return nil
	case device.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case device.FieldAssetTag:
		m.ResetAssetTag()
		return nil
	case device.FieldLocationID:
		m.ResetLocationID()
		return nil
	case device.FieldRackID:
		m.ResetRackID()
		return nil
	case device.FieldRackPosition:
		m.ResetRackPosition()
		return nil
	case device.FieldDeviceHeightU:
		m.ResetDeviceHeightU()
		return nil
	case device.FieldStatus:
		m.ResetStatus()
		return nil
	case device.FieldPrimaryIP:
		m.ResetPrimaryIP()
		return nil
	case device.FieldPrimaryIpv6:
		m.ResetPrimaryIpv6()
		return nil
	case device.FieldManagementIP:
		m.ResetManagementIP()
		return nil
	case device.FieldOsType:
		m.ResetOsType()
		return nil
	case device.FieldOsVersion:
		m.ResetOsVersion()
		return nil
	case device.FieldFirmwareVersion:
		m.ResetFirmwareVersion()
		return nil
	case device.FieldContact:
		m.ResetContact()
		return nil
	case device.FieldTags:
		m.ResetTags()
		return nil
	case device.FieldMetadata:
		m.ResetMetadata()
		return nil
	case device.FieldNotes:
		m.ResetNotes()
		return nil
	case device.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.addresses != nil {
		edges = append(edges, device.EdgeAddresses)
	}
	if m.interfaces != nil {
		edges = append(edges, device.EdgeInterfaces)
	}
	if m.location != nil {
		edges = append(edges, device.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.addresses))
		for id := range m.addresses {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeInterfaces:
		ids := make([]ent.Value, 0, len(m.interfaces))
		for id := range m.interfaces {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedaddresses != nil {
		edges = append(edges, device.EdgeAddresses)
	}
	if m.removedinterfaces != nil {
		edges = append(edges, device.EdgeInterfaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.removedaddresses))
		for id := range m.removedaddresses {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeInterfaces:
		ids := make([]ent.Value, 0, len(m.removedinterfaces))
		for id := range m.removedinterfaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedaddresses {
		edges = append(edges, device.EdgeAddresses)
	}
	if m.clearedinterfaces {
		edges = append(edges, device.EdgeInterfaces)
	}
	if m.clearedlocation {
		edges = append(edges, device.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeAddresses:
		return m.clearedaddresses
	case device.EdgeInterfaces:
		return m.clearedinterfaces
	case device.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	case device.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeAddresses:
		m.ResetAddresses()
		return nil
	case device.EdgeInterfaces:
		m.ResetInterfaces()
		return nil
	case device.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// DeviceInterfaceMutation represents an operation that mutates the DeviceInterface nodes in the graph.
type DeviceInterfaceMutation struct {
	config
	op             Op
	typ            string
	id             *string
	create_time    *time.Time
	update_time    *time.Time
	delete_time    *time.Time
	name           *string
	mac_address    *string
	interface_type *string
	enabled        *bool
	speed_mbps     *int32
	addspeed_mbps  *int32
	description    *string
	clearedFields  map[string]struct{}
	device         *string
	cleareddevice  bool
	done           bool
	oldValue       func(context.Context) (*DeviceInterface, error)
	predicates     []predicate.DeviceInterface
}

var _ ent.Mutation = (*DeviceInterfaceMutation)(nil)

// deviceinterfaceOption allows management of the mutation configuration using functional options.
type deviceinterfaceOption func(*DeviceInterfaceMutation)

// newDeviceInterfaceMutation creates new mutation for the DeviceInterface entity.
func newDeviceInterfaceMutation(c config, op Op, opts ...deviceinterfaceOption) *DeviceInterfaceMutation {
	m := &DeviceInterfaceMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceInterface,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceInterfaceID sets the ID field of the mutation.
func withDeviceInterfaceID(id string) deviceinterfaceOption {
	return func(m *DeviceInterfaceMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceInterface
		)
		m.oldValue = func(ctx context.Context) (*DeviceInterface, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceInterface.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceInterface sets the old DeviceInterface of the mutation.
func withDeviceInterface(node *DeviceInterface) deviceinterfaceOption {
	return func(m *DeviceInterfaceMutation) {
		m.oldValue = func(context.Context) (*DeviceInterface, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceInterfaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceInterfaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceInterface entities.
func (m *DeviceInterfaceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceInterfaceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceInterfaceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceInterface.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DeviceInterfaceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DeviceInterfaceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DeviceInterface entity.
// If the DeviceInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInterfaceMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *DeviceInterfaceMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[deviceinterface.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *DeviceInterfaceMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[deviceinterface.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DeviceInterfaceMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, deviceinterface.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *DeviceInterfaceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DeviceInterfaceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DeviceInterface entity.
// If the DeviceInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInterfaceMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *DeviceInterfaceMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[deviceinterface.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *DeviceInterfaceMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[deviceinterface.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DeviceInterfaceMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, deviceinterface.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *DeviceInterfaceMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *DeviceInterfaceMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the DeviceInterface entity.
// If the DeviceInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInterfaceMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *DeviceInterfaceMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[deviceinterface.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *DeviceInterfaceMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[deviceinterface.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *DeviceInterfaceMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, deviceinterface.FieldDeleteTime)
}

// SetDeviceID sets the "device_id" field.
func (m *DeviceInterfaceMutation) SetDeviceID(s string) {
	m.device = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *DeviceInterfaceMutation) DeviceID() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the DeviceInterface entity.
// If the DeviceInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInterfaceMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *DeviceInterfaceMutation) ResetDeviceID() {
	m.device = nil
}

// SetName sets the "name" field.
func (m *DeviceInterfaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeviceInterfaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DeviceInterface entity.
// If the DeviceInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInterfaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeviceInterfaceMutation) ResetName() {
	m.name = nil
}

// SetMACAddress sets the "mac_address" field.
func (m *DeviceInterfaceMutation) SetMACAddress(s string) {
	m.mac_address = &s
}

// MACAddress returns the value of the "mac_address" field in the mutation.
func (m *DeviceInterfaceMutation) MACAddress() (r string, exists bool) {
	v := m.mac_address
	if v == nil {
		return
	}
	return *v, true
}

// OldMACAddress returns the old "mac_address" field's value of the DeviceInterface entity.
// If the DeviceInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInterfaceMutation) OldMACAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMACAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMACAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMACAddress: %w", err)
	}
	return oldValue.MACAddress, nil
}

// ClearMACAddress clears the value of the "mac_address" field.
func (m *DeviceInterfaceMutation) ClearMACAddress() {
	m.mac_address = nil
	m.clearedFields[deviceinterface.FieldMACAddress] = struct{}{}
}

// MACAddressCleared returns if the "mac_address" field was cleared in this mutation.
func (m *DeviceInterfaceMutation) MACAddressCleared() bool {
	_, ok := m.clearedFields[deviceinterface.FieldMACAddress]
	return ok
}

// ResetMACAddress resets all changes to the "mac_address" field.
func (m *DeviceInterfaceMutation) ResetMACAddress() {
	m.mac_address = nil
	delete(m.clearedFields, deviceinterface.FieldMACAddress)
}

// SetInterfaceType sets the "interface_type" field.
func (m *DeviceInterfaceMutation) SetInterfaceType(s string) {
	m.interface_type = &s
}

// InterfaceType returns the value of the "interface_type" field in the mutation.
func (m *DeviceInterfaceMutation) InterfaceType() (r string, exists bool) {
	v := m.interface_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInterfaceType returns the old "interface_type" field's value of the DeviceInterface entity.
// If the DeviceInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInterfaceMutation) OldInterfaceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterfaceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterfaceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterfaceType: %w", err)
	}
	return oldValue.InterfaceType, nil
}

// ClearInterfaceType clears the value of the "interface_type" field.
func (m *DeviceInterfaceMutation) ClearInterfaceType() {
	m.interface_type = nil
	m.clearedFields[deviceinterface.FieldInterfaceType] = struct{}{}
}

// InterfaceTypeCleared returns if the "interface_type" field was cleared in this mutation.
func (m *DeviceInterfaceMutation) InterfaceTypeCleared() bool {
	_, ok := m.clearedFields[deviceinterface.FieldInterfaceType]
	return ok
}

// ResetInterfaceType resets all changes to the "interface_type" field.
func (m *DeviceInterfaceMutation) ResetInterfaceType() {
	m.interface_type = nil
	delete(m.clearedFields, deviceinterface.FieldInterfaceType)
}

// SetEnabled sets the "enabled" field.
func (m *DeviceInterfaceMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *DeviceInterfaceMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the DeviceInterface entity.
// If the DeviceInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInterfaceMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *DeviceInterfaceMutation) ResetEnabled() {
	m.enabled = nil
}

// SetSpeedMbps sets the "speed_mbps" field.
func (m *DeviceInterfaceMutation) SetSpeedMbps(i int32) {
	m.speed_mbps = &i
	m.addspeed_mbps = nil
}

// SpeedMbps returns the value of the "speed_mbps" field in the mutation.
func (m *DeviceInterfaceMutation) SpeedMbps() (r int32, exists bool) {
	v := m.speed_mbps
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeedMbps returns the old "speed_mbps" field's value of the DeviceInterface entity.
// If the DeviceInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInterfaceMutation) OldSpeedMbps(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeedMbps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeedMbps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeedMbps: %w", err)
	}
	return oldValue.SpeedMbps, nil
}

// AddSpeedMbps adds i to the "speed_mbps" field.
func (m *DeviceInterfaceMutation) AddSpeedMbps(i int32) {
	if m.addspeed_mbps != nil {
		*m.addspeed_mbps += i
	} else {
		m.addspeed_mbps = &i
	}
}

// AddedSpeedMbps returns the value that was added to the "speed_mbps" field in this mutation.
func (m *DeviceInterfaceMutation) AddedSpeedMbps() (r int32, exists bool) {
	v := m.addspeed_mbps
	if v == nil {
		return
	}
	return *v, true
}

// ClearSpeedMbps clears the value of the "speed_mbps" field.
func (m *DeviceInterfaceMutation) ClearSpeedMbps() {
	m.speed_mbps = nil
	m.addspeed_mbps = nil
	m.clearedFields[deviceinterface.FieldSpeedMbps] = struct{}{}
}

// SpeedMbpsCleared returns if the "speed_mbps" field was cleared in this mutation.
func (m *DeviceInterfaceMutation) SpeedMbpsCleared() bool {
	_, ok := m.clearedFields[deviceinterface.FieldSpeedMbps]
	return ok
}

// ResetSpeedMbps resets all changes to the "speed_mbps" field.
func (m *DeviceInterfaceMutation) ResetSpeedMbps() {
	m.speed_mbps = nil
	m.addspeed_mbps = nil
	delete(m.clearedFields, deviceinterface.FieldSpeedMbps)
}

// SetDescription sets the "description" field.
func (m *DeviceInterfaceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DeviceInterfaceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DeviceInterface entity.
// If the DeviceInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInterfaceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DeviceInterfaceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[deviceinterface.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DeviceInterfaceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[deviceinterface.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DeviceInterfaceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, deviceinterface.FieldDescription)
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *DeviceInterfaceMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[deviceinterface.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *DeviceInterfaceMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *DeviceInterfaceMutation) DeviceIDs() (ids []string) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *DeviceInterfaceMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the DeviceInterfaceMutation builder.
func (m *DeviceInterfaceMutation) Where(ps ...predicate.DeviceInterface) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceInterfaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceInterfaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceInterface, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceInterfaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceInterfaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceInterface).
func (m *DeviceInterfaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceInterfaceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, deviceinterface.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, deviceinterface.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, deviceinterface.FieldDeleteTime)
	}
	if m.device != nil {
		fields = append(fields, deviceinterface.FieldDeviceID)
	}
	if m.name != nil {
		fields = append(fields, deviceinterface.FieldName)
	}
	if m.mac_address != nil {
		fields = append(fields, deviceinterface.FieldMACAddress)
	}
	if m.interface_type != nil {
		fields = append(fields, deviceinterface.FieldInterfaceType)
	}
	if m.enabled != nil {
		fields = append(fields, deviceinterface.FieldEnabled)
	}
	if m.speed_mbps != nil {
		fields = append(fields, deviceinterface.FieldSpeedMbps)
	}
	if m.description != nil {
		fields = append(fields, deviceinterface.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceInterfaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceinterface.FieldCreateTime:
		return m.CreateTime()
	case deviceinterface.FieldUpdateTime:
		return m.UpdateTime()
	case deviceinterface.FieldDeleteTime:
		return m.DeleteTime()
	case deviceinterface.FieldDeviceID:
		return m.DeviceID()
	case deviceinterface.FieldName:
		return m.Name()
	case deviceinterface.FieldMACAddress:
		return m.MACAddress()
	case deviceinterface.FieldInterfaceType:
		return m.InterfaceType()
	case deviceinterface.FieldEnabled:
		return m.Enabled()
	case deviceinterface.FieldSpeedMbps:
		return m.SpeedMbps()
	case deviceinterface.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceInterfaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceinterface.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case deviceinterface.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case deviceinterface.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case deviceinterface.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case deviceinterface.FieldName:
		return m.OldName(ctx)
	case deviceinterface.FieldMACAddress:
		return m.OldMACAddress(ctx)
	case deviceinterface.FieldInterfaceType:
		return m.OldInterfaceType(ctx)
	case deviceinterface.FieldEnabled:
		return m.OldEnabled(ctx)
	case deviceinterface.FieldSpeedMbps:
		return m.OldSpeedMbps(ctx)
	case deviceinterface.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceInterface field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInterfaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceinterface.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case deviceinterface.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case deviceinterface.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case deviceinterface.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case deviceinterface.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case deviceinterface.FieldMACAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMACAddress(v)
		return nil
	case deviceinterface.FieldInterfaceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterfaceType(v)
		return nil
	case deviceinterface.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case deviceinterface.FieldSpeedMbps:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeedMbps(v)
		return nil
	case deviceinterface.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInterface field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceInterfaceMutation) AddedFields() []string {
	var fields []string
	if m.addspeed_mbps != nil {
		fields = append(fields, deviceinterface.FieldSpeedMbps)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceInterfaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deviceinterface.FieldSpeedMbps:
		return m.AddedSpeedMbps()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInterfaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deviceinterface.FieldSpeedMbps:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpeedMbps(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInterface numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceInterfaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deviceinterface.FieldCreateTime) {
		fields = append(fields, deviceinterface.FieldCreateTime)
	}
	if m.FieldCleared(deviceinterface.FieldUpdateTime) {
		fields = append(fields, deviceinterface.FieldUpdateTime)
	}
	if m.FieldCleared(deviceinterface.FieldDeleteTime) {
		fields = append(fields, deviceinterface.FieldDeleteTime)
	}
	if m.FieldCleared(deviceinterface.FieldMACAddress) {
		fields = append(fields, deviceinterface.FieldMACAddress)
	}
	if m.FieldCleared(deviceinterface.FieldInterfaceType) {
		fields = append(fields, deviceinterface.FieldInterfaceType)
	}
	if m.FieldCleared(deviceinterface.FieldSpeedMbps) {
		fields = append(fields, deviceinterface.FieldSpeedMbps)
	}
	if m.FieldCleared(deviceinterface.FieldDescription) {
		fields = append(fields, deviceinterface.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceInterfaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceInterfaceMutation) ClearField(name string) error {
	switch name {
	case deviceinterface.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case deviceinterface.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case deviceinterface.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case deviceinterface.FieldMACAddress:
		m.ClearMACAddress()
		return nil
	case deviceinterface.FieldInterfaceType:
		m.ClearInterfaceType()
		return nil
	case deviceinterface.FieldSpeedMbps:
		m.ClearSpeedMbps()
		return nil
	case deviceinterface.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DeviceInterface nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceInterfaceMutation) ResetField(name string) error {
	switch name {
	case deviceinterface.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case deviceinterface.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case deviceinterface.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case deviceinterface.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case deviceinterface.FieldName:
		m.ResetName()
		return nil
	case deviceinterface.FieldMACAddress:
		m.ResetMACAddress()
		return nil
	case deviceinterface.FieldInterfaceType:
		m.ResetInterfaceType()
		return nil
	case deviceinterface.FieldEnabled:
		m.ResetEnabled()
		return nil
	case deviceinterface.FieldSpeedMbps:
		m.ResetSpeedMbps()
		return nil
	case deviceinterface.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown DeviceInterface field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceInterfaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.device != nil {
		edges = append(edges, deviceinterface.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceInterfaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deviceinterface.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceInterfaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceInterfaceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceInterfaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddevice {
		edges = append(edges, deviceinterface.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceInterfaceMutation) EdgeCleared(name string) bool {
	switch name {
	case deviceinterface.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceInterfaceMutation) ClearEdge(name string) error {
	switch name {
	case deviceinterface.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceInterface unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceInterfaceMutation) ResetEdge(name string) error {
	switch name {
	case deviceinterface.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceInterface edge %s", name)
}

// DnsConfigMutation represents an operation that mutates the DnsConfig nodes in the graph.
type DnsConfigMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	create_by               *uint32
	addcreate_by            *int32
	update_by               *uint32
	addupdate_by            *int32
	create_time             *time.Time
	update_time             *time.Time
	delete_time             *time.Time
	tenant_id               *uint32
	addtenant_id            *int32
	dns_servers             *[]string
	appenddns_servers       []string
	timeout_ms              *int32
	addtimeout_ms           *int32
	use_system_dns_fallback *bool
	reverse_dns_enabled     *bool
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*DnsConfig, error)
	predicates              []predicate.DnsConfig
}

var _ ent.Mutation = (*DnsConfigMutation)(nil)

// dnsconfigOption allows management of the mutation configuration using functional options.
type dnsconfigOption func(*DnsConfigMutation)

// newDnsConfigMutation creates new mutation for the DnsConfig entity.
func newDnsConfigMutation(c config, op Op, opts ...dnsconfigOption) *DnsConfigMutation {
	m := &DnsConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeDnsConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDnsConfigID sets the ID field of the mutation.
func withDnsConfigID(id string) dnsconfigOption {
	return func(m *DnsConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *DnsConfig
		)
		m.oldValue = func(ctx context.Context) (*DnsConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DnsConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDnsConfig sets the old DnsConfig of the mutation.
func withDnsConfig(node *DnsConfig) dnsconfigOption {
	return func(m *DnsConfigMutation) {
		m.oldValue = func(context.Context) (*DnsConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DnsConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DnsConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DnsConfig entities.
func (m *DnsConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DnsConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DnsConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DnsConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *DnsConfigMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *DnsConfigMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the DnsConfig entity.
// If the DnsConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsConfigMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *DnsConfigMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *DnsConfigMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *DnsConfigMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[dnsconfig.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *DnsConfigMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[dnsconfig.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *DnsConfigMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, dnsconfig.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *DnsConfigMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *DnsConfigMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the DnsConfig entity.
// If the DnsConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsConfigMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *DnsConfigMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *DnsConfigMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *DnsConfigMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[dnsconfig.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *DnsConfigMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[dnsconfig.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *DnsConfigMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, dnsconfig.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *DnsConfigMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DnsConfigMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DnsConfig entity.
// If the DnsConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsConfigMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *DnsConfigMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[dnsconfig.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *DnsConfigMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[dnsconfig.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DnsConfigMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, dnsconfig.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *DnsConfigMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DnsConfigMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DnsConfig entity.
// If the DnsConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsConfigMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *DnsConfigMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[dnsconfig.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *DnsConfigMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[dnsconfig.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DnsConfigMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, dnsconfig.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *DnsConfigMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *DnsConfigMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the DnsConfig entity.
// If the DnsConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsConfigMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *DnsConfigMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[dnsconfig.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *DnsConfigMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[dnsconfig.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *DnsConfigMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, dnsconfig.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *DnsConfigMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DnsConfigMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DnsConfig entity.
// If the DnsConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsConfigMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *DnsConfigMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DnsConfigMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *DnsConfigMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[dnsconfig.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *DnsConfigMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[dnsconfig.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DnsConfigMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, dnsconfig.FieldTenantID)
}

// SetDNSServers sets the "dns_servers" field.
func (m *DnsConfigMutation) SetDNSServers(s []string) {
	m.dns_servers = &s
	m.appenddns_servers = nil
}

// DNSServers returns the value of the "dns_servers" field in the mutation.
func (m *DnsConfigMutation) DNSServers() (r []string, exists bool) {
	v := m.dns_servers
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSServers returns the old "dns_servers" field's value of the DnsConfig entity.
// If the DnsConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsConfigMutation) OldDNSServers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSServers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSServers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSServers: %w", err)
	}
	return oldValue.DNSServers, nil
}

// AppendDNSServers adds s to the "dns_servers" field.
func (m *DnsConfigMutation) AppendDNSServers(s []string) {
	m.appenddns_servers = append(m.appenddns_servers, s...)
}

// AppendedDNSServers returns the list of values that were appended to the "dns_servers" field in this mutation.
func (m *DnsConfigMutation) AppendedDNSServers() ([]string, bool) {
	if len(m.appenddns_servers) == 0 {
		return nil, false
	}
	return m.appenddns_servers, true
}

// ClearDNSServers clears the value of the "dns_servers" field.
func (m *DnsConfigMutation) ClearDNSServers() {
	m.dns_servers = nil
	m.appenddns_servers = nil
	m.clearedFields[dnsconfig.FieldDNSServers] = struct{}{}
}

// DNSServersCleared returns if the "dns_servers" field was cleared in this mutation.
func (m *DnsConfigMutation) DNSServersCleared() bool {
	_, ok := m.clearedFields[dnsconfig.FieldDNSServers]
	return ok
}

// ResetDNSServers resets all changes to the "dns_servers" field.
func (m *DnsConfigMutation) ResetDNSServers() {
	m.dns_servers = nil
	m.appenddns_servers = nil
	delete(m.clearedFields, dnsconfig.FieldDNSServers)
}

// SetTimeoutMs sets the "timeout_ms" field.
func (m *DnsConfigMutation) SetTimeoutMs(i int32) {
	m.timeout_ms = &i
	m.addtimeout_ms = nil
}

// TimeoutMs returns the value of the "timeout_ms" field in the mutation.
func (m *DnsConfigMutation) TimeoutMs() (r int32, exists bool) {
	v := m.timeout_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeoutMs returns the old "timeout_ms" field's value of the DnsConfig entity.
// If the DnsConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsConfigMutation) OldTimeoutMs(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeoutMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeoutMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeoutMs: %w", err)
	}
	return oldValue.TimeoutMs, nil
}

// AddTimeoutMs adds i to the "timeout_ms" field.
func (m *DnsConfigMutation) AddTimeoutMs(i int32) {
	if m.addtimeout_ms != nil {
		*m.addtimeout_ms += i
	} else {
		m.addtimeout_ms = &i
	}
}

// AddedTimeoutMs returns the value that was added to the "timeout_ms" field in this mutation.
func (m *DnsConfigMutation) AddedTimeoutMs() (r int32, exists bool) {
	v := m.addtimeout_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeoutMs resets all changes to the "timeout_ms" field.
func (m *DnsConfigMutation) ResetTimeoutMs() {
	m.timeout_ms = nil
	m.addtimeout_ms = nil
}

// SetUseSystemDNSFallback sets the "use_system_dns_fallback" field.
func (m *DnsConfigMutation) SetUseSystemDNSFallback(b bool) {
	m.use_system_dns_fallback = &b
}

// UseSystemDNSFallback returns the value of the "use_system_dns_fallback" field in the mutation.
func (m *DnsConfigMutation) UseSystemDNSFallback() (r bool, exists bool) {
	v := m.use_system_dns_fallback
	if v == nil {
		return
	}
	return *v, true
}

// OldUseSystemDNSFallback returns the old "use_system_dns_fallback" field's value of the DnsConfig entity.
// If the DnsConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsConfigMutation) OldUseSystemDNSFallback(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseSystemDNSFallback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseSystemDNSFallback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseSystemDNSFallback: %w", err)
	}
	return oldValue.UseSystemDNSFallback, nil
}

// ResetUseSystemDNSFallback resets all changes to the "use_system_dns_fallback" field.
func (m *DnsConfigMutation) ResetUseSystemDNSFallback() {
	m.use_system_dns_fallback = nil
}

// SetReverseDNSEnabled sets the "reverse_dns_enabled" field.
func (m *DnsConfigMutation) SetReverseDNSEnabled(b bool) {
	m.reverse_dns_enabled = &b
}

// ReverseDNSEnabled returns the value of the "reverse_dns_enabled" field in the mutation.
func (m *DnsConfigMutation) ReverseDNSEnabled() (r bool, exists bool) {
	v := m.reverse_dns_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldReverseDNSEnabled returns the old "reverse_dns_enabled" field's value of the DnsConfig entity.
// If the DnsConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DnsConfigMutation) OldReverseDNSEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReverseDNSEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReverseDNSEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReverseDNSEnabled: %w", err)
	}
	return oldValue.ReverseDNSEnabled, nil
}

// ResetReverseDNSEnabled resets all changes to the "reverse_dns_enabled" field.
func (m *DnsConfigMutation) ResetReverseDNSEnabled() {
	m.reverse_dns_enabled = nil
}

// Where appends a list predicates to the DnsConfigMutation builder.
func (m *DnsConfigMutation) Where(ps ...predicate.DnsConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DnsConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DnsConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DnsConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DnsConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DnsConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DnsConfig).
func (m *DnsConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DnsConfigMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_by != nil {
		fields = append(fields, dnsconfig.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, dnsconfig.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, dnsconfig.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, dnsconfig.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, dnsconfig.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, dnsconfig.FieldTenantID)
	}
	if m.dns_servers != nil {
		fields = append(fields, dnsconfig.FieldDNSServers)
	}
	if m.timeout_ms != nil {
		fields = append(fields, dnsconfig.FieldTimeoutMs)
	}
	if m.use_system_dns_fallback != nil {
		fields = append(fields, dnsconfig.FieldUseSystemDNSFallback)
	}
	if m.reverse_dns_enabled != nil {
		fields = append(fields, dnsconfig.FieldReverseDNSEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DnsConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dnsconfig.FieldCreateBy:
		return m.CreateBy()
	case dnsconfig.FieldUpdateBy:
		return m.UpdateBy()
	case dnsconfig.FieldCreateTime:
		return m.CreateTime()
	case dnsconfig.FieldUpdateTime:
		return m.UpdateTime()
	case dnsconfig.FieldDeleteTime:
		return m.DeleteTime()
	case dnsconfig.FieldTenantID:
		return m.TenantID()
	case dnsconfig.FieldDNSServers:
		return m.DNSServers()
	case dnsconfig.FieldTimeoutMs:
		return m.TimeoutMs()
	case dnsconfig.FieldUseSystemDNSFallback:
		return m.UseSystemDNSFallback()
	case dnsconfig.FieldReverseDNSEnabled:
		return m.ReverseDNSEnabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DnsConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dnsconfig.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case dnsconfig.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case dnsconfig.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case dnsconfig.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case dnsconfig.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case dnsconfig.FieldTenantID:
		return m.OldTenantID(ctx)
	case dnsconfig.FieldDNSServers:
		return m.OldDNSServers(ctx)
	case dnsconfig.FieldTimeoutMs:
		return m.OldTimeoutMs(ctx)
	case dnsconfig.FieldUseSystemDNSFallback:
		return m.OldUseSystemDNSFallback(ctx)
	case dnsconfig.FieldReverseDNSEnabled:
		return m.OldReverseDNSEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown DnsConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DnsConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dnsconfig.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case dnsconfig.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case dnsconfig.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case dnsconfig.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case dnsconfig.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case dnsconfig.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dnsconfig.FieldDNSServers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSServers(v)
		return nil
	case dnsconfig.FieldTimeoutMs:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeoutMs(v)
		return nil
	case dnsconfig.FieldUseSystemDNSFallback:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseSystemDNSFallback(v)
		return nil
	case dnsconfig.FieldReverseDNSEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReverseDNSEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown DnsConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DnsConfigMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, dnsconfig.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, dnsconfig.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, dnsconfig.FieldTenantID)
	}
	if m.addtimeout_ms != nil {
		fields = append(fields, dnsconfig.FieldTimeoutMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DnsConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dnsconfig.FieldCreateBy:
		return m.AddedCreateBy()
	case dnsconfig.FieldUpdateBy:
		return m.AddedUpdateBy()
	case dnsconfig.FieldTenantID:
		return m.AddedTenantID()
	case dnsconfig.FieldTimeoutMs:
		return m.AddedTimeoutMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DnsConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dnsconfig.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case dnsconfig.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case dnsconfig.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case dnsconfig.FieldTimeoutMs:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeoutMs(v)
		return nil
	}
	return fmt.Errorf("unknown DnsConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DnsConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dnsconfig.FieldCreateBy) {
		fields = append(fields, dnsconfig.FieldCreateBy)
	}
	if m.FieldCleared(dnsconfig.FieldUpdateBy) {
		fields = append(fields, dnsconfig.FieldUpdateBy)
	}
	if m.FieldCleared(dnsconfig.FieldCreateTime) {
		fields = append(fields, dnsconfig.FieldCreateTime)
	}
	if m.FieldCleared(dnsconfig.FieldUpdateTime) {
		fields = append(fields, dnsconfig.FieldUpdateTime)
	}
	if m.FieldCleared(dnsconfig.FieldDeleteTime) {
		fields = append(fields, dnsconfig.FieldDeleteTime)
	}
	if m.FieldCleared(dnsconfig.FieldTenantID) {
		fields = append(fields, dnsconfig.FieldTenantID)
	}
	if m.FieldCleared(dnsconfig.FieldDNSServers) {
		fields = append(fields, dnsconfig.FieldDNSServers)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DnsConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DnsConfigMutation) ClearField(name string) error {
	switch name {
	case dnsconfig.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case dnsconfig.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case dnsconfig.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case dnsconfig.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case dnsconfig.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case dnsconfig.FieldTenantID:
		m.ClearTenantID()
		return nil
	case dnsconfig.FieldDNSServers:
		m.ClearDNSServers()
		return nil
	}
	return fmt.Errorf("unknown DnsConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DnsConfigMutation) ResetField(name string) error {
	switch name {
	case dnsconfig.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case dnsconfig.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case dnsconfig.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case dnsconfig.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case dnsconfig.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case dnsconfig.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dnsconfig.FieldDNSServers:
		m.ResetDNSServers()
		return nil
	case dnsconfig.FieldTimeoutMs:
		m.ResetTimeoutMs()
		return nil
	case dnsconfig.FieldUseSystemDNSFallback:
		m.ResetUseSystemDNSFallback()
		return nil
	case dnsconfig.FieldReverseDNSEnabled:
		m.ResetReverseDNSEnabled()
		return nil
	}
	return fmt.Errorf("unknown DnsConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DnsConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DnsConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DnsConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DnsConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DnsConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DnsConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DnsConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DnsConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DnsConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DnsConfig edge %s", name)
}

// HostGroupMutation represents an operation that mutates the HostGroup nodes in the graph.
type HostGroupMutation struct {
	config
	op             Op
	typ            string
	id             *string
	create_by      *uint32
	addcreate_by   *int32
	update_by      *uint32
	addupdate_by   *int32
	create_time    *time.Time
	update_time    *time.Time
	delete_time    *time.Time
	tenant_id      *uint32
	addtenant_id   *int32
	name           *string
	description    *string
	status         *int32
	addstatus      *int32
	tags           *string
	metadata       *string
	clearedFields  map[string]struct{}
	members        map[string]struct{}
	removedmembers map[string]struct{}
	clearedmembers bool
	done           bool
	oldValue       func(context.Context) (*HostGroup, error)
	predicates     []predicate.HostGroup
}

var _ ent.Mutation = (*HostGroupMutation)(nil)

// hostgroupOption allows management of the mutation configuration using functional options.
type hostgroupOption func(*HostGroupMutation)

// newHostGroupMutation creates new mutation for the HostGroup entity.
func newHostGroupMutation(c config, op Op, opts ...hostgroupOption) *HostGroupMutation {
	m := &HostGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeHostGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostGroupID sets the ID field of the mutation.
func withHostGroupID(id string) hostgroupOption {
	return func(m *HostGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *HostGroup
		)
		m.oldValue = func(ctx context.Context) (*HostGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HostGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHostGroup sets the old HostGroup of the mutation.
func withHostGroup(node *HostGroup) hostgroupOption {
	return func(m *HostGroupMutation) {
		m.oldValue = func(context.Context) (*HostGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HostGroup entities.
func (m *HostGroupMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostGroupMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostGroupMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HostGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *HostGroupMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *HostGroupMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *HostGroupMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *HostGroupMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *HostGroupMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[hostgroup.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *HostGroupMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[hostgroup.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *HostGroupMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, hostgroup.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *HostGroupMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *HostGroupMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *HostGroupMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *HostGroupMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *HostGroupMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[hostgroup.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *HostGroupMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[hostgroup.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *HostGroupMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, hostgroup.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *HostGroupMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *HostGroupMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *HostGroupMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[hostgroup.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *HostGroupMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[hostgroup.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *HostGroupMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, hostgroup.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *HostGroupMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *HostGroupMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *HostGroupMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[hostgroup.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *HostGroupMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[hostgroup.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *HostGroupMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, hostgroup.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *HostGroupMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *HostGroupMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *HostGroupMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[hostgroup.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *HostGroupMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[hostgroup.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *HostGroupMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, hostgroup.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *HostGroupMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *HostGroupMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *HostGroupMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *HostGroupMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *HostGroupMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[hostgroup.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *HostGroupMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[hostgroup.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *HostGroupMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, hostgroup.FieldTenantID)
}

// SetName sets the "name" field.
func (m *HostGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HostGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HostGroupMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *HostGroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HostGroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *HostGroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[hostgroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *HostGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[hostgroup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *HostGroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, hostgroup.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *HostGroupMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *HostGroupMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *HostGroupMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *HostGroupMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *HostGroupMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetTags sets the "tags" field.
func (m *HostGroupMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *HostGroupMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *HostGroupMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[hostgroup.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *HostGroupMutation) TagsCleared() bool {
	_, ok := m.clearedFields[hostgroup.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *HostGroupMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, hostgroup.FieldTags)
}

// SetMetadata sets the "metadata" field.
func (m *HostGroupMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *HostGroupMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *HostGroupMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[hostgroup.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *HostGroupMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[hostgroup.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *HostGroupMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, hostgroup.FieldMetadata)
}

// AddMemberIDs adds the "members" edge to the HostGroupMember entity by ids.
func (m *HostGroupMutation) AddMemberIDs(ids ...string) {
	if m.members == nil {
		m.members = make(map[string]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the HostGroupMember entity.
func (m *HostGroupMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the HostGroupMember entity was cleared.
func (m *HostGroupMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the HostGroupMember entity by IDs.
func (m *HostGroupMutation) RemoveMemberIDs(ids ...string) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the HostGroupMember entity.
func (m *HostGroupMutation) RemovedMembersIDs() (ids []string) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *HostGroupMutation) MembersIDs() (ids []string) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *HostGroupMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the HostGroupMutation builder.
func (m *HostGroupMutation) Where(ps ...predicate.HostGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HostGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HostGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HostGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HostGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HostGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HostGroup).
func (m *HostGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostGroupMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_by != nil {
		fields = append(fields, hostgroup.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, hostgroup.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, hostgroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, hostgroup.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, hostgroup.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, hostgroup.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, hostgroup.FieldName)
	}
	if m.description != nil {
		fields = append(fields, hostgroup.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, hostgroup.FieldStatus)
	}
	if m.tags != nil {
		fields = append(fields, hostgroup.FieldTags)
	}
	if m.metadata != nil {
		fields = append(fields, hostgroup.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hostgroup.FieldCreateBy:
		return m.CreateBy()
	case hostgroup.FieldUpdateBy:
		return m.UpdateBy()
	case hostgroup.FieldCreateTime:
		return m.CreateTime()
	case hostgroup.FieldUpdateTime:
		return m.UpdateTime()
	case hostgroup.FieldDeleteTime:
		return m.DeleteTime()
	case hostgroup.FieldTenantID:
		return m.TenantID()
	case hostgroup.FieldName:
		return m.Name()
	case hostgroup.FieldDescription:
		return m.Description()
	case hostgroup.FieldStatus:
		return m.Status()
	case hostgroup.FieldTags:
		return m.Tags()
	case hostgroup.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hostgroup.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case hostgroup.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case hostgroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case hostgroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case hostgroup.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case hostgroup.FieldTenantID:
		return m.OldTenantID(ctx)
	case hostgroup.FieldName:
		return m.OldName(ctx)
	case hostgroup.FieldDescription:
		return m.OldDescription(ctx)
	case hostgroup.FieldStatus:
		return m.OldStatus(ctx)
	case hostgroup.FieldTags:
		return m.OldTags(ctx)
	case hostgroup.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown HostGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hostgroup.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case hostgroup.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case hostgroup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case hostgroup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case hostgroup.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case hostgroup.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case hostgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hostgroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case hostgroup.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case hostgroup.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case hostgroup.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown HostGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostGroupMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, hostgroup.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, hostgroup.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, hostgroup.FieldTenantID)
	}
	if m.addstatus != nil {
		fields = append(fields, hostgroup.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hostgroup.FieldCreateBy:
		return m.AddedCreateBy()
	case hostgroup.FieldUpdateBy:
		return m.AddedUpdateBy()
	case hostgroup.FieldTenantID:
		return m.AddedTenantID()
	case hostgroup.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hostgroup.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case hostgroup.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case hostgroup.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case hostgroup.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown HostGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hostgroup.FieldCreateBy) {
		fields = append(fields, hostgroup.FieldCreateBy)
	}
	if m.FieldCleared(hostgroup.FieldUpdateBy) {
		fields = append(fields, hostgroup.FieldUpdateBy)
	}
	if m.FieldCleared(hostgroup.FieldCreateTime) {
		fields = append(fields, hostgroup.FieldCreateTime)
	}
	if m.FieldCleared(hostgroup.FieldUpdateTime) {
		fields = append(fields, hostgroup.FieldUpdateTime)
	}
	if m.FieldCleared(hostgroup.FieldDeleteTime) {
		fields = append(fields, hostgroup.FieldDeleteTime)
	}
	if m.FieldCleared(hostgroup.FieldTenantID) {
		fields = append(fields, hostgroup.FieldTenantID)
	}
	if m.FieldCleared(hostgroup.FieldDescription) {
		fields = append(fields, hostgroup.FieldDescription)
	}
	if m.FieldCleared(hostgroup.FieldTags) {
		fields = append(fields, hostgroup.FieldTags)
	}
	if m.FieldCleared(hostgroup.FieldMetadata) {
		fields = append(fields, hostgroup.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostGroupMutation) ClearField(name string) error {
	switch name {
	case hostgroup.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case hostgroup.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case hostgroup.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case hostgroup.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case hostgroup.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case hostgroup.FieldTenantID:
		m.ClearTenantID()
		return nil
	case hostgroup.FieldDescription:
		m.ClearDescription()
		return nil
	case hostgroup.FieldTags:
		m.ClearTags()
		return nil
	case hostgroup.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown HostGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostGroupMutation) ResetField(name string) error {
	switch name {
	case hostgroup.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case hostgroup.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case hostgroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case hostgroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case hostgroup.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case hostgroup.FieldTenantID:
		m.ResetTenantID()
		return nil
	case hostgroup.FieldName:
		m.ResetName()
		return nil
	case hostgroup.FieldDescription:
		m.ResetDescription()
		return nil
	case hostgroup.FieldStatus:
		m.ResetStatus()
		return nil
	case hostgroup.FieldTags:
		m.ResetTags()
		return nil
	case hostgroup.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown HostGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.members != nil {
		edges = append(edges, hostgroup.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hostgroup.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmembers != nil {
		edges = append(edges, hostgroup.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hostgroup.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmembers {
		edges = append(edges, hostgroup.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case hostgroup.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostGroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HostGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostGroupMutation) ResetEdge(name string) error {
	switch name {
	case hostgroup.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown HostGroup edge %s", name)
}

// HostGroupMemberMutation represents an operation that mutates the HostGroupMember nodes in the graph.
type HostGroupMemberMutation struct {
	config
	op            Op
	typ           string
	id            *string
	sequence      *int32
	addsequence   *int32
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	group         *string
	clearedgroup  bool
	device        *string
	cleareddevice bool
	done          bool
	oldValue      func(context.Context) (*HostGroupMember, error)
	predicates    []predicate.HostGroupMember
}

var _ ent.Mutation = (*HostGroupMemberMutation)(nil)

// hostgroupmemberOption allows management of the mutation configuration using functional options.
type hostgroupmemberOption func(*HostGroupMemberMutation)

// newHostGroupMemberMutation creates new mutation for the HostGroupMember entity.
func newHostGroupMemberMutation(c config, op Op, opts ...hostgroupmemberOption) *HostGroupMemberMutation {
	m := &HostGroupMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeHostGroupMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostGroupMemberID sets the ID field of the mutation.
func withHostGroupMemberID(id string) hostgroupmemberOption {
	return func(m *HostGroupMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *HostGroupMember
		)
		m.oldValue = func(ctx context.Context) (*HostGroupMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HostGroupMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHostGroupMember sets the old HostGroupMember of the mutation.
func withHostGroupMember(node *HostGroupMember) hostgroupmemberOption {
	return func(m *HostGroupMemberMutation) {
		m.oldValue = func(context.Context) (*HostGroupMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostGroupMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostGroupMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HostGroupMember entities.
func (m *HostGroupMemberMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostGroupMemberMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostGroupMemberMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HostGroupMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHostGroupID sets the "host_group_id" field.
func (m *HostGroupMemberMutation) SetHostGroupID(s string) {
	m.group = &s
}

// HostGroupID returns the value of the "host_group_id" field in the mutation.
func (m *HostGroupMemberMutation) HostGroupID() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldHostGroupID returns the old "host_group_id" field's value of the HostGroupMember entity.
// If the HostGroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMemberMutation) OldHostGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostGroupID: %w", err)
	}
	return oldValue.HostGroupID, nil
}

// ResetHostGroupID resets all changes to the "host_group_id" field.
func (m *HostGroupMemberMutation) ResetHostGroupID() {
	m.group = nil
}

// SetDeviceID sets the "device_id" field.
func (m *HostGroupMemberMutation) SetDeviceID(s string) {
	m.device = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *HostGroupMemberMutation) DeviceID() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the HostGroupMember entity.
// If the HostGroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMemberMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *HostGroupMemberMutation) ResetDeviceID() {
	m.device = nil
}

// SetSequence sets the "sequence" field.
func (m *HostGroupMemberMutation) SetSequence(i int32) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *HostGroupMemberMutation) Sequence() (r int32, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the HostGroupMember entity.
// If the HostGroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMemberMutation) OldSequence(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *HostGroupMemberMutation) AddSequence(i int32) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *HostGroupMemberMutation) AddedSequence() (r int32, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *HostGroupMemberMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetCreateTime sets the "create_time" field.
func (m *HostGroupMemberMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *HostGroupMemberMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the HostGroupMember entity.
// If the HostGroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMemberMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *HostGroupMemberMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[hostgroupmember.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *HostGroupMemberMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[hostgroupmember.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *HostGroupMemberMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, hostgroupmember.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *HostGroupMemberMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *HostGroupMemberMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the HostGroupMember entity.
// If the HostGroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMemberMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *HostGroupMemberMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[hostgroupmember.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *HostGroupMemberMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[hostgroupmember.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *HostGroupMemberMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, hostgroupmember.FieldUpdateTime)
}

// SetGroupID sets the "group" edge to the HostGroup entity by id.
func (m *HostGroupMemberMutation) SetGroupID(id string) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the HostGroup entity.
func (m *HostGroupMemberMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[hostgroupmember.FieldHostGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the HostGroup entity was cleared.
func (m *HostGroupMemberMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *HostGroupMemberMutation) GroupID() (id string, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *HostGroupMemberMutation) GroupIDs() (ids []string) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *HostGroupMemberMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *HostGroupMemberMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[hostgroupmember.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *HostGroupMemberMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *HostGroupMemberMutation) DeviceIDs() (ids []string) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *HostGroupMemberMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the HostGroupMemberMutation builder.
func (m *HostGroupMemberMutation) Where(ps ...predicate.HostGroupMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HostGroupMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HostGroupMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HostGroupMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HostGroupMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HostGroupMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HostGroupMember).
func (m *HostGroupMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostGroupMemberMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.group != nil {
		fields = append(fields, hostgroupmember.FieldHostGroupID)
	}
	if m.device != nil {
		fields = append(fields, hostgroupmember.FieldDeviceID)
	}
	if m.sequence != nil {
		fields = append(fields, hostgroupmember.FieldSequence)
	}
	if m.create_time != nil {
		fields = append(fields, hostgroupmember.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, hostgroupmember.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostGroupMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hostgroupmember.FieldHostGroupID:
		return m.HostGroupID()
	case hostgroupmember.FieldDeviceID:
		return m.DeviceID()
	case hostgroupmember.FieldSequence:
		return m.Sequence()
	case hostgroupmember.FieldCreateTime:
		return m.CreateTime()
	case hostgroupmember.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostGroupMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hostgroupmember.FieldHostGroupID:
		return m.OldHostGroupID(ctx)
	case hostgroupmember.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case hostgroupmember.FieldSequence:
		return m.OldSequence(ctx)
	case hostgroupmember.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case hostgroupmember.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown HostGroupMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostGroupMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hostgroupmember.FieldHostGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostGroupID(v)
		return nil
	case hostgroupmember.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case hostgroupmember.FieldSequence:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case hostgroupmember.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case hostgroupmember.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown HostGroupMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostGroupMemberMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, hostgroupmember.FieldSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostGroupMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hostgroupmember.FieldSequence:
		return m.AddedSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostGroupMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hostgroupmember.FieldSequence:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	}
	return fmt.Errorf("unknown HostGroupMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostGroupMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hostgroupmember.FieldCreateTime) {
		fields = append(fields, hostgroupmember.FieldCreateTime)
	}
	if m.FieldCleared(hostgroupmember.FieldUpdateTime) {
		fields = append(fields, hostgroupmember.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostGroupMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostGroupMemberMutation) ClearField(name string) error {
	switch name {
	case hostgroupmember.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case hostgroupmember.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown HostGroupMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostGroupMemberMutation) ResetField(name string) error {
	switch name {
	case hostgroupmember.FieldHostGroupID:
		m.ResetHostGroupID()
		return nil
	case hostgroupmember.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case hostgroupmember.FieldSequence:
		m.ResetSequence()
		return nil
	case hostgroupmember.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case hostgroupmember.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown HostGroupMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostGroupMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group != nil {
		edges = append(edges, hostgroupmember.EdgeGroup)
	}
	if m.device != nil {
		edges = append(edges, hostgroupmember.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostGroupMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hostgroupmember.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case hostgroupmember.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostGroupMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostGroupMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostGroupMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup {
		edges = append(edges, hostgroupmember.EdgeGroup)
	}
	if m.cleareddevice {
		edges = append(edges, hostgroupmember.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostGroupMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case hostgroupmember.EdgeGroup:
		return m.clearedgroup
	case hostgroupmember.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostGroupMemberMutation) ClearEdge(name string) error {
	switch name {
	case hostgroupmember.EdgeGroup:
		m.ClearGroup()
		return nil
	case hostgroupmember.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown HostGroupMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostGroupMemberMutation) ResetEdge(name string) error {
	switch name {
	case hostgroupmember.EdgeGroup:
		m.ResetGroup()
		return nil
	case hostgroupmember.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown HostGroupMember edge %s", name)
}

// IpAddressMutation represents an operation that mutates the IpAddress nodes in the graph.
type IpAddressMutation struct {
	config
	op              Op
	typ             string
	id              *string
	create_by       *uint32
	addcreate_by    *int32
	update_by       *uint32
	addupdate_by    *int32
	create_time     *time.Time
	update_time     *time.Time
	delete_time     *time.Time
	tenant_id       *uint32
	addtenant_id    *int32
	address         *string
	hostname        *string
	mac_address     *string
	description     *string
	interface_name  *string
	status          *int32
	addstatus       *int32
	address_type    *int32
	addaddress_type *int32
	is_primary      *bool
	ptr_record      *string
	has_reverse_dns *bool
	dns_name        *string
	owner           *string
	last_seen       *time.Time
	lease_expiry    *time.Time
	tags            *string
	metadata        *string
	note            *string
	clearedFields   map[string]struct{}
	subnet          *string
	clearedsubnet   bool
	device          *string
	cleareddevice   bool
	done            bool
	oldValue        func(context.Context) (*IpAddress, error)
	predicates      []predicate.IpAddress
}

var _ ent.Mutation = (*IpAddressMutation)(nil)

// ipaddressOption allows management of the mutation configuration using functional options.
type ipaddressOption func(*IpAddressMutation)

// newIpAddressMutation creates new mutation for the IpAddress entity.
func newIpAddressMutation(c config, op Op, opts ...ipaddressOption) *IpAddressMutation {
	m := &IpAddressMutation{
		config:        c,
		op:            op,
		typ:           TypeIpAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIpAddressID sets the ID field of the mutation.
func withIpAddressID(id string) ipaddressOption {
	return func(m *IpAddressMutation) {
		var (
			err   error
			once  sync.Once
			value *IpAddress
		)
		m.oldValue = func(ctx context.Context) (*IpAddress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IpAddress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIpAddress sets the old IpAddress of the mutation.
func withIpAddress(node *IpAddress) ipaddressOption {
	return func(m *IpAddressMutation) {
		m.oldValue = func(context.Context) (*IpAddress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IpAddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IpAddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IpAddress entities.
func (m *IpAddressMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IpAddressMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IpAddressMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IpAddress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *IpAddressMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *IpAddressMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *IpAddressMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *IpAddressMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *IpAddressMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[ipaddress.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *IpAddressMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *IpAddressMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, ipaddress.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *IpAddressMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *IpAddressMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *IpAddressMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *IpAddressMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *IpAddressMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[ipaddress.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *IpAddressMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *IpAddressMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, ipaddress.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *IpAddressMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *IpAddressMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *IpAddressMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[ipaddress.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *IpAddressMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *IpAddressMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, ipaddress.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *IpAddressMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *IpAddressMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *IpAddressMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[ipaddress.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *IpAddressMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *IpAddressMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, ipaddress.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *IpAddressMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *IpAddressMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *IpAddressMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[ipaddress.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *IpAddressMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *IpAddressMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, ipaddress.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *IpAddressMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IpAddressMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *IpAddressMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *IpAddressMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *IpAddressMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[ipaddress.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *IpAddressMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IpAddressMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, ipaddress.FieldTenantID)
}

// SetAddress sets the "address" field.
func (m *IpAddressMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *IpAddressMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *IpAddressMutation) ResetAddress() {
	m.address = nil
}

// SetSubnetID sets the "subnet_id" field.
func (m *IpAddressMutation) SetSubnetID(s string) {
	m.subnet = &s
}

// SubnetID returns the value of the "subnet_id" field in the mutation.
func (m *IpAddressMutation) SubnetID() (r string, exists bool) {
	v := m.subnet
	if v == nil {
		return
	}
	return *v, true
}

// OldSubnetID returns the old "subnet_id" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldSubnetID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubnetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubnetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubnetID: %w", err)
	}
	return oldValue.SubnetID, nil
}

// ResetSubnetID resets all changes to the "subnet_id" field.
func (m *IpAddressMutation) ResetSubnetID() {
	m.subnet = nil
}

// SetHostname sets the "hostname" field.
func (m *IpAddressMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *IpAddressMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ClearHostname clears the value of the "hostname" field.
func (m *IpAddressMutation) ClearHostname() {
	m.hostname = nil
	m.clearedFields[ipaddress.FieldHostname] = struct{}{}
}

// HostnameCleared returns if the "hostname" field was cleared in this mutation.
func (m *IpAddressMutation) HostnameCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldHostname]
	return ok
}

// ResetHostname resets all changes to the "hostname" field.
func (m *IpAddressMutation) ResetHostname() {
	m.hostname = nil
	delete(m.clearedFields, ipaddress.FieldHostname)
}

// SetMACAddress sets the "mac_address" field.
func (m *IpAddressMutation) SetMACAddress(s string) {
	m.mac_address = &s
}

// MACAddress returns the value of the "mac_address" field in the mutation.
func (m *IpAddressMutation) MACAddress() (r string, exists bool) {
	v := m.mac_address
	if v == nil {
		return
	}
	return *v, true
}

// OldMACAddress returns the old "mac_address" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldMACAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMACAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMACAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMACAddress: %w", err)
	}
	return oldValue.MACAddress, nil
}

// ClearMACAddress clears the value of the "mac_address" field.
func (m *IpAddressMutation) ClearMACAddress() {
	m.mac_address = nil
	m.clearedFields[ipaddress.FieldMACAddress] = struct{}{}
}

// MACAddressCleared returns if the "mac_address" field was cleared in this mutation.
func (m *IpAddressMutation) MACAddressCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldMACAddress]
	return ok
}

// ResetMACAddress resets all changes to the "mac_address" field.
func (m *IpAddressMutation) ResetMACAddress() {
	m.mac_address = nil
	delete(m.clearedFields, ipaddress.FieldMACAddress)
}

// SetDescription sets the "description" field.
func (m *IpAddressMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IpAddressMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IpAddressMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ipaddress.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IpAddressMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IpAddressMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ipaddress.FieldDescription)
}

// SetDeviceID sets the "device_id" field.
func (m *IpAddressMutation) SetDeviceID(s string) {
	m.device = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *IpAddressMutation) DeviceID() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ClearDeviceID clears the value of the "device_id" field.
func (m *IpAddressMutation) ClearDeviceID() {
	m.device = nil
	m.clearedFields[ipaddress.FieldDeviceID] = struct{}{}
}

// DeviceIDCleared returns if the "device_id" field was cleared in this mutation.
func (m *IpAddressMutation) DeviceIDCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldDeviceID]
	return ok
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *IpAddressMutation) ResetDeviceID() {
	m.device = nil
	delete(m.clearedFields, ipaddress.FieldDeviceID)
}

// SetInterfaceName sets the "interface_name" field.
func (m *IpAddressMutation) SetInterfaceName(s string) {
	m.interface_name = &s
}

// InterfaceName returns the value of the "interface_name" field in the mutation.
func (m *IpAddressMutation) InterfaceName() (r string, exists bool) {
	v := m.interface_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInterfaceName returns the old "interface_name" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldInterfaceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterfaceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterfaceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterfaceName: %w", err)
	}
	return oldValue.InterfaceName, nil
}

// ClearInterfaceName clears the value of the "interface_name" field.
func (m *IpAddressMutation) ClearInterfaceName() {
	m.interface_name = nil
	m.clearedFields[ipaddress.FieldInterfaceName] = struct{}{}
}

// InterfaceNameCleared returns if the "interface_name" field was cleared in this mutation.
func (m *IpAddressMutation) InterfaceNameCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldInterfaceName]
	return ok
}

// ResetInterfaceName resets all changes to the "interface_name" field.
func (m *IpAddressMutation) ResetInterfaceName() {
	m.interface_name = nil
	delete(m.clearedFields, ipaddress.FieldInterfaceName)
}

// SetStatus sets the "status" field.
func (m *IpAddressMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *IpAddressMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *IpAddressMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *IpAddressMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *IpAddressMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetAddressType sets the "address_type" field.
func (m *IpAddressMutation) SetAddressType(i int32) {
	m.address_type = &i
	m.addaddress_type = nil
}

// AddressType returns the value of the "address_type" field in the mutation.
func (m *IpAddressMutation) AddressType() (r int32, exists bool) {
	v := m.address_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressType returns the old "address_type" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldAddressType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressType: %w", err)
	}
	return oldValue.AddressType, nil
}

// AddAddressType adds i to the "address_type" field.
func (m *IpAddressMutation) AddAddressType(i int32) {
	if m.addaddress_type != nil {
		*m.addaddress_type += i
	} else {
		m.addaddress_type = &i
	}
}

// AddedAddressType returns the value that was added to the "address_type" field in this mutation.
func (m *IpAddressMutation) AddedAddressType() (r int32, exists bool) {
	v := m.addaddress_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetAddressType resets all changes to the "address_type" field.
func (m *IpAddressMutation) ResetAddressType() {
	m.address_type = nil
	m.addaddress_type = nil
}

// SetIsPrimary sets the "is_primary" field.
func (m *IpAddressMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *IpAddressMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldIsPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *IpAddressMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// SetPtrRecord sets the "ptr_record" field.
func (m *IpAddressMutation) SetPtrRecord(s string) {
	m.ptr_record = &s
}

// PtrRecord returns the value of the "ptr_record" field in the mutation.
func (m *IpAddressMutation) PtrRecord() (r string, exists bool) {
	v := m.ptr_record
	if v == nil {
		return
	}
	return *v, true
}

// OldPtrRecord returns the old "ptr_record" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldPtrRecord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPtrRecord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPtrRecord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPtrRecord: %w", err)
	}
	return oldValue.PtrRecord, nil
}

// ClearPtrRecord clears the value of the "ptr_record" field.
func (m *IpAddressMutation) ClearPtrRecord() {
	m.ptr_record = nil
	m.clearedFields[ipaddress.FieldPtrRecord] = struct{}{}
}

// PtrRecordCleared returns if the "ptr_record" field was cleared in this mutation.
func (m *IpAddressMutation) PtrRecordCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldPtrRecord]
	return ok
}

// ResetPtrRecord resets all changes to the "ptr_record" field.
func (m *IpAddressMutation) ResetPtrRecord() {
	m.ptr_record = nil
	delete(m.clearedFields, ipaddress.FieldPtrRecord)
}

// SetHasReverseDNS sets the "has_reverse_dns" field.
func (m *IpAddressMutation) SetHasReverseDNS(b bool) {
	m.has_reverse_dns = &b
}

// HasReverseDNS returns the value of the "has_reverse_dns" field in the mutation.
func (m *IpAddressMutation) HasReverseDNS() (r bool, exists bool) {
	v := m.has_reverse_dns
	if v == nil {
		return
	}
	return *v, true
}

// OldHasReverseDNS returns the old "has_reverse_dns" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldHasReverseDNS(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasReverseDNS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasReverseDNS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasReverseDNS: %w", err)
	}
	return oldValue.HasReverseDNS, nil
}

// ResetHasReverseDNS resets all changes to the "has_reverse_dns" field.
func (m *IpAddressMutation) ResetHasReverseDNS() {
	m.has_reverse_dns = nil
}

// SetDNSName sets the "dns_name" field.
func (m *IpAddressMutation) SetDNSName(s string) {
	m.dns_name = &s
}

// DNSName returns the value of the "dns_name" field in the mutation.
func (m *IpAddressMutation) DNSName() (r string, exists bool) {
	v := m.dns_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSName returns the old "dns_name" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldDNSName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSName: %w", err)
	}
	return oldValue.DNSName, nil
}

// ClearDNSName clears the value of the "dns_name" field.
func (m *IpAddressMutation) ClearDNSName() {
	m.dns_name = nil
	m.clearedFields[ipaddress.FieldDNSName] = struct{}{}
}

// DNSNameCleared returns if the "dns_name" field was cleared in this mutation.
func (m *IpAddressMutation) DNSNameCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldDNSName]
	return ok
}

// ResetDNSName resets all changes to the "dns_name" field.
func (m *IpAddressMutation) ResetDNSName() {
	m.dns_name = nil
	delete(m.clearedFields, ipaddress.FieldDNSName)
}

// SetOwner sets the "owner" field.
func (m *IpAddressMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *IpAddressMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ClearOwner clears the value of the "owner" field.
func (m *IpAddressMutation) ClearOwner() {
	m.owner = nil
	m.clearedFields[ipaddress.FieldOwner] = struct{}{}
}

// OwnerCleared returns if the "owner" field was cleared in this mutation.
func (m *IpAddressMutation) OwnerCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldOwner]
	return ok
}

// ResetOwner resets all changes to the "owner" field.
func (m *IpAddressMutation) ResetOwner() {
	m.owner = nil
	delete(m.clearedFields, ipaddress.FieldOwner)
}

// SetLastSeen sets the "last_seen" field.
func (m *IpAddressMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *IpAddressMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldLastSeen(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ClearLastSeen clears the value of the "last_seen" field.
func (m *IpAddressMutation) ClearLastSeen() {
	m.last_seen = nil
	m.clearedFields[ipaddress.FieldLastSeen] = struct{}{}
}

// LastSeenCleared returns if the "last_seen" field was cleared in this mutation.
func (m *IpAddressMutation) LastSeenCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldLastSeen]
	return ok
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *IpAddressMutation) ResetLastSeen() {
	m.last_seen = nil
	delete(m.clearedFields, ipaddress.FieldLastSeen)
}

// SetLeaseExpiry sets the "lease_expiry" field.
func (m *IpAddressMutation) SetLeaseExpiry(t time.Time) {
	m.lease_expiry = &t
}

// LeaseExpiry returns the value of the "lease_expiry" field in the mutation.
func (m *IpAddressMutation) LeaseExpiry() (r time.Time, exists bool) {
	v := m.lease_expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldLeaseExpiry returns the old "lease_expiry" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldLeaseExpiry(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeaseExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeaseExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeaseExpiry: %w", err)
	}
	return oldValue.LeaseExpiry, nil
}

// ClearLeaseExpiry clears the value of the "lease_expiry" field.
func (m *IpAddressMutation) ClearLeaseExpiry() {
	m.lease_expiry = nil
	m.clearedFields[ipaddress.FieldLeaseExpiry] = struct{}{}
}

// LeaseExpiryCleared returns if the "lease_expiry" field was cleared in this mutation.
func (m *IpAddressMutation) LeaseExpiryCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldLeaseExpiry]
	return ok
}

// ResetLeaseExpiry resets all changes to the "lease_expiry" field.
func (m *IpAddressMutation) ResetLeaseExpiry() {
	m.lease_expiry = nil
	delete(m.clearedFields, ipaddress.FieldLeaseExpiry)
}

// SetTags sets the "tags" field.
func (m *IpAddressMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *IpAddressMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *IpAddressMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[ipaddress.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *IpAddressMutation) TagsCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *IpAddressMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, ipaddress.FieldTags)
}

// SetMetadata sets the "metadata" field.
func (m *IpAddressMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *IpAddressMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *IpAddressMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[ipaddress.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *IpAddressMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *IpAddressMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, ipaddress.FieldMetadata)
}

// SetNote sets the "note" field.
func (m *IpAddressMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *IpAddressMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the IpAddress entity.
// If the IpAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpAddressMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *IpAddressMutation) ClearNote() {
	m.note = nil
	m.clearedFields[ipaddress.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *IpAddressMutation) NoteCleared() bool {
	_, ok := m.clearedFields[ipaddress.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *IpAddressMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, ipaddress.FieldNote)
}

// ClearSubnet clears the "subnet" edge to the Subnet entity.
func (m *IpAddressMutation) ClearSubnet() {
	m.clearedsubnet = true
	m.clearedFields[ipaddress.FieldSubnetID] = struct{}{}
}

// SubnetCleared reports if the "subnet" edge to the Subnet entity was cleared.
func (m *IpAddressMutation) SubnetCleared() bool {
	return m.clearedsubnet
}

// SubnetIDs returns the "subnet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubnetID instead. It exists only for internal usage by the builders.
func (m *IpAddressMutation) SubnetIDs() (ids []string) {
	if id := m.subnet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubnet resets all changes to the "subnet" edge.
func (m *IpAddressMutation) ResetSubnet() {
	m.subnet = nil
	m.clearedsubnet = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *IpAddressMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[ipaddress.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *IpAddressMutation) DeviceCleared() bool {
	return m.DeviceIDCleared() || m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *IpAddressMutation) DeviceIDs() (ids []string) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *IpAddressMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the IpAddressMutation builder.
func (m *IpAddressMutation) Where(ps ...predicate.IpAddress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IpAddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IpAddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IpAddress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IpAddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IpAddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IpAddress).
func (m *IpAddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IpAddressMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.create_by != nil {
		fields = append(fields, ipaddress.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, ipaddress.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, ipaddress.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, ipaddress.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, ipaddress.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, ipaddress.FieldTenantID)
	}
	if m.address != nil {
		fields = append(fields, ipaddress.FieldAddress)
	}
	if m.subnet != nil {
		fields = append(fields, ipaddress.FieldSubnetID)
	}
	if m.hostname != nil {
		fields = append(fields, ipaddress.FieldHostname)
	}
	if m.mac_address != nil {
		fields = append(fields, ipaddress.FieldMACAddress)
	}
	if m.description != nil {
		fields = append(fields, ipaddress.FieldDescription)
	}
	if m.device != nil {
		fields = append(fields, ipaddress.FieldDeviceID)
	}
	if m.interface_name != nil {
		fields = append(fields, ipaddress.FieldInterfaceName)
	}
	if m.status != nil {
		fields = append(fields, ipaddress.FieldStatus)
	}
	if m.address_type != nil {
		fields = append(fields, ipaddress.FieldAddressType)
	}
	if m.is_primary != nil {
		fields = append(fields, ipaddress.FieldIsPrimary)
	}
	if m.ptr_record != nil {
		fields = append(fields, ipaddress.FieldPtrRecord)
	}
	if m.has_reverse_dns != nil {
		fields = append(fields, ipaddress.FieldHasReverseDNS)
	}
	if m.dns_name != nil {
		fields = append(fields, ipaddress.FieldDNSName)
	}
	if m.owner != nil {
		fields = append(fields, ipaddress.FieldOwner)
	}
	if m.last_seen != nil {
		fields = append(fields, ipaddress.FieldLastSeen)
	}
	if m.lease_expiry != nil {
		fields = append(fields, ipaddress.FieldLeaseExpiry)
	}
	if m.tags != nil {
		fields = append(fields, ipaddress.FieldTags)
	}
	if m.metadata != nil {
		fields = append(fields, ipaddress.FieldMetadata)
	}
	if m.note != nil {
		fields = append(fields, ipaddress.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IpAddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ipaddress.FieldCreateBy:
		return m.CreateBy()
	case ipaddress.FieldUpdateBy:
		return m.UpdateBy()
	case ipaddress.FieldCreateTime:
		return m.CreateTime()
	case ipaddress.FieldUpdateTime:
		return m.UpdateTime()
	case ipaddress.FieldDeleteTime:
		return m.DeleteTime()
	case ipaddress.FieldTenantID:
		return m.TenantID()
	case ipaddress.FieldAddress:
		return m.Address()
	case ipaddress.FieldSubnetID:
		return m.SubnetID()
	case ipaddress.FieldHostname:
		return m.Hostname()
	case ipaddress.FieldMACAddress:
		return m.MACAddress()
	case ipaddress.FieldDescription:
		return m.Description()
	case ipaddress.FieldDeviceID:
		return m.DeviceID()
	case ipaddress.FieldInterfaceName:
		return m.InterfaceName()
	case ipaddress.FieldStatus:
		return m.Status()
	case ipaddress.FieldAddressType:
		return m.AddressType()
	case ipaddress.FieldIsPrimary:
		return m.IsPrimary()
	case ipaddress.FieldPtrRecord:
		return m.PtrRecord()
	case ipaddress.FieldHasReverseDNS:
		return m.HasReverseDNS()
	case ipaddress.FieldDNSName:
		return m.DNSName()
	case ipaddress.FieldOwner:
		return m.Owner()
	case ipaddress.FieldLastSeen:
		return m.LastSeen()
	case ipaddress.FieldLeaseExpiry:
		return m.LeaseExpiry()
	case ipaddress.FieldTags:
		return m.Tags()
	case ipaddress.FieldMetadata:
		return m.Metadata()
	case ipaddress.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IpAddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ipaddress.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case ipaddress.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case ipaddress.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case ipaddress.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case ipaddress.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case ipaddress.FieldTenantID:
		return m.OldTenantID(ctx)
	case ipaddress.FieldAddress:
		return m.OldAddress(ctx)
	case ipaddress.FieldSubnetID:
		return m.OldSubnetID(ctx)
	case ipaddress.FieldHostname:
		return m.OldHostname(ctx)
	case ipaddress.FieldMACAddress:
		return m.OldMACAddress(ctx)
	case ipaddress.FieldDescription:
		return m.OldDescription(ctx)
	case ipaddress.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case ipaddress.FieldInterfaceName:
		return m.OldInterfaceName(ctx)
	case ipaddress.FieldStatus:
		return m.OldStatus(ctx)
	case ipaddress.FieldAddressType:
		return m.OldAddressType(ctx)
	case ipaddress.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case ipaddress.FieldPtrRecord:
		return m.OldPtrRecord(ctx)
	case ipaddress.FieldHasReverseDNS:
		return m.OldHasReverseDNS(ctx)
	case ipaddress.FieldDNSName:
		return m.OldDNSName(ctx)
	case ipaddress.FieldOwner:
		return m.OldOwner(ctx)
	case ipaddress.FieldLastSeen:
		return m.OldLastSeen(ctx)
	case ipaddress.FieldLeaseExpiry:
		return m.OldLeaseExpiry(ctx)
	case ipaddress.FieldTags:
		return m.OldTags(ctx)
	case ipaddress.FieldMetadata:
		return m.OldMetadata(ctx)
	case ipaddress.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown IpAddress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IpAddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ipaddress.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case ipaddress.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case ipaddress.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case ipaddress.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case ipaddress.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case ipaddress.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ipaddress.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case ipaddress.FieldSubnetID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubnetID(v)
		return nil
	case ipaddress.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case ipaddress.FieldMACAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMACAddress(v)
		return nil
	case ipaddress.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ipaddress.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case ipaddress.FieldInterfaceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterfaceName(v)
		return nil
	case ipaddress.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ipaddress.FieldAddressType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressType(v)
		return nil
	case ipaddress.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case ipaddress.FieldPtrRecord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPtrRecord(v)
		return nil
	case ipaddress.FieldHasReverseDNS:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasReverseDNS(v)
		return nil
	case ipaddress.FieldDNSName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSName(v)
		return nil
	case ipaddress.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case ipaddress.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	case ipaddress.FieldLeaseExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeaseExpiry(v)
		return nil
	case ipaddress.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case ipaddress.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case ipaddress.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown IpAddress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IpAddressMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, ipaddress.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, ipaddress.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, ipaddress.FieldTenantID)
	}
	if m.addstatus != nil {
		fields = append(fields, ipaddress.FieldStatus)
	}
	if m.addaddress_type != nil {
		fields = append(fields, ipaddress.FieldAddressType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IpAddressMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ipaddress.FieldCreateBy:
		return m.AddedCreateBy()
	case ipaddress.FieldUpdateBy:
		return m.AddedUpdateBy()
	case ipaddress.FieldTenantID:
		return m.AddedTenantID()
	case ipaddress.FieldStatus:
		return m.AddedStatus()
	case ipaddress.FieldAddressType:
		return m.AddedAddressType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IpAddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ipaddress.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case ipaddress.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case ipaddress.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case ipaddress.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case ipaddress.FieldAddressType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAddressType(v)
		return nil
	}
	return fmt.Errorf("unknown IpAddress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IpAddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ipaddress.FieldCreateBy) {
		fields = append(fields, ipaddress.FieldCreateBy)
	}
	if m.FieldCleared(ipaddress.FieldUpdateBy) {
		fields = append(fields, ipaddress.FieldUpdateBy)
	}
	if m.FieldCleared(ipaddress.FieldCreateTime) {
		fields = append(fields, ipaddress.FieldCreateTime)
	}
	if m.FieldCleared(ipaddress.FieldUpdateTime) {
		fields = append(fields, ipaddress.FieldUpdateTime)
	}
	if m.FieldCleared(ipaddress.FieldDeleteTime) {
		fields = append(fields, ipaddress.FieldDeleteTime)
	}
	if m.FieldCleared(ipaddress.FieldTenantID) {
		fields = append(fields, ipaddress.FieldTenantID)
	}
	if m.FieldCleared(ipaddress.FieldHostname) {
		fields = append(fields, ipaddress.FieldHostname)
	}
	if m.FieldCleared(ipaddress.FieldMACAddress) {
		fields = append(fields, ipaddress.FieldMACAddress)
	}
	if m.FieldCleared(ipaddress.FieldDescription) {
		fields = append(fields, ipaddress.FieldDescription)
	}
	if m.FieldCleared(ipaddress.FieldDeviceID) {
		fields = append(fields, ipaddress.FieldDeviceID)
	}
	if m.FieldCleared(ipaddress.FieldInterfaceName) {
		fields = append(fields, ipaddress.FieldInterfaceName)
	}
	if m.FieldCleared(ipaddress.FieldPtrRecord) {
		fields = append(fields, ipaddress.FieldPtrRecord)
	}
	if m.FieldCleared(ipaddress.FieldDNSName) {
		fields = append(fields, ipaddress.FieldDNSName)
	}
	if m.FieldCleared(ipaddress.FieldOwner) {
		fields = append(fields, ipaddress.FieldOwner)
	}
	if m.FieldCleared(ipaddress.FieldLastSeen) {
		fields = append(fields, ipaddress.FieldLastSeen)
	}
	if m.FieldCleared(ipaddress.FieldLeaseExpiry) {
		fields = append(fields, ipaddress.FieldLeaseExpiry)
	}
	if m.FieldCleared(ipaddress.FieldTags) {
		fields = append(fields, ipaddress.FieldTags)
	}
	if m.FieldCleared(ipaddress.FieldMetadata) {
		fields = append(fields, ipaddress.FieldMetadata)
	}
	if m.FieldCleared(ipaddress.FieldNote) {
		fields = append(fields, ipaddress.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IpAddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IpAddressMutation) ClearField(name string) error {
	switch name {
	case ipaddress.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case ipaddress.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case ipaddress.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case ipaddress.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case ipaddress.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case ipaddress.FieldTenantID:
		m.ClearTenantID()
		return nil
	case ipaddress.FieldHostname:
		m.ClearHostname()
		return nil
	case ipaddress.FieldMACAddress:
		m.ClearMACAddress()
		return nil
	case ipaddress.FieldDescription:
		m.ClearDescription()
		return nil
	case ipaddress.FieldDeviceID:
		m.ClearDeviceID()
		return nil
	case ipaddress.FieldInterfaceName:
		m.ClearInterfaceName()
		return nil
	case ipaddress.FieldPtrRecord:
		m.ClearPtrRecord()
		return nil
	case ipaddress.FieldDNSName:
		m.ClearDNSName()
		return nil
	case ipaddress.FieldOwner:
		m.ClearOwner()
		return nil
	case ipaddress.FieldLastSeen:
		m.ClearLastSeen()
		return nil
	case ipaddress.FieldLeaseExpiry:
		m.ClearLeaseExpiry()
		return nil
	case ipaddress.FieldTags:
		m.ClearTags()
		return nil
	case ipaddress.FieldMetadata:
		m.ClearMetadata()
		return nil
	case ipaddress.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown IpAddress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IpAddressMutation) ResetField(name string) error {
	switch name {
	case ipaddress.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case ipaddress.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case ipaddress.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case ipaddress.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case ipaddress.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case ipaddress.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ipaddress.FieldAddress:
		m.ResetAddress()
		return nil
	case ipaddress.FieldSubnetID:
		m.ResetSubnetID()
		return nil
	case ipaddress.FieldHostname:
		m.ResetHostname()
		return nil
	case ipaddress.FieldMACAddress:
		m.ResetMACAddress()
		return nil
	case ipaddress.FieldDescription:
		m.ResetDescription()
		return nil
	case ipaddress.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case ipaddress.FieldInterfaceName:
		m.ResetInterfaceName()
		return nil
	case ipaddress.FieldStatus:
		m.ResetStatus()
		return nil
	case ipaddress.FieldAddressType:
		m.ResetAddressType()
		return nil
	case ipaddress.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case ipaddress.FieldPtrRecord:
		m.ResetPtrRecord()
		return nil
	case ipaddress.FieldHasReverseDNS:
		m.ResetHasReverseDNS()
		return nil
	case ipaddress.FieldDNSName:
		m.ResetDNSName()
		return nil
	case ipaddress.FieldOwner:
		m.ResetOwner()
		return nil
	case ipaddress.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	case ipaddress.FieldLeaseExpiry:
		m.ResetLeaseExpiry()
		return nil
	case ipaddress.FieldTags:
		m.ResetTags()
		return nil
	case ipaddress.FieldMetadata:
		m.ResetMetadata()
		return nil
	case ipaddress.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown IpAddress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IpAddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.subnet != nil {
		edges = append(edges, ipaddress.EdgeSubnet)
	}
	if m.device != nil {
		edges = append(edges, ipaddress.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IpAddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ipaddress.EdgeSubnet:
		if id := m.subnet; id != nil {
			return []ent.Value{*id}
		}
	case ipaddress.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IpAddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IpAddressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IpAddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsubnet {
		edges = append(edges, ipaddress.EdgeSubnet)
	}
	if m.cleareddevice {
		edges = append(edges, ipaddress.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IpAddressMutation) EdgeCleared(name string) bool {
	switch name {
	case ipaddress.EdgeSubnet:
		return m.clearedsubnet
	case ipaddress.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IpAddressMutation) ClearEdge(name string) error {
	switch name {
	case ipaddress.EdgeSubnet:
		m.ClearSubnet()
		return nil
	case ipaddress.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown IpAddress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IpAddressMutation) ResetEdge(name string) error {
	switch name {
	case ipaddress.EdgeSubnet:
		m.ResetSubnet()
		return nil
	case ipaddress.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown IpAddress edge %s", name)
}

// IpGroupMutation represents an operation that mutates the IpGroup nodes in the graph.
type IpGroupMutation struct {
	config
	op             Op
	typ            string
	id             *string
	create_by      *uint32
	addcreate_by   *int32
	update_by      *uint32
	addupdate_by   *int32
	create_time    *time.Time
	update_time    *time.Time
	delete_time    *time.Time
	tenant_id      *uint32
	addtenant_id   *int32
	name           *string
	description    *string
	status         *int32
	addstatus      *int32
	tags           *string
	metadata       *string
	clearedFields  map[string]struct{}
	members        map[string]struct{}
	removedmembers map[string]struct{}
	clearedmembers bool
	done           bool
	oldValue       func(context.Context) (*IpGroup, error)
	predicates     []predicate.IpGroup
}

var _ ent.Mutation = (*IpGroupMutation)(nil)

// ipgroupOption allows management of the mutation configuration using functional options.
type ipgroupOption func(*IpGroupMutation)

// newIpGroupMutation creates new mutation for the IpGroup entity.
func newIpGroupMutation(c config, op Op, opts ...ipgroupOption) *IpGroupMutation {
	m := &IpGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeIpGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIpGroupID sets the ID field of the mutation.
func withIpGroupID(id string) ipgroupOption {
	return func(m *IpGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *IpGroup
		)
		m.oldValue = func(ctx context.Context) (*IpGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IpGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIpGroup sets the old IpGroup of the mutation.
func withIpGroup(node *IpGroup) ipgroupOption {
	return func(m *IpGroupMutation) {
		m.oldValue = func(context.Context) (*IpGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IpGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IpGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IpGroup entities.
func (m *IpGroupMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IpGroupMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IpGroupMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IpGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *IpGroupMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *IpGroupMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the IpGroup entity.
// If the IpGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *IpGroupMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *IpGroupMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *IpGroupMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[ipgroup.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *IpGroupMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[ipgroup.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *IpGroupMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, ipgroup.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *IpGroupMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *IpGroupMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the IpGroup entity.
// If the IpGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *IpGroupMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *IpGroupMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *IpGroupMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[ipgroup.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *IpGroupMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[ipgroup.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *IpGroupMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, ipgroup.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *IpGroupMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *IpGroupMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the IpGroup entity.
// If the IpGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *IpGroupMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[ipgroup.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *IpGroupMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[ipgroup.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *IpGroupMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, ipgroup.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *IpGroupMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *IpGroupMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the IpGroup entity.
// If the IpGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *IpGroupMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[ipgroup.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *IpGroupMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[ipgroup.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *IpGroupMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, ipgroup.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *IpGroupMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *IpGroupMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the IpGroup entity.
// If the IpGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *IpGroupMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[ipgroup.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *IpGroupMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[ipgroup.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *IpGroupMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, ipgroup.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *IpGroupMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IpGroupMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IpGroup entity.
// If the IpGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *IpGroupMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *IpGroupMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *IpGroupMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[ipgroup.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *IpGroupMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[ipgroup.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IpGroupMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, ipgroup.FieldTenantID)
}

// SetName sets the "name" field.
func (m *IpGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IpGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IpGroup entity.
// If the IpGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IpGroupMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *IpGroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IpGroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IpGroup entity.
// If the IpGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IpGroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ipgroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IpGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ipgroup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IpGroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ipgroup.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *IpGroupMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *IpGroupMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the IpGroup entity.
// If the IpGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *IpGroupMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *IpGroupMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *IpGroupMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetTags sets the "tags" field.
func (m *IpGroupMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *IpGroupMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the IpGroup entity.
// If the IpGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *IpGroupMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[ipgroup.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *IpGroupMutation) TagsCleared() bool {
	_, ok := m.clearedFields[ipgroup.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *IpGroupMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, ipgroup.FieldTags)
}

// SetMetadata sets the "metadata" field.
func (m *IpGroupMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *IpGroupMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the IpGroup entity.
// If the IpGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *IpGroupMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[ipgroup.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *IpGroupMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[ipgroup.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *IpGroupMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, ipgroup.FieldMetadata)
}

// AddMemberIDs adds the "members" edge to the IpGroupMember entity by ids.
func (m *IpGroupMutation) AddMemberIDs(ids ...string) {
	if m.members == nil {
		m.members = make(map[string]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the IpGroupMember entity.
func (m *IpGroupMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the IpGroupMember entity was cleared.
func (m *IpGroupMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the IpGroupMember entity by IDs.
func (m *IpGroupMutation) RemoveMemberIDs(ids ...string) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the IpGroupMember entity.
func (m *IpGroupMutation) RemovedMembersIDs() (ids []string) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *IpGroupMutation) MembersIDs() (ids []string) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *IpGroupMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the IpGroupMutation builder.
func (m *IpGroupMutation) Where(ps ...predicate.IpGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IpGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IpGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IpGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IpGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IpGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IpGroup).
func (m *IpGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IpGroupMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_by != nil {
		fields = append(fields, ipgroup.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, ipgroup.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, ipgroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, ipgroup.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, ipgroup.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, ipgroup.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, ipgroup.FieldName)
	}
	if m.description != nil {
		fields = append(fields, ipgroup.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, ipgroup.FieldStatus)
	}
	if m.tags != nil {
		fields = append(fields, ipgroup.FieldTags)
	}
	if m.metadata != nil {
		fields = append(fields, ipgroup.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IpGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ipgroup.FieldCreateBy:
		return m.CreateBy()
	case ipgroup.FieldUpdateBy:
		return m.UpdateBy()
	case ipgroup.FieldCreateTime:
		return m.CreateTime()
	case ipgroup.FieldUpdateTime:
		return m.UpdateTime()
	case ipgroup.FieldDeleteTime:
		return m.DeleteTime()
	case ipgroup.FieldTenantID:
		return m.TenantID()
	case ipgroup.FieldName:
		return m.Name()
	case ipgroup.FieldDescription:
		return m.Description()
	case ipgroup.FieldStatus:
		return m.Status()
	case ipgroup.FieldTags:
		return m.Tags()
	case ipgroup.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IpGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ipgroup.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case ipgroup.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case ipgroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case ipgroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case ipgroup.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case ipgroup.FieldTenantID:
		return m.OldTenantID(ctx)
	case ipgroup.FieldName:
		return m.OldName(ctx)
	case ipgroup.FieldDescription:
		return m.OldDescription(ctx)
	case ipgroup.FieldStatus:
		return m.OldStatus(ctx)
	case ipgroup.FieldTags:
		return m.OldTags(ctx)
	case ipgroup.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown IpGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IpGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ipgroup.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case ipgroup.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case ipgroup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case ipgroup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case ipgroup.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case ipgroup.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ipgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ipgroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ipgroup.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ipgroup.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case ipgroup.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown IpGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IpGroupMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, ipgroup.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, ipgroup.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, ipgroup.FieldTenantID)
	}
	if m.addstatus != nil {
		fields = append(fields, ipgroup.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IpGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ipgroup.FieldCreateBy:
		return m.AddedCreateBy()
	case ipgroup.FieldUpdateBy:
		return m.AddedUpdateBy()
	case ipgroup.FieldTenantID:
		return m.AddedTenantID()
	case ipgroup.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IpGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ipgroup.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case ipgroup.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case ipgroup.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case ipgroup.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown IpGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IpGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ipgroup.FieldCreateBy) {
		fields = append(fields, ipgroup.FieldCreateBy)
	}
	if m.FieldCleared(ipgroup.FieldUpdateBy) {
		fields = append(fields, ipgroup.FieldUpdateBy)
	}
	if m.FieldCleared(ipgroup.FieldCreateTime) {
		fields = append(fields, ipgroup.FieldCreateTime)
	}
	if m.FieldCleared(ipgroup.FieldUpdateTime) {
		fields = append(fields, ipgroup.FieldUpdateTime)
	}
	if m.FieldCleared(ipgroup.FieldDeleteTime) {
		fields = append(fields, ipgroup.FieldDeleteTime)
	}
	if m.FieldCleared(ipgroup.FieldTenantID) {
		fields = append(fields, ipgroup.FieldTenantID)
	}
	if m.FieldCleared(ipgroup.FieldDescription) {
		fields = append(fields, ipgroup.FieldDescription)
	}
	if m.FieldCleared(ipgroup.FieldTags) {
		fields = append(fields, ipgroup.FieldTags)
	}
	if m.FieldCleared(ipgroup.FieldMetadata) {
		fields = append(fields, ipgroup.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IpGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IpGroupMutation) ClearField(name string) error {
	switch name {
	case ipgroup.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case ipgroup.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case ipgroup.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case ipgroup.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case ipgroup.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case ipgroup.FieldTenantID:
		m.ClearTenantID()
		return nil
	case ipgroup.FieldDescription:
		m.ClearDescription()
		return nil
	case ipgroup.FieldTags:
		m.ClearTags()
		return nil
	case ipgroup.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown IpGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IpGroupMutation) ResetField(name string) error {
	switch name {
	case ipgroup.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case ipgroup.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case ipgroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case ipgroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case ipgroup.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case ipgroup.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ipgroup.FieldName:
		m.ResetName()
		return nil
	case ipgroup.FieldDescription:
		m.ResetDescription()
		return nil
	case ipgroup.FieldStatus:
		m.ResetStatus()
		return nil
	case ipgroup.FieldTags:
		m.ResetTags()
		return nil
	case ipgroup.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown IpGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IpGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.members != nil {
		edges = append(edges, ipgroup.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IpGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ipgroup.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IpGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmembers != nil {
		edges = append(edges, ipgroup.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IpGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ipgroup.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IpGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmembers {
		edges = append(edges, ipgroup.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IpGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case ipgroup.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IpGroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown IpGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IpGroupMutation) ResetEdge(name string) error {
	switch name {
	case ipgroup.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown IpGroup edge %s", name)
}

// IpGroupMemberMutation represents an operation that mutates the IpGroupMember nodes in the graph.
type IpGroupMemberMutation struct {
	config
	op             Op
	typ            string
	id             *string
	member_type    *int32
	addmember_type *int32
	value          *string
	description    *string
	sequence       *int32
	addsequence    *int32
	create_time    *time.Time
	update_time    *time.Time
	clearedFields  map[string]struct{}
	group          *string
	clearedgroup   bool
	done           bool
	oldValue       func(context.Context) (*IpGroupMember, error)
	predicates     []predicate.IpGroupMember
}

var _ ent.Mutation = (*IpGroupMemberMutation)(nil)

// ipgroupmemberOption allows management of the mutation configuration using functional options.
type ipgroupmemberOption func(*IpGroupMemberMutation)

// newIpGroupMemberMutation creates new mutation for the IpGroupMember entity.
func newIpGroupMemberMutation(c config, op Op, opts ...ipgroupmemberOption) *IpGroupMemberMutation {
	m := &IpGroupMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeIpGroupMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIpGroupMemberID sets the ID field of the mutation.
func withIpGroupMemberID(id string) ipgroupmemberOption {
	return func(m *IpGroupMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *IpGroupMember
		)
		m.oldValue = func(ctx context.Context) (*IpGroupMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IpGroupMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIpGroupMember sets the old IpGroupMember of the mutation.
func withIpGroupMember(node *IpGroupMember) ipgroupmemberOption {
	return func(m *IpGroupMemberMutation) {
		m.oldValue = func(context.Context) (*IpGroupMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IpGroupMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IpGroupMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IpGroupMember entities.
func (m *IpGroupMemberMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IpGroupMemberMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IpGroupMemberMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IpGroupMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIPGroupID sets the "ip_group_id" field.
func (m *IpGroupMemberMutation) SetIPGroupID(s string) {
	m.group = &s
}

// IPGroupID returns the value of the "ip_group_id" field in the mutation.
func (m *IpGroupMemberMutation) IPGroupID() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldIPGroupID returns the old "ip_group_id" field's value of the IpGroupMember entity.
// If the IpGroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMemberMutation) OldIPGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPGroupID: %w", err)
	}
	return oldValue.IPGroupID, nil
}

// ResetIPGroupID resets all changes to the "ip_group_id" field.
func (m *IpGroupMemberMutation) ResetIPGroupID() {
	m.group = nil
}

// SetMemberType sets the "member_type" field.
func (m *IpGroupMemberMutation) SetMemberType(i int32) {
	m.member_type = &i
	m.addmember_type = nil
}

// MemberType returns the value of the "member_type" field in the mutation.
func (m *IpGroupMemberMutation) MemberType() (r int32, exists bool) {
	v := m.member_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberType returns the old "member_type" field's value of the IpGroupMember entity.
// If the IpGroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMemberMutation) OldMemberType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberType: %w", err)
	}
	return oldValue.MemberType, nil
}

// AddMemberType adds i to the "member_type" field.
func (m *IpGroupMemberMutation) AddMemberType(i int32) {
	if m.addmember_type != nil {
		*m.addmember_type += i
	} else {
		m.addmember_type = &i
	}
}

// AddedMemberType returns the value that was added to the "member_type" field in this mutation.
func (m *IpGroupMemberMutation) AddedMemberType() (r int32, exists bool) {
	v := m.addmember_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemberType resets all changes to the "member_type" field.
func (m *IpGroupMemberMutation) ResetMemberType() {
	m.member_type = nil
	m.addmember_type = nil
}

// SetValue sets the "value" field.
func (m *IpGroupMemberMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *IpGroupMemberMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the IpGroupMember entity.
// If the IpGroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMemberMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *IpGroupMemberMutation) ResetValue() {
	m.value = nil
}

// SetDescription sets the "description" field.
func (m *IpGroupMemberMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IpGroupMemberMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IpGroupMember entity.
// If the IpGroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMemberMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IpGroupMemberMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ipgroupmember.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IpGroupMemberMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ipgroupmember.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IpGroupMemberMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ipgroupmember.FieldDescription)
}

// SetSequence sets the "sequence" field.
func (m *IpGroupMemberMutation) SetSequence(i int32) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *IpGroupMemberMutation) Sequence() (r int32, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the IpGroupMember entity.
// If the IpGroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMemberMutation) OldSequence(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *IpGroupMemberMutation) AddSequence(i int32) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *IpGroupMemberMutation) AddedSequence() (r int32, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *IpGroupMemberMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetCreateTime sets the "create_time" field.
func (m *IpGroupMemberMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *IpGroupMemberMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the IpGroupMember entity.
// If the IpGroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMemberMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *IpGroupMemberMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[ipgroupmember.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *IpGroupMemberMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[ipgroupmember.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *IpGroupMemberMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, ipgroupmember.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *IpGroupMemberMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *IpGroupMemberMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the IpGroupMember entity.
// If the IpGroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpGroupMemberMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *IpGroupMemberMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[ipgroupmember.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *IpGroupMemberMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[ipgroupmember.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *IpGroupMemberMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, ipgroupmember.FieldUpdateTime)
}

// SetGroupID sets the "group" edge to the IpGroup entity by id.
func (m *IpGroupMemberMutation) SetGroupID(id string) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the IpGroup entity.
func (m *IpGroupMemberMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[ipgroupmember.FieldIPGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the IpGroup entity was cleared.
func (m *IpGroupMemberMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *IpGroupMemberMutation) GroupID() (id string, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *IpGroupMemberMutation) GroupIDs() (ids []string) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *IpGroupMemberMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the IpGroupMemberMutation builder.
func (m *IpGroupMemberMutation) Where(ps ...predicate.IpGroupMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IpGroupMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IpGroupMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IpGroupMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IpGroupMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IpGroupMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IpGroupMember).
func (m *IpGroupMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IpGroupMemberMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.group != nil {
		fields = append(fields, ipgroupmember.FieldIPGroupID)
	}
	if m.member_type != nil {
		fields = append(fields, ipgroupmember.FieldMemberType)
	}
	if m.value != nil {
		fields = append(fields, ipgroupmember.FieldValue)
	}
	if m.description != nil {
		fields = append(fields, ipgroupmember.FieldDescription)
	}
	if m.sequence != nil {
		fields = append(fields, ipgroupmember.FieldSequence)
	}
	if m.create_time != nil {
		fields = append(fields, ipgroupmember.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, ipgroupmember.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IpGroupMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ipgroupmember.FieldIPGroupID:
		return m.IPGroupID()
	case ipgroupmember.FieldMemberType:
		return m.MemberType()
	case ipgroupmember.FieldValue:
		return m.Value()
	case ipgroupmember.FieldDescription:
		return m.Description()
	case ipgroupmember.FieldSequence:
		return m.Sequence()
	case ipgroupmember.FieldCreateTime:
		return m.CreateTime()
	case ipgroupmember.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IpGroupMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ipgroupmember.FieldIPGroupID:
		return m.OldIPGroupID(ctx)
	case ipgroupmember.FieldMemberType:
		return m.OldMemberType(ctx)
	case ipgroupmember.FieldValue:
		return m.OldValue(ctx)
	case ipgroupmember.FieldDescription:
		return m.OldDescription(ctx)
	case ipgroupmember.FieldSequence:
		return m.OldSequence(ctx)
	case ipgroupmember.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case ipgroupmember.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown IpGroupMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IpGroupMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ipgroupmember.FieldIPGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPGroupID(v)
		return nil
	case ipgroupmember.FieldMemberType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberType(v)
		return nil
	case ipgroupmember.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case ipgroupmember.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ipgroupmember.FieldSequence:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case ipgroupmember.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case ipgroupmember.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown IpGroupMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IpGroupMemberMutation) AddedFields() []string {
	var fields []string
	if m.addmember_type != nil {
		fields = append(fields, ipgroupmember.FieldMemberType)
	}
	if m.addsequence != nil {
		fields = append(fields, ipgroupmember.FieldSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IpGroupMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ipgroupmember.FieldMemberType:
		return m.AddedMemberType()
	case ipgroupmember.FieldSequence:
		return m.AddedSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IpGroupMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ipgroupmember.FieldMemberType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberType(v)
		return nil
	case ipgroupmember.FieldSequence:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	}
	return fmt.Errorf("unknown IpGroupMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IpGroupMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ipgroupmember.FieldDescription) {
		fields = append(fields, ipgroupmember.FieldDescription)
	}
	if m.FieldCleared(ipgroupmember.FieldCreateTime) {
		fields = append(fields, ipgroupmember.FieldCreateTime)
	}
	if m.FieldCleared(ipgroupmember.FieldUpdateTime) {
		fields = append(fields, ipgroupmember.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IpGroupMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IpGroupMemberMutation) ClearField(name string) error {
	switch name {
	case ipgroupmember.FieldDescription:
		m.ClearDescription()
		return nil
	case ipgroupmember.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case ipgroupmember.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown IpGroupMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IpGroupMemberMutation) ResetField(name string) error {
	switch name {
	case ipgroupmember.FieldIPGroupID:
		m.ResetIPGroupID()
		return nil
	case ipgroupmember.FieldMemberType:
		m.ResetMemberType()
		return nil
	case ipgroupmember.FieldValue:
		m.ResetValue()
		return nil
	case ipgroupmember.FieldDescription:
		m.ResetDescription()
		return nil
	case ipgroupmember.FieldSequence:
		m.ResetSequence()
		return nil
	case ipgroupmember.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case ipgroupmember.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown IpGroupMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IpGroupMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.group != nil {
		edges = append(edges, ipgroupmember.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IpGroupMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ipgroupmember.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IpGroupMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IpGroupMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IpGroupMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgroup {
		edges = append(edges, ipgroupmember.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IpGroupMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case ipgroupmember.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IpGroupMemberMutation) ClearEdge(name string) error {
	switch name {
	case ipgroupmember.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown IpGroupMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IpGroupMemberMutation) ResetEdge(name string) error {
	switch name {
	case ipgroupmember.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown IpGroupMember edge %s", name)
}

// IpScanJobMutation represents an operation that mutates the IpScanJob nodes in the graph.
type IpScanJobMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	create_by          *uint32
	addcreate_by       *int32
	update_by          *uint32
	addupdate_by       *int32
	create_time        *time.Time
	update_time        *time.Time
	delete_time        *time.Time
	tenant_id          *uint32
	addtenant_id       *int32
	status             *ipscanjob.Status
	progress           *int32
	addprogress        *int32
	status_message     *string
	total_addresses    *int64
	addtotal_addresses *int64
	scanned_count      *int64
	addscanned_count   *int64
	alive_count        *int64
	addalive_count     *int64
	new_count          *int64
	addnew_count       *int64
	updated_count      *int64
	addupdated_count   *int64
	triggered_by       *ipscanjob.TriggeredBy
	retry_count        *int32
	addretry_count     *int32
	max_retries        *int32
	addmax_retries     *int32
	next_retry_at      *time.Time
	timeout_ms         *int32
	addtimeout_ms      *int32
	concurrency        *int32
	addconcurrency     *int32
	skip_reverse_dns   *bool
	tcp_probe_ports    *string
	started_at         *time.Time
	completed_at       *time.Time
	clearedFields      map[string]struct{}
	subnet             *string
	clearedsubnet      bool
	done               bool
	oldValue           func(context.Context) (*IpScanJob, error)
	predicates         []predicate.IpScanJob
}

var _ ent.Mutation = (*IpScanJobMutation)(nil)

// ipscanjobOption allows management of the mutation configuration using functional options.
type ipscanjobOption func(*IpScanJobMutation)

// newIpScanJobMutation creates new mutation for the IpScanJob entity.
func newIpScanJobMutation(c config, op Op, opts ...ipscanjobOption) *IpScanJobMutation {
	m := &IpScanJobMutation{
		config:        c,
		op:            op,
		typ:           TypeIpScanJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIpScanJobID sets the ID field of the mutation.
func withIpScanJobID(id string) ipscanjobOption {
	return func(m *IpScanJobMutation) {
		var (
			err   error
			once  sync.Once
			value *IpScanJob
		)
		m.oldValue = func(ctx context.Context) (*IpScanJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IpScanJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIpScanJob sets the old IpScanJob of the mutation.
func withIpScanJob(node *IpScanJob) ipscanjobOption {
	return func(m *IpScanJobMutation) {
		m.oldValue = func(context.Context) (*IpScanJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IpScanJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IpScanJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IpScanJob entities.
func (m *IpScanJobMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IpScanJobMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IpScanJobMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IpScanJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *IpScanJobMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *IpScanJobMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *IpScanJobMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *IpScanJobMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *IpScanJobMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[ipscanjob.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *IpScanJobMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[ipscanjob.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *IpScanJobMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, ipscanjob.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *IpScanJobMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *IpScanJobMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *IpScanJobMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *IpScanJobMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *IpScanJobMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[ipscanjob.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *IpScanJobMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[ipscanjob.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *IpScanJobMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, ipscanjob.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *IpScanJobMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *IpScanJobMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *IpScanJobMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[ipscanjob.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *IpScanJobMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[ipscanjob.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *IpScanJobMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, ipscanjob.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *IpScanJobMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *IpScanJobMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *IpScanJobMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[ipscanjob.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *IpScanJobMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[ipscanjob.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *IpScanJobMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, ipscanjob.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *IpScanJobMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *IpScanJobMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *IpScanJobMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[ipscanjob.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *IpScanJobMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[ipscanjob.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *IpScanJobMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, ipscanjob.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *IpScanJobMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IpScanJobMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *IpScanJobMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *IpScanJobMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *IpScanJobMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[ipscanjob.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *IpScanJobMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[ipscanjob.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IpScanJobMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, ipscanjob.FieldTenantID)
}

// SetSubnetID sets the "subnet_id" field.
func (m *IpScanJobMutation) SetSubnetID(s string) {
	m.subnet = &s
}

// SubnetID returns the value of the "subnet_id" field in the mutation.
func (m *IpScanJobMutation) SubnetID() (r string, exists bool) {
	v := m.subnet
	if v == nil {
		return
	}
	return *v, true
}

// OldSubnetID returns the old "subnet_id" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldSubnetID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubnetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubnetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubnetID: %w", err)
	}
	return oldValue.SubnetID, nil
}

// ResetSubnetID resets all changes to the "subnet_id" field.
func (m *IpScanJobMutation) ResetSubnetID() {
	m.subnet = nil
}

// SetStatus sets the "status" field.
func (m *IpScanJobMutation) SetStatus(i ipscanjob.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *IpScanJobMutation) Status() (r ipscanjob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldStatus(ctx context.Context) (v ipscanjob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IpScanJobMutation) ResetStatus() {
	m.status = nil
}

// SetProgress sets the "progress" field.
func (m *IpScanJobMutation) SetProgress(i int32) {
	m.progress = &i
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *IpScanJobMutation) Progress() (r int32, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldProgress(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds i to the "progress" field.
func (m *IpScanJobMutation) AddProgress(i int32) {
	if m.addprogress != nil {
		*m.addprogress += i
	} else {
		m.addprogress = &i
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *IpScanJobMutation) AddedProgress() (r int32, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress resets all changes to the "progress" field.
func (m *IpScanJobMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetStatusMessage sets the "status_message" field.
func (m *IpScanJobMutation) SetStatusMessage(s string) {
	m.status_message = &s
}

// StatusMessage returns the value of the "status_message" field in the mutation.
func (m *IpScanJobMutation) StatusMessage() (r string, exists bool) {
	v := m.status_message
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusMessage returns the old "status_message" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldStatusMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusMessage: %w", err)
	}
	return oldValue.StatusMessage, nil
}

// ClearStatusMessage clears the value of the "status_message" field.
func (m *IpScanJobMutation) ClearStatusMessage() {
	m.status_message = nil
	m.clearedFields[ipscanjob.FieldStatusMessage] = struct{}{}
}

// StatusMessageCleared returns if the "status_message" field was cleared in this mutation.
func (m *IpScanJobMutation) StatusMessageCleared() bool {
	_, ok := m.clearedFields[ipscanjob.FieldStatusMessage]
	return ok
}

// ResetStatusMessage resets all changes to the "status_message" field.
func (m *IpScanJobMutation) ResetStatusMessage() {
	m.status_message = nil
	delete(m.clearedFields, ipscanjob.FieldStatusMessage)
}

// SetTotalAddresses sets the "total_addresses" field.
func (m *IpScanJobMutation) SetTotalAddresses(i int64) {
	m.total_addresses = &i
	m.addtotal_addresses = nil
}

// TotalAddresses returns the value of the "total_addresses" field in the mutation.
func (m *IpScanJobMutation) TotalAddresses() (r int64, exists bool) {
	v := m.total_addresses
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAddresses returns the old "total_addresses" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldTotalAddresses(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAddresses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAddresses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAddresses: %w", err)
	}
	return oldValue.TotalAddresses, nil
}

// AddTotalAddresses adds i to the "total_addresses" field.
func (m *IpScanJobMutation) AddTotalAddresses(i int64) {
	if m.addtotal_addresses != nil {
		*m.addtotal_addresses += i
	} else {
		m.addtotal_addresses = &i
	}
}

// AddedTotalAddresses returns the value that was added to the "total_addresses" field in this mutation.
func (m *IpScanJobMutation) AddedTotalAddresses() (r int64, exists bool) {
	v := m.addtotal_addresses
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAddresses resets all changes to the "total_addresses" field.
func (m *IpScanJobMutation) ResetTotalAddresses() {
	m.total_addresses = nil
	m.addtotal_addresses = nil
}

// SetScannedCount sets the "scanned_count" field.
func (m *IpScanJobMutation) SetScannedCount(i int64) {
	m.scanned_count = &i
	m.addscanned_count = nil
}

// ScannedCount returns the value of the "scanned_count" field in the mutation.
func (m *IpScanJobMutation) ScannedCount() (r int64, exists bool) {
	v := m.scanned_count
	if v == nil {
		return
	}
	return *v, true
}

// OldScannedCount returns the old "scanned_count" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldScannedCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScannedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScannedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScannedCount: %w", err)
	}
	return oldValue.ScannedCount, nil
}

// AddScannedCount adds i to the "scanned_count" field.
func (m *IpScanJobMutation) AddScannedCount(i int64) {
	if m.addscanned_count != nil {
		*m.addscanned_count += i
	} else {
		m.addscanned_count = &i
	}
}

// AddedScannedCount returns the value that was added to the "scanned_count" field in this mutation.
func (m *IpScanJobMutation) AddedScannedCount() (r int64, exists bool) {
	v := m.addscanned_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetScannedCount resets all changes to the "scanned_count" field.
func (m *IpScanJobMutation) ResetScannedCount() {
	m.scanned_count = nil
	m.addscanned_count = nil
}

// SetAliveCount sets the "alive_count" field.
func (m *IpScanJobMutation) SetAliveCount(i int64) {
	m.alive_count = &i
	m.addalive_count = nil
}

// AliveCount returns the value of the "alive_count" field in the mutation.
func (m *IpScanJobMutation) AliveCount() (r int64, exists bool) {
	v := m.alive_count
	if v == nil {
		return
	}
	return *v, true
}

// OldAliveCount returns the old "alive_count" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldAliveCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAliveCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAliveCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAliveCount: %w", err)
	}
	return oldValue.AliveCount, nil
}

// AddAliveCount adds i to the "alive_count" field.
func (m *IpScanJobMutation) AddAliveCount(i int64) {
	if m.addalive_count != nil {
		*m.addalive_count += i
	} else {
		m.addalive_count = &i
	}
}

// AddedAliveCount returns the value that was added to the "alive_count" field in this mutation.
func (m *IpScanJobMutation) AddedAliveCount() (r int64, exists bool) {
	v := m.addalive_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetAliveCount resets all changes to the "alive_count" field.
func (m *IpScanJobMutation) ResetAliveCount() {
	m.alive_count = nil
	m.addalive_count = nil
}

// SetNewCount sets the "new_count" field.
func (m *IpScanJobMutation) SetNewCount(i int64) {
	m.new_count = &i
	m.addnew_count = nil
}

// NewCount returns the value of the "new_count" field in the mutation.
func (m *IpScanJobMutation) NewCount() (r int64, exists bool) {
	v := m.new_count
	if v == nil {
		return
	}
	return *v, true
}

// OldNewCount returns the old "new_count" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldNewCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewCount: %w", err)
	}
	return oldValue.NewCount, nil
}

// AddNewCount adds i to the "new_count" field.
func (m *IpScanJobMutation) AddNewCount(i int64) {
	if m.addnew_count != nil {
		*m.addnew_count += i
	} else {
		m.addnew_count = &i
	}
}

// AddedNewCount returns the value that was added to the "new_count" field in this mutation.
func (m *IpScanJobMutation) AddedNewCount() (r int64, exists bool) {
	v := m.addnew_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetNewCount resets all changes to the "new_count" field.
func (m *IpScanJobMutation) ResetNewCount() {
	m.new_count = nil
	m.addnew_count = nil
}

// SetUpdatedCount sets the "updated_count" field.
func (m *IpScanJobMutation) SetUpdatedCount(i int64) {
	m.updated_count = &i
	m.addupdated_count = nil
}

// UpdatedCount returns the value of the "updated_count" field in the mutation.
func (m *IpScanJobMutation) UpdatedCount() (r int64, exists bool) {
	v := m.updated_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedCount returns the old "updated_count" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldUpdatedCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedCount: %w", err)
	}
	return oldValue.UpdatedCount, nil
}

// AddUpdatedCount adds i to the "updated_count" field.
func (m *IpScanJobMutation) AddUpdatedCount(i int64) {
	if m.addupdated_count != nil {
		*m.addupdated_count += i
	} else {
		m.addupdated_count = &i
	}
}

// AddedUpdatedCount returns the value that was added to the "updated_count" field in this mutation.
func (m *IpScanJobMutation) AddedUpdatedCount() (r int64, exists bool) {
	v := m.addupdated_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedCount resets all changes to the "updated_count" field.
func (m *IpScanJobMutation) ResetUpdatedCount() {
	m.updated_count = nil
	m.addupdated_count = nil
}

// SetTriggeredBy sets the "triggered_by" field.
func (m *IpScanJobMutation) SetTriggeredBy(ib ipscanjob.TriggeredBy) {
	m.triggered_by = &ib
}

// TriggeredBy returns the value of the "triggered_by" field in the mutation.
func (m *IpScanJobMutation) TriggeredBy() (r ipscanjob.TriggeredBy, exists bool) {
	v := m.triggered_by
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggeredBy returns the old "triggered_by" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldTriggeredBy(ctx context.Context) (v ipscanjob.TriggeredBy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggeredBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggeredBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggeredBy: %w", err)
	}
	return oldValue.TriggeredBy, nil
}

// ResetTriggeredBy resets all changes to the "triggered_by" field.
func (m *IpScanJobMutation) ResetTriggeredBy() {
	m.triggered_by = nil
}

// SetRetryCount sets the "retry_count" field.
func (m *IpScanJobMutation) SetRetryCount(i int32) {
	m.retry_count = &i
	m.addretry_count = nil
}

// RetryCount returns the value of the "retry_count" field in the mutation.
func (m *IpScanJobMutation) RetryCount() (r int32, exists bool) {
	v := m.retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryCount returns the old "retry_count" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldRetryCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryCount: %w", err)
	}
	return oldValue.RetryCount, nil
}

// AddRetryCount adds i to the "retry_count" field.
func (m *IpScanJobMutation) AddRetryCount(i int32) {
	if m.addretry_count != nil {
		*m.addretry_count += i
	} else {
		m.addretry_count = &i
	}
}

// AddedRetryCount returns the value that was added to the "retry_count" field in this mutation.
func (m *IpScanJobMutation) AddedRetryCount() (r int32, exists bool) {
	v := m.addretry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetryCount resets all changes to the "retry_count" field.
func (m *IpScanJobMutation) ResetRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
}

// SetMaxRetries sets the "max_retries" field.
func (m *IpScanJobMutation) SetMaxRetries(i int32) {
	m.max_retries = &i
	m.addmax_retries = nil
}

// MaxRetries returns the value of the "max_retries" field in the mutation.
func (m *IpScanJobMutation) MaxRetries() (r int32, exists bool) {
	v := m.max_retries
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxRetries returns the old "max_retries" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldMaxRetries(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxRetries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxRetries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxRetries: %w", err)
	}
	return oldValue.MaxRetries, nil
}

// AddMaxRetries adds i to the "max_retries" field.
func (m *IpScanJobMutation) AddMaxRetries(i int32) {
	if m.addmax_retries != nil {
		*m.addmax_retries += i
	} else {
		m.addmax_retries = &i
	}
}

// AddedMaxRetries returns the value that was added to the "max_retries" field in this mutation.
func (m *IpScanJobMutation) AddedMaxRetries() (r int32, exists bool) {
	v := m.addmax_retries
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxRetries resets all changes to the "max_retries" field.
func (m *IpScanJobMutation) ResetMaxRetries() {
	m.max_retries = nil
	m.addmax_retries = nil
}

// SetNextRetryAt sets the "next_retry_at" field.
func (m *IpScanJobMutation) SetNextRetryAt(t time.Time) {
	m.next_retry_at = &t
}

// NextRetryAt returns the value of the "next_retry_at" field in the mutation.
func (m *IpScanJobMutation) NextRetryAt() (r time.Time, exists bool) {
	v := m.next_retry_at
	if v == nil {
		return
	}
	return *v, true
}

// OldNextRetryAt returns the old "next_retry_at" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldNextRetryAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextRetryAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextRetryAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextRetryAt: %w", err)
	}
	return oldValue.NextRetryAt, nil
}

// ClearNextRetryAt clears the value of the "next_retry_at" field.
func (m *IpScanJobMutation) ClearNextRetryAt() {
	m.next_retry_at = nil
	m.clearedFields[ipscanjob.FieldNextRetryAt] = struct{}{}
}

// NextRetryAtCleared returns if the "next_retry_at" field was cleared in this mutation.
func (m *IpScanJobMutation) NextRetryAtCleared() bool {
	_, ok := m.clearedFields[ipscanjob.FieldNextRetryAt]
	return ok
}

// ResetNextRetryAt resets all changes to the "next_retry_at" field.
func (m *IpScanJobMutation) ResetNextRetryAt() {
	m.next_retry_at = nil
	delete(m.clearedFields, ipscanjob.FieldNextRetryAt)
}

// SetTimeoutMs sets the "timeout_ms" field.
func (m *IpScanJobMutation) SetTimeoutMs(i int32) {
	m.timeout_ms = &i
	m.addtimeout_ms = nil
}

// TimeoutMs returns the value of the "timeout_ms" field in the mutation.
func (m *IpScanJobMutation) TimeoutMs() (r int32, exists bool) {
	v := m.timeout_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeoutMs returns the old "timeout_ms" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldTimeoutMs(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeoutMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeoutMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeoutMs: %w", err)
	}
	return oldValue.TimeoutMs, nil
}

// AddTimeoutMs adds i to the "timeout_ms" field.
func (m *IpScanJobMutation) AddTimeoutMs(i int32) {
	if m.addtimeout_ms != nil {
		*m.addtimeout_ms += i
	} else {
		m.addtimeout_ms = &i
	}
}

// AddedTimeoutMs returns the value that was added to the "timeout_ms" field in this mutation.
func (m *IpScanJobMutation) AddedTimeoutMs() (r int32, exists bool) {
	v := m.addtimeout_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeoutMs resets all changes to the "timeout_ms" field.
func (m *IpScanJobMutation) ResetTimeoutMs() {
	m.timeout_ms = nil
	m.addtimeout_ms = nil
}

// SetConcurrency sets the "concurrency" field.
func (m *IpScanJobMutation) SetConcurrency(i int32) {
	m.concurrency = &i
	m.addconcurrency = nil
}

// Concurrency returns the value of the "concurrency" field in the mutation.
func (m *IpScanJobMutation) Concurrency() (r int32, exists bool) {
	v := m.concurrency
	if v == nil {
		return
	}
	return *v, true
}

// OldConcurrency returns the old "concurrency" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldConcurrency(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConcurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConcurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConcurrency: %w", err)
	}
	return oldValue.Concurrency, nil
}

// AddConcurrency adds i to the "concurrency" field.
func (m *IpScanJobMutation) AddConcurrency(i int32) {
	if m.addconcurrency != nil {
		*m.addconcurrency += i
	} else {
		m.addconcurrency = &i
	}
}

// AddedConcurrency returns the value that was added to the "concurrency" field in this mutation.
func (m *IpScanJobMutation) AddedConcurrency() (r int32, exists bool) {
	v := m.addconcurrency
	if v == nil {
		return
	}
	return *v, true
}

// ResetConcurrency resets all changes to the "concurrency" field.
func (m *IpScanJobMutation) ResetConcurrency() {
	m.concurrency = nil
	m.addconcurrency = nil
}

// SetSkipReverseDNS sets the "skip_reverse_dns" field.
func (m *IpScanJobMutation) SetSkipReverseDNS(b bool) {
	m.skip_reverse_dns = &b
}

// SkipReverseDNS returns the value of the "skip_reverse_dns" field in the mutation.
func (m *IpScanJobMutation) SkipReverseDNS() (r bool, exists bool) {
	v := m.skip_reverse_dns
	if v == nil {
		return
	}
	return *v, true
}

// OldSkipReverseDNS returns the old "skip_reverse_dns" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldSkipReverseDNS(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkipReverseDNS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkipReverseDNS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkipReverseDNS: %w", err)
	}
	return oldValue.SkipReverseDNS, nil
}

// ResetSkipReverseDNS resets all changes to the "skip_reverse_dns" field.
func (m *IpScanJobMutation) ResetSkipReverseDNS() {
	m.skip_reverse_dns = nil
}

// SetTCPProbePorts sets the "tcp_probe_ports" field.
func (m *IpScanJobMutation) SetTCPProbePorts(s string) {
	m.tcp_probe_ports = &s
}

// TCPProbePorts returns the value of the "tcp_probe_ports" field in the mutation.
func (m *IpScanJobMutation) TCPProbePorts() (r string, exists bool) {
	v := m.tcp_probe_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldTCPProbePorts returns the old "tcp_probe_ports" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldTCPProbePorts(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTCPProbePorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTCPProbePorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTCPProbePorts: %w", err)
	}
	return oldValue.TCPProbePorts, nil
}

// ResetTCPProbePorts resets all changes to the "tcp_probe_ports" field.
func (m *IpScanJobMutation) ResetTCPProbePorts() {
	m.tcp_probe_ports = nil
}

// SetStartedAt sets the "started_at" field.
func (m *IpScanJobMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *IpScanJobMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *IpScanJobMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[ipscanjob.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *IpScanJobMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[ipscanjob.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *IpScanJobMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, ipscanjob.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *IpScanJobMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *IpScanJobMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the IpScanJob entity.
// If the IpScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IpScanJobMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *IpScanJobMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[ipscanjob.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *IpScanJobMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[ipscanjob.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *IpScanJobMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, ipscanjob.FieldCompletedAt)
}

// ClearSubnet clears the "subnet" edge to the Subnet entity.
func (m *IpScanJobMutation) ClearSubnet() {
	m.clearedsubnet = true
	m.clearedFields[ipscanjob.FieldSubnetID] = struct{}{}
}

// SubnetCleared reports if the "subnet" edge to the Subnet entity was cleared.
func (m *IpScanJobMutation) SubnetCleared() bool {
	return m.clearedsubnet
}

// SubnetIDs returns the "subnet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubnetID instead. It exists only for internal usage by the builders.
func (m *IpScanJobMutation) SubnetIDs() (ids []string) {
	if id := m.subnet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubnet resets all changes to the "subnet" edge.
func (m *IpScanJobMutation) ResetSubnet() {
	m.subnet = nil
	m.clearedsubnet = false
}

// Where appends a list predicates to the IpScanJobMutation builder.
func (m *IpScanJobMutation) Where(ps ...predicate.IpScanJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IpScanJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IpScanJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IpScanJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IpScanJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IpScanJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IpScanJob).
func (m *IpScanJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IpScanJobMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.create_by != nil {
		fields = append(fields, ipscanjob.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, ipscanjob.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, ipscanjob.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, ipscanjob.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, ipscanjob.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, ipscanjob.FieldTenantID)
	}
	if m.subnet != nil {
		fields = append(fields, ipscanjob.FieldSubnetID)
	}
	if m.status != nil {
		fields = append(fields, ipscanjob.FieldStatus)
	}
	if m.progress != nil {
		fields = append(fields, ipscanjob.FieldProgress)
	}
	if m.status_message != nil {
		fields = append(fields, ipscanjob.FieldStatusMessage)
	}
	if m.total_addresses != nil {
		fields = append(fields, ipscanjob.FieldTotalAddresses)
	}
	if m.scanned_count != nil {
		fields = append(fields, ipscanjob.FieldScannedCount)
	}
	if m.alive_count != nil {
		fields = append(fields, ipscanjob.FieldAliveCount)
	}
	if m.new_count != nil {
		fields = append(fields, ipscanjob.FieldNewCount)
	}
	if m.updated_count != nil {
		fields = append(fields, ipscanjob.FieldUpdatedCount)
	}
	if m.triggered_by != nil {
		fields = append(fields, ipscanjob.FieldTriggeredBy)
	}
	if m.retry_count != nil {
		fields = append(fields, ipscanjob.FieldRetryCount)
	}
	if m.max_retries != nil {
		fields = append(fields, ipscanjob.FieldMaxRetries)
	}
	if m.next_retry_at != nil {
		fields = append(fields, ipscanjob.FieldNextRetryAt)
	}
	if m.timeout_ms != nil {
		fields = append(fields, ipscanjob.FieldTimeoutMs)
	}
	if m.concurrency != nil {
		fields = append(fields, ipscanjob.FieldConcurrency)
	}
	if m.skip_reverse_dns != nil {
		fields = append(fields, ipscanjob.FieldSkipReverseDNS)
	}
	if m.tcp_probe_ports != nil {
		fields = append(fields, ipscanjob.FieldTCPProbePorts)
	}
	if m.started_at != nil {
		fields = append(fields, ipscanjob.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, ipscanjob.FieldCompletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IpScanJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ipscanjob.FieldCreateBy:
		return m.CreateBy()
	case ipscanjob.FieldUpdateBy:
		return m.UpdateBy()
	case ipscanjob.FieldCreateTime:
		return m.CreateTime()
	case ipscanjob.FieldUpdateTime:
		return m.UpdateTime()
	case ipscanjob.FieldDeleteTime:
		return m.DeleteTime()
	case ipscanjob.FieldTenantID:
		return m.TenantID()
	case ipscanjob.FieldSubnetID:
		return m.SubnetID()
	case ipscanjob.FieldStatus:
		return m.Status()
	case ipscanjob.FieldProgress:
		return m.Progress()
	case ipscanjob.FieldStatusMessage:
		return m.StatusMessage()
	case ipscanjob.FieldTotalAddresses:
		return m.TotalAddresses()
	case ipscanjob.FieldScannedCount:
		return m.ScannedCount()
	case ipscanjob.FieldAliveCount:
		return m.AliveCount()
	case ipscanjob.FieldNewCount:
		return m.NewCount()
	case ipscanjob.FieldUpdatedCount:
		return m.UpdatedCount()
	case ipscanjob.FieldTriggeredBy:
		return m.TriggeredBy()
	case ipscanjob.FieldRetryCount:
		return m.RetryCount()
	case ipscanjob.FieldMaxRetries:
		return m.MaxRetries()
	case ipscanjob.FieldNextRetryAt:
		return m.NextRetryAt()
	case ipscanjob.FieldTimeoutMs:
		return m.TimeoutMs()
	case ipscanjob.FieldConcurrency:
		return m.Concurrency()
	case ipscanjob.FieldSkipReverseDNS:
		return m.SkipReverseDNS()
	case ipscanjob.FieldTCPProbePorts:
		return m.TCPProbePorts()
	case ipscanjob.FieldStartedAt:
		return m.StartedAt()
	case ipscanjob.FieldCompletedAt:
		return m.CompletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IpScanJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ipscanjob.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case ipscanjob.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case ipscanjob.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case ipscanjob.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case ipscanjob.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case ipscanjob.FieldTenantID:
		return m.OldTenantID(ctx)
	case ipscanjob.FieldSubnetID:
		return m.OldSubnetID(ctx)
	case ipscanjob.FieldStatus:
		return m.OldStatus(ctx)
	case ipscanjob.FieldProgress:
		return m.OldProgress(ctx)
	case ipscanjob.FieldStatusMessage:
		return m.OldStatusMessage(ctx)
	case ipscanjob.FieldTotalAddresses:
		return m.OldTotalAddresses(ctx)
	case ipscanjob.FieldScannedCount:
		return m.OldScannedCount(ctx)
	case ipscanjob.FieldAliveCount:
		return m.OldAliveCount(ctx)
	case ipscanjob.FieldNewCount:
		return m.OldNewCount(ctx)
	case ipscanjob.FieldUpdatedCount:
		return m.OldUpdatedCount(ctx)
	case ipscanjob.FieldTriggeredBy:
		return m.OldTriggeredBy(ctx)
	case ipscanjob.FieldRetryCount:
		return m.OldRetryCount(ctx)
	case ipscanjob.FieldMaxRetries:
		return m.OldMaxRetries(ctx)
	case ipscanjob.FieldNextRetryAt:
		return m.OldNextRetryAt(ctx)
	case ipscanjob.FieldTimeoutMs:
		return m.OldTimeoutMs(ctx)
	case ipscanjob.FieldConcurrency:
		return m.OldConcurrency(ctx)
	case ipscanjob.FieldSkipReverseDNS:
		return m.OldSkipReverseDNS(ctx)
	case ipscanjob.FieldTCPProbePorts:
		return m.OldTCPProbePorts(ctx)
	case ipscanjob.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case ipscanjob.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IpScanJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IpScanJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ipscanjob.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case ipscanjob.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case ipscanjob.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case ipscanjob.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case ipscanjob.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case ipscanjob.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ipscanjob.FieldSubnetID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubnetID(v)
		return nil
	case ipscanjob.FieldStatus:
		v, ok := value.(ipscanjob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ipscanjob.FieldProgress:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case ipscanjob.FieldStatusMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusMessage(v)
		return nil
	case ipscanjob.FieldTotalAddresses:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAddresses(v)
		return nil
	case ipscanjob.FieldScannedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScannedCount(v)
		return nil
	case ipscanjob.FieldAliveCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAliveCount(v)
		return nil
	case ipscanjob.FieldNewCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewCount(v)
		return nil
	case ipscanjob.FieldUpdatedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedCount(v)
		return nil
	case ipscanjob.FieldTriggeredBy:
		v, ok := value.(ipscanjob.TriggeredBy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggeredBy(v)
		return nil
	case ipscanjob.FieldRetryCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryCount(v)
		return nil
	case ipscanjob.FieldMaxRetries:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxRetries(v)
		return nil
	case ipscanjob.FieldNextRetryAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextRetryAt(v)
		return nil
	case ipscanjob.FieldTimeoutMs:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeoutMs(v)
		return nil
	case ipscanjob.FieldConcurrency:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConcurrency(v)
		return nil
	case ipscanjob.FieldSkipReverseDNS:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkipReverseDNS(v)
		return nil
	case ipscanjob.FieldTCPProbePorts:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTCPProbePorts(v)
		return nil
	case ipscanjob.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case ipscanjob.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IpScanJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IpScanJobMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, ipscanjob.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, ipscanjob.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, ipscanjob.FieldTenantID)
	}
	if m.addprogress != nil {
		fields = append(fields, ipscanjob.FieldProgress)
	}
	if m.addtotal_addresses != nil {
		fields = append(fields, ipscanjob.FieldTotalAddresses)
	}
	if m.addscanned_count != nil {
		fields = append(fields, ipscanjob.FieldScannedCount)
	}
	if m.addalive_count != nil {
		fields = append(fields, ipscanjob.FieldAliveCount)
	}
	if m.addnew_count != nil {
		fields = append(fields, ipscanjob.FieldNewCount)
	}
	if m.addupdated_count != nil {
		fields = append(fields, ipscanjob.FieldUpdatedCount)
	}
	if m.addretry_count != nil {
		fields = append(fields, ipscanjob.FieldRetryCount)
	}
	if m.addmax_retries != nil {
		fields = append(fields, ipscanjob.FieldMaxRetries)
	}
	if m.addtimeout_ms != nil {
		fields = append(fields, ipscanjob.FieldTimeoutMs)
	}
	if m.addconcurrency != nil {
		fields = append(fields, ipscanjob.FieldConcurrency)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IpScanJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ipscanjob.FieldCreateBy:
		return m.AddedCreateBy()
	case ipscanjob.FieldUpdateBy:
		return m.AddedUpdateBy()
	case ipscanjob.FieldTenantID:
		return m.AddedTenantID()
	case ipscanjob.FieldProgress:
		return m.AddedProgress()
	case ipscanjob.FieldTotalAddresses:
		return m.AddedTotalAddresses()
	case ipscanjob.FieldScannedCount:
		return m.AddedScannedCount()
	case ipscanjob.FieldAliveCount:
		return m.AddedAliveCount()
	case ipscanjob.FieldNewCount:
		return m.AddedNewCount()
	case ipscanjob.FieldUpdatedCount:
		return m.AddedUpdatedCount()
	case ipscanjob.FieldRetryCount:
		return m.AddedRetryCount()
	case ipscanjob.FieldMaxRetries:
		return m.AddedMaxRetries()
	case ipscanjob.FieldTimeoutMs:
		return m.AddedTimeoutMs()
	case ipscanjob.FieldConcurrency:
		return m.AddedConcurrency()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IpScanJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ipscanjob.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case ipscanjob.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case ipscanjob.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case ipscanjob.FieldProgress:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	case ipscanjob.FieldTotalAddresses:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAddresses(v)
		return nil
	case ipscanjob.FieldScannedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScannedCount(v)
		return nil
	case ipscanjob.FieldAliveCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAliveCount(v)
		return nil
	case ipscanjob.FieldNewCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNewCount(v)
		return nil
	case ipscanjob.FieldUpdatedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedCount(v)
		return nil
	case ipscanjob.FieldRetryCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryCount(v)
		return nil
	case ipscanjob.FieldMaxRetries:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxRetries(v)
		return nil
	case ipscanjob.FieldTimeoutMs:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeoutMs(v)
		return nil
	case ipscanjob.FieldConcurrency:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConcurrency(v)
		return nil
	}
	return fmt.Errorf("unknown IpScanJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IpScanJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ipscanjob.FieldCreateBy) {
		fields = append(fields, ipscanjob.FieldCreateBy)
	}
	if m.FieldCleared(ipscanjob.FieldUpdateBy) {
		fields = append(fields, ipscanjob.FieldUpdateBy)
	}
	if m.FieldCleared(ipscanjob.FieldCreateTime) {
		fields = append(fields, ipscanjob.FieldCreateTime)
	}
	if m.FieldCleared(ipscanjob.FieldUpdateTime) {
		fields = append(fields, ipscanjob.FieldUpdateTime)
	}
	if m.FieldCleared(ipscanjob.FieldDeleteTime) {
		fields = append(fields, ipscanjob.FieldDeleteTime)
	}
	if m.FieldCleared(ipscanjob.FieldTenantID) {
		fields = append(fields, ipscanjob.FieldTenantID)
	}
	if m.FieldCleared(ipscanjob.FieldStatusMessage) {
		fields = append(fields, ipscanjob.FieldStatusMessage)
	}
	if m.FieldCleared(ipscanjob.FieldNextRetryAt) {
		fields = append(fields, ipscanjob.FieldNextRetryAt)
	}
	if m.FieldCleared(ipscanjob.FieldStartedAt) {
		fields = append(fields, ipscanjob.FieldStartedAt)
	}
	if m.FieldCleared(ipscanjob.FieldCompletedAt) {
		fields = append(fields, ipscanjob.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IpScanJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IpScanJobMutation) ClearField(name string) error {
	switch name {
	case ipscanjob.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case ipscanjob.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case ipscanjob.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case ipscanjob.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case ipscanjob.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case ipscanjob.FieldTenantID:
		m.ClearTenantID()
		return nil
	case ipscanjob.FieldStatusMessage:
		m.ClearStatusMessage()
		return nil
	case ipscanjob.FieldNextRetryAt:
		m.ClearNextRetryAt()
		return nil
	case ipscanjob.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case ipscanjob.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown IpScanJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IpScanJobMutation) ResetField(name string) error {
	switch name {
	case ipscanjob.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case ipscanjob.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case ipscanjob.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case ipscanjob.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case ipscanjob.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case ipscanjob.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ipscanjob.FieldSubnetID:
		m.ResetSubnetID()
		return nil
	case ipscanjob.FieldStatus:
		m.ResetStatus()
		return nil
	case ipscanjob.FieldProgress:
		m.ResetProgress()
		return nil
	case ipscanjob.FieldStatusMessage:
		m.ResetStatusMessage()
		return nil
	case ipscanjob.FieldTotalAddresses:
		m.ResetTotalAddresses()
		return nil
	case ipscanjob.FieldScannedCount:
		m.ResetScannedCount()
		return nil
	case ipscanjob.FieldAliveCount:
		m.ResetAliveCount()
		return nil
	case ipscanjob.FieldNewCount:
		m.ResetNewCount()
		return nil
	case ipscanjob.FieldUpdatedCount:
		m.ResetUpdatedCount()
		return nil
	case ipscanjob.FieldTriggeredBy:
		m.ResetTriggeredBy()
		return nil
	case ipscanjob.FieldRetryCount:
		m.ResetRetryCount()
		return nil
	case ipscanjob.FieldMaxRetries:
		m.ResetMaxRetries()
		return nil
	case ipscanjob.FieldNextRetryAt:
		m.ResetNextRetryAt()
		return nil
	case ipscanjob.FieldTimeoutMs:
		m.ResetTimeoutMs()
		return nil
	case ipscanjob.FieldConcurrency:
		m.ResetConcurrency()
		return nil
	case ipscanjob.FieldSkipReverseDNS:
		m.ResetSkipReverseDNS()
		return nil
	case ipscanjob.FieldTCPProbePorts:
		m.ResetTCPProbePorts()
		return nil
	case ipscanjob.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case ipscanjob.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown IpScanJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IpScanJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subnet != nil {
		edges = append(edges, ipscanjob.EdgeSubnet)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IpScanJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ipscanjob.EdgeSubnet:
		if id := m.subnet; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IpScanJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IpScanJobMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IpScanJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubnet {
		edges = append(edges, ipscanjob.EdgeSubnet)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IpScanJobMutation) EdgeCleared(name string) bool {
	switch name {
	case ipscanjob.EdgeSubnet:
		return m.clearedsubnet
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IpScanJobMutation) ClearEdge(name string) error {
	switch name {
	case ipscanjob.EdgeSubnet:
		m.ClearSubnet()
		return nil
	}
	return fmt.Errorf("unknown IpScanJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IpScanJobMutation) ResetEdge(name string) error {
	switch name {
	case ipscanjob.EdgeSubnet:
		m.ResetSubnet()
		return nil
	}
	return fmt.Errorf("unknown IpScanJob edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op               Op
	typ              string
	id               *string
	create_by        *uint32
	addcreate_by     *int32
	update_by        *uint32
	addupdate_by     *int32
	create_time      *time.Time
	update_time      *time.Time
	delete_time      *time.Time
	tenant_id        *uint32
	addtenant_id     *int32
	name             *string
	code             *string
	location_type    *int32
	addlocation_type *int32
	description      *string
	_path            *string
	address          *string
	city             *string
	state            *string
	country          *string
	postal_code      *string
	latitude         *float64
	addlatitude      *float64
	longitude        *float64
	addlongitude     *float64
	contact          *string
	phone            *string
	email            *string
	status           *int32
	addstatus        *int32
	tags             *string
	metadata         *string
	rack_size_u      *int32
	addrack_size_u   *int32
	clearedFields    map[string]struct{}
	parent           *string
	clearedparent    bool
	children         map[string]struct{}
	removedchildren  map[string]struct{}
	clearedchildren  bool
	subnets          map[string]struct{}
	removedsubnets   map[string]struct{}
	clearedsubnets   bool
	vlans            map[string]struct{}
	removedvlans     map[string]struct{}
	clearedvlans     bool
	devices          map[string]struct{}
	removeddevices   map[string]struct{}
	cleareddevices   bool
	done             bool
	oldValue         func(context.Context) (*Location, error)
	predicates       []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id string) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Location entities.
func (m *LocationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *LocationMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *LocationMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *LocationMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *LocationMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *LocationMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[location.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *LocationMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[location.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *LocationMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, location.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *LocationMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *LocationMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *LocationMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *LocationMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *LocationMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[location.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *LocationMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[location.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *LocationMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, location.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *LocationMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *LocationMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *LocationMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[location.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *LocationMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[location.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *LocationMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, location.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *LocationMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *LocationMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *LocationMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[location.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *LocationMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[location.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *LocationMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, location.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *LocationMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *LocationMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *LocationMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[location.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *LocationMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[location.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *LocationMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, location.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *LocationMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *LocationMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *LocationMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *LocationMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *LocationMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[location.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *LocationMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[location.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *LocationMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, location.FieldTenantID)
}

// SetName sets the "name" field.
func (m *LocationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LocationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LocationMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *LocationMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *LocationMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *LocationMutation) ClearCode() {
	m.code = nil
	m.clearedFields[location.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *LocationMutation) CodeCleared() bool {
	_, ok := m.clearedFields[location.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *LocationMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, location.FieldCode)
}

// SetLocationType sets the "location_type" field.
func (m *LocationMutation) SetLocationType(i int32) {
	m.location_type = &i
	m.addlocation_type = nil
}

// LocationType returns the value of the "location_type" field in the mutation.
func (m *LocationMutation) LocationType() (r int32, exists bool) {
	v := m.location_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationType returns the old "location_type" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLocationType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationType: %w", err)
	}
	return oldValue.LocationType, nil
}

// AddLocationType adds i to the "location_type" field.
func (m *LocationMutation) AddLocationType(i int32) {
	if m.addlocation_type != nil {
		*m.addlocation_type += i
	} else {
		m.addlocation_type = &i
	}
}

// AddedLocationType returns the value that was added to the "location_type" field in this mutation.
func (m *LocationMutation) AddedLocationType() (r int32, exists bool) {
	v := m.addlocation_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetLocationType resets all changes to the "location_type" field.
func (m *LocationMutation) ResetLocationType() {
	m.location_type = nil
	m.addlocation_type = nil
}

// SetDescription sets the "description" field.
func (m *LocationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LocationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LocationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[location.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LocationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[location.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LocationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, location.FieldDescription)
}

// SetParentID sets the "parent_id" field.
func (m *LocationMutation) SetParentID(s string) {
	m.parent = &s
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *LocationMutation) ParentID() (r string, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldParentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *LocationMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[location.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *LocationMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[location.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *LocationMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, location.FieldParentID)
}

// SetPath sets the "path" field.
func (m *LocationMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *LocationMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *LocationMutation) ClearPath() {
	m._path = nil
	m.clearedFields[location.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *LocationMutation) PathCleared() bool {
	_, ok := m.clearedFields[location.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *LocationMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, location.FieldPath)
}

// SetAddress sets the "address" field.
func (m *LocationMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *LocationMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *LocationMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[location.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *LocationMutation) AddressCleared() bool {
	_, ok := m.clearedFields[location.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *LocationMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, location.FieldAddress)
}

// SetCity sets the "city" field.
func (m *LocationMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *LocationMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *LocationMutation) ClearCity() {
	m.city = nil
	m.clearedFields[location.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *LocationMutation) CityCleared() bool {
	_, ok := m.clearedFields[location.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *LocationMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, location.FieldCity)
}

// SetState sets the "state" field.
func (m *LocationMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *LocationMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *LocationMutation) ClearState() {
	m.state = nil
	m.clearedFields[location.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *LocationMutation) StateCleared() bool {
	_, ok := m.clearedFields[location.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *LocationMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, location.FieldState)
}

// SetCountry sets the "country" field.
func (m *LocationMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *LocationMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *LocationMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[location.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *LocationMutation) CountryCleared() bool {
	_, ok := m.clearedFields[location.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *LocationMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, location.FieldCountry)
}

// SetPostalCode sets the "postal_code" field.
func (m *LocationMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *LocationMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "postal_code" field.
func (m *LocationMutation) ClearPostalCode() {
	m.postal_code = nil
	m.clearedFields[location.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "postal_code" field was cleared in this mutation.
func (m *LocationMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[location.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *LocationMutation) ResetPostalCode() {
	m.postal_code = nil
	delete(m.clearedFields, location.FieldPostalCode)
}

// SetLatitude sets the "latitude" field.
func (m *LocationMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *LocationMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLatitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *LocationMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *LocationMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *LocationMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[location.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *LocationMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[location.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *LocationMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, location.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *LocationMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *LocationMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLongitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *LocationMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *LocationMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *LocationMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[location.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *LocationMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[location.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *LocationMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, location.FieldLongitude)
}

// SetContact sets the "contact" field.
func (m *LocationMutation) SetContact(s string) {
	m.contact = &s
}

// Contact returns the value of the "contact" field in the mutation.
func (m *LocationMutation) Contact() (r string, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old "contact" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// ClearContact clears the value of the "contact" field.
func (m *LocationMutation) ClearContact() {
	m.contact = nil
	m.clearedFields[location.FieldContact] = struct{}{}
}

// ContactCleared returns if the "contact" field was cleared in this mutation.
func (m *LocationMutation) ContactCleared() bool {
	_, ok := m.clearedFields[location.FieldContact]
	return ok
}

// ResetContact resets all changes to the "contact" field.
func (m *LocationMutation) ResetContact() {
	m.contact = nil
	delete(m.clearedFields, location.FieldContact)
}

// SetPhone sets the "phone" field.
func (m *LocationMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *LocationMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *LocationMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[location.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *LocationMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[location.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *LocationMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, location.FieldPhone)
}

// SetEmail sets the "email" field.
func (m *LocationMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *LocationMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *LocationMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[location.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *LocationMutation) EmailCleared() bool {
	_, ok := m.clearedFields[location.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *LocationMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, location.FieldEmail)
}

// SetStatus sets the "status" field.
func (m *LocationMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *LocationMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *LocationMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *LocationMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *LocationMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetTags sets the "tags" field.
func (m *LocationMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *LocationMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *LocationMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[location.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *LocationMutation) TagsCleared() bool {
	_, ok := m.clearedFields[location.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *LocationMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, location.FieldTags)
}

// SetMetadata sets the "metadata" field.
func (m *LocationMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *LocationMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *LocationMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[location.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *LocationMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[location.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *LocationMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, location.FieldMetadata)
}

// SetRackSizeU sets the "rack_size_u" field.
func (m *LocationMutation) SetRackSizeU(i int32) {
	m.rack_size_u = &i
	m.addrack_size_u = nil
}

// RackSizeU returns the value of the "rack_size_u" field in the mutation.
func (m *LocationMutation) RackSizeU() (r int32, exists bool) {
	v := m.rack_size_u
	if v == nil {
		return
	}
	return *v, true
}

// OldRackSizeU returns the old "rack_size_u" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldRackSizeU(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRackSizeU is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRackSizeU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRackSizeU: %w", err)
	}
	return oldValue.RackSizeU, nil
}

// AddRackSizeU adds i to the "rack_size_u" field.
func (m *LocationMutation) AddRackSizeU(i int32) {
	if m.addrack_size_u != nil {
		*m.addrack_size_u += i
	} else {
		m.addrack_size_u = &i
	}
}

// AddedRackSizeU returns the value that was added to the "rack_size_u" field in this mutation.
func (m *LocationMutation) AddedRackSizeU() (r int32, exists bool) {
	v := m.addrack_size_u
	if v == nil {
		return
	}
	return *v, true
}

// ClearRackSizeU clears the value of the "rack_size_u" field.
func (m *LocationMutation) ClearRackSizeU() {
	m.rack_size_u = nil
	m.addrack_size_u = nil
	m.clearedFields[location.FieldRackSizeU] = struct{}{}
}

// RackSizeUCleared returns if the "rack_size_u" field was cleared in this mutation.
func (m *LocationMutation) RackSizeUCleared() bool {
	_, ok := m.clearedFields[location.FieldRackSizeU]
	return ok
}

// ResetRackSizeU resets all changes to the "rack_size_u" field.
func (m *LocationMutation) ResetRackSizeU() {
	m.rack_size_u = nil
	m.addrack_size_u = nil
	delete(m.clearedFields, location.FieldRackSizeU)
}

// ClearParent clears the "parent" edge to the Location entity.
func (m *LocationMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[location.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Location entity was cleared.
func (m *LocationMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) ParentIDs() (ids []string) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *LocationMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Location entity by ids.
func (m *LocationMutation) AddChildIDs(ids ...string) {
	if m.children == nil {
		m.children = make(map[string]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Location entity.
func (m *LocationMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Location entity was cleared.
func (m *LocationMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Location entity by IDs.
func (m *LocationMutation) RemoveChildIDs(ids ...string) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Location entity.
func (m *LocationMutation) RemovedChildrenIDs() (ids []string) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *LocationMutation) ChildrenIDs() (ids []string) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *LocationMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddSubnetIDs adds the "subnets" edge to the Subnet entity by ids.
func (m *LocationMutation) AddSubnetIDs(ids ...string) {
	if m.subnets == nil {
		m.subnets = make(map[string]struct{})
	}
	for i := range ids {
		m.subnets[ids[i]] = struct{}{}
	}
}

// ClearSubnets clears the "subnets" edge to the Subnet entity.
func (m *LocationMutation) ClearSubnets() {
	m.clearedsubnets = true
}

// SubnetsCleared reports if the "subnets" edge to the Subnet entity was cleared.
func (m *LocationMutation) SubnetsCleared() bool {
	return m.clearedsubnets
}

// RemoveSubnetIDs removes the "subnets" edge to the Subnet entity by IDs.
func (m *LocationMutation) RemoveSubnetIDs(ids ...string) {
	if m.removedsubnets == nil {
		m.removedsubnets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subnets, ids[i])
		m.removedsubnets[ids[i]] = struct{}{}
	}
}

// RemovedSubnets returns the removed IDs of the "subnets" edge to the Subnet entity.
func (m *LocationMutation) RemovedSubnetsIDs() (ids []string) {
	for id := range m.removedsubnets {
		ids = append(ids, id)
	}
	return
}

// SubnetsIDs returns the "subnets" edge IDs in the mutation.
func (m *LocationMutation) SubnetsIDs() (ids []string) {
	for id := range m.subnets {
		ids = append(ids, id)
	}
	return
}

// ResetSubnets resets all changes to the "subnets" edge.
func (m *LocationMutation) ResetSubnets() {
	m.subnets = nil
	m.clearedsubnets = false
	m.removedsubnets = nil
}

// AddVlanIDs adds the "vlans" edge to the Vlan entity by ids.
func (m *LocationMutation) AddVlanIDs(ids ...string) {
	if m.vlans == nil {
		m.vlans = make(map[string]struct{})
	}
	for i := range ids {
		m.vlans[ids[i]] = struct{}{}
	}
}

// ClearVlans clears the "vlans" edge to the Vlan entity.
func (m *LocationMutation) ClearVlans() {
	m.clearedvlans = true
}

// VlansCleared reports if the "vlans" edge to the Vlan entity was cleared.
func (m *LocationMutation) VlansCleared() bool {
	return m.clearedvlans
}

// RemoveVlanIDs removes the "vlans" edge to the Vlan entity by IDs.
func (m *LocationMutation) RemoveVlanIDs(ids ...string) {
	if m.removedvlans == nil {
		m.removedvlans = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.vlans, ids[i])
		m.removedvlans[ids[i]] = struct{}{}
	}
}

// RemovedVlans returns the removed IDs of the "vlans" edge to the Vlan entity.
func (m *LocationMutation) RemovedVlansIDs() (ids []string) {
	for id := range m.removedvlans {
		ids = append(ids, id)
	}
	return
}

// VlansIDs returns the "vlans" edge IDs in the mutation.
func (m *LocationMutation) VlansIDs() (ids []string) {
	for id := range m.vlans {
		ids = append(ids, id)
	}
	return
}

// ResetVlans resets all changes to the "vlans" edge.
func (m *LocationMutation) ResetVlans() {
	m.vlans = nil
	m.clearedvlans = false
	m.removedvlans = nil
}

// AddDeviceIDs adds the "devices" edge to the Device entity by ids.
func (m *LocationMutation) AddDeviceIDs(ids ...string) {
	if m.devices == nil {
		m.devices = make(map[string]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the Device entity.
func (m *LocationMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the Device entity was cleared.
func (m *LocationMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the Device entity by IDs.
func (m *LocationMutation) RemoveDeviceIDs(ids ...string) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the Device entity.
func (m *LocationMutation) RemovedDevicesIDs() (ids []string) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *LocationMutation) DevicesIDs() (ids []string) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *LocationMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.create_by != nil {
		fields = append(fields, location.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, location.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, location.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, location.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, location.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, location.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, location.FieldName)
	}
	if m.code != nil {
		fields = append(fields, location.FieldCode)
	}
	if m.location_type != nil {
		fields = append(fields, location.FieldLocationType)
	}
	if m.description != nil {
		fields = append(fields, location.FieldDescription)
	}
	if m.parent != nil {
		fields = append(fields, location.FieldParentID)
	}
	if m._path != nil {
		fields = append(fields, location.FieldPath)
	}
	if m.address != nil {
		fields = append(fields, location.FieldAddress)
	}
	if m.city != nil {
		fields = append(fields, location.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, location.FieldState)
	}
	if m.country != nil {
		fields = append(fields, location.FieldCountry)
	}
	if m.postal_code != nil {
		fields = append(fields, location.FieldPostalCode)
	}
	if m.latitude != nil {
		fields = append(fields, location.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, location.FieldLongitude)
	}
	if m.contact != nil {
		fields = append(fields, location.FieldContact)
	}
	if m.phone != nil {
		fields = append(fields, location.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, location.FieldEmail)
	}
	if m.status != nil {
		fields = append(fields, location.FieldStatus)
	}
	if m.tags != nil {
		fields = append(fields, location.FieldTags)
	}
	if m.metadata != nil {
		fields = append(fields, location.FieldMetadata)
	}
	if m.rack_size_u != nil {
		fields = append(fields, location.FieldRackSizeU)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldCreateBy:
		return m.CreateBy()
	case location.FieldUpdateBy:
		return m.UpdateBy()
	case location.FieldCreateTime:
		return m.CreateTime()
	case location.FieldUpdateTime:
		return m.UpdateTime()
	case location.FieldDeleteTime:
		return m.DeleteTime()
	case location.FieldTenantID:
		return m.TenantID()
	case location.FieldName:
		return m.Name()
	case location.FieldCode:
		return m.Code()
	case location.FieldLocationType:
		return m.LocationType()
	case location.FieldDescription:
		return m.Description()
	case location.FieldParentID:
		return m.ParentID()
	case location.FieldPath:
		return m.Path()
	case location.FieldAddress:
		return m.Address()
	case location.FieldCity:
		return m.City()
	case location.FieldState:
		return m.State()
	case location.FieldCountry:
		return m.Country()
	case location.FieldPostalCode:
		return m.PostalCode()
	case location.FieldLatitude:
		return m.Latitude()
	case location.FieldLongitude:
		return m.Longitude()
	case location.FieldContact:
		return m.Contact()
	case location.FieldPhone:
		return m.Phone()
	case location.FieldEmail:
		return m.Email()
	case location.FieldStatus:
		return m.Status()
	case location.FieldTags:
		return m.Tags()
	case location.FieldMetadata:
		return m.Metadata()
	case location.FieldRackSizeU:
		return m.RackSizeU()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case location.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case location.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case location.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case location.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case location.FieldTenantID:
		return m.OldTenantID(ctx)
	case location.FieldName:
		return m.OldName(ctx)
	case location.FieldCode:
		return m.OldCode(ctx)
	case location.FieldLocationType:
		return m.OldLocationType(ctx)
	case location.FieldDescription:
		return m.OldDescription(ctx)
	case location.FieldParentID:
		return m.OldParentID(ctx)
	case location.FieldPath:
		return m.OldPath(ctx)
	case location.FieldAddress:
		return m.OldAddress(ctx)
	case location.FieldCity:
		return m.OldCity(ctx)
	case location.FieldState:
		return m.OldState(ctx)
	case location.FieldCountry:
		return m.OldCountry(ctx)
	case location.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case location.FieldLatitude:
		return m.OldLatitude(ctx)
	case location.FieldLongitude:
		return m.OldLongitude(ctx)
	case location.FieldContact:
		return m.OldContact(ctx)
	case location.FieldPhone:
		return m.OldPhone(ctx)
	case location.FieldEmail:
		return m.OldEmail(ctx)
	case location.FieldStatus:
		return m.OldStatus(ctx)
	case location.FieldTags:
		return m.OldTags(ctx)
	case location.FieldMetadata:
		return m.OldMetadata(ctx)
	case location.FieldRackSizeU:
		return m.OldRackSizeU(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case location.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case location.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case location.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case location.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case location.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case location.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case location.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case location.FieldLocationType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationType(v)
		return nil
	case location.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case location.FieldParentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case location.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case location.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case location.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case location.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case location.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case location.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case location.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case location.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case location.FieldContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case location.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case location.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case location.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case location.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case location.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case location.FieldRackSizeU:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRackSizeU(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, location.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, location.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, location.FieldTenantID)
	}
	if m.addlocation_type != nil {
		fields = append(fields, location.FieldLocationType)
	}
	if m.addlatitude != nil {
		fields = append(fields, location.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, location.FieldLongitude)
	}
	if m.addstatus != nil {
		fields = append(fields, location.FieldStatus)
	}
	if m.addrack_size_u != nil {
		fields = append(fields, location.FieldRackSizeU)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case location.FieldCreateBy:
		return m.AddedCreateBy()
	case location.FieldUpdateBy:
		return m.AddedUpdateBy()
	case location.FieldTenantID:
		return m.AddedTenantID()
	case location.FieldLocationType:
		return m.AddedLocationType()
	case location.FieldLatitude:
		return m.AddedLatitude()
	case location.FieldLongitude:
		return m.AddedLongitude()
	case location.FieldStatus:
		return m.AddedStatus()
	case location.FieldRackSizeU:
		return m.AddedRackSizeU()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case location.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case location.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case location.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case location.FieldLocationType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationType(v)
		return nil
	case location.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case location.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case location.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case location.FieldRackSizeU:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRackSizeU(v)
		return nil
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(location.FieldCreateBy) {
		fields = append(fields, location.FieldCreateBy)
	}
	if m.FieldCleared(location.FieldUpdateBy) {
		fields = append(fields, location.FieldUpdateBy)
	}
	if m.FieldCleared(location.FieldCreateTime) {
		fields = append(fields, location.FieldCreateTime)
	}
	if m.FieldCleared(location.FieldUpdateTime) {
		fields = append(fields, location.FieldUpdateTime)
	}
	if m.FieldCleared(location.FieldDeleteTime) {
		fields = append(fields, location.FieldDeleteTime)
	}
	if m.FieldCleared(location.FieldTenantID) {
		fields = append(fields, location.FieldTenantID)
	}
	if m.FieldCleared(location.FieldCode) {
		fields = append(fields, location.FieldCode)
	}
	if m.FieldCleared(location.FieldDescription) {
		fields = append(fields, location.FieldDescription)
	}
	if m.FieldCleared(location.FieldParentID) {
		fields = append(fields, location.FieldParentID)
	}
	if m.FieldCleared(location.FieldPath) {
		fields = append(fields, location.FieldPath)
	}
	if m.FieldCleared(location.FieldAddress) {
		fields = append(fields, location.FieldAddress)
	}
	if m.FieldCleared(location.FieldCity) {
		fields = append(fields, location.FieldCity)
	}
	if m.FieldCleared(location.FieldState) {
		fields = append(fields, location.FieldState)
	}
	if m.FieldCleared(location.FieldCountry) {
		fields = append(fields, location.FieldCountry)
	}
	if m.FieldCleared(location.FieldPostalCode) {
		fields = append(fields, location.FieldPostalCode)
	}
	if m.FieldCleared(location.FieldLatitude) {
		fields = append(fields, location.FieldLatitude)
	}
	if m.FieldCleared(location.FieldLongitude) {
		fields = append(fields, location.FieldLongitude)
	}
	if m.FieldCleared(location.FieldContact) {
		fields = append(fields, location.FieldContact)
	}
	if m.FieldCleared(location.FieldPhone) {
		fields = append(fields, location.FieldPhone)
	}
	if m.FieldCleared(location.FieldEmail) {
		fields = append(fields, location.FieldEmail)
	}
	if m.FieldCleared(location.FieldTags) {
		fields = append(fields, location.FieldTags)
	}
	if m.FieldCleared(location.FieldMetadata) {
		fields = append(fields, location.FieldMetadata)
	}
	if m.FieldCleared(location.FieldRackSizeU) {
		fields = append(fields, location.FieldRackSizeU)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	switch name {
	case location.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case location.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case location.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case location.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case location.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case location.FieldTenantID:
		m.ClearTenantID()
		return nil
	case location.FieldCode:
		m.ClearCode()
		return nil
	case location.FieldDescription:
		m.ClearDescription()
		return nil
	case location.FieldParentID:
		m.ClearParentID()
		return nil
	case location.FieldPath:
		m.ClearPath()
		return nil
	case location.FieldAddress:
		m.ClearAddress()
		return nil
	case location.FieldCity:
		m.ClearCity()
		return nil
	case location.FieldState:
		m.ClearState()
		return nil
	case location.FieldCountry:
		m.ClearCountry()
		return nil
	case location.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case location.FieldLatitude:
		m.ClearLatitude()
		return nil
	case location.FieldLongitude:
		m.ClearLongitude()
		return nil
	case location.FieldContact:
		m.ClearContact()
		return nil
	case location.FieldPhone:
		m.ClearPhone()
		return nil
	case location.FieldEmail:
		m.ClearEmail()
		return nil
	case location.FieldTags:
		m.ClearTags()
		return nil
	case location.FieldMetadata:
		m.ClearMetadata()
		return nil
	case location.FieldRackSizeU:
		m.ClearRackSizeU()
		return nil
	}
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case location.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case location.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case location.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case location.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case location.FieldTenantID:
		m.ResetTenantID()
		return nil
	case location.FieldName:
		m.ResetName()
		return nil
	case location.FieldCode:
		m.ResetCode()
		return nil
	case location.FieldLocationType:
		m.ResetLocationType()
		return nil
	case location.FieldDescription:
		m.ResetDescription()
		return nil
	case location.FieldParentID:
		m.ResetParentID()
		return nil
	case location.FieldPath:
		m.ResetPath()
		return nil
	case location.FieldAddress:
		m.ResetAddress()
		return nil
	case location.FieldCity:
		m.ResetCity()
		return nil
	case location.FieldState:
		m.ResetState()
		return nil
	case location.FieldCountry:
		m.ResetCountry()
		return nil
	case location.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case location.FieldLatitude:
		m.ResetLatitude()
		return nil
	case location.FieldLongitude:
		m.ResetLongitude()
		return nil
	case location.FieldContact:
		m.ResetContact()
		return nil
	case location.FieldPhone:
		m.ResetPhone()
		return nil
	case location.FieldEmail:
		m.ResetEmail()
		return nil
	case location.FieldStatus:
		m.ResetStatus()
		return nil
	case location.FieldTags:
		m.ResetTags()
		return nil
	case location.FieldMetadata:
		m.ResetMetadata()
		return nil
	case location.FieldRackSizeU:
		m.ResetRackSizeU()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.parent != nil {
		edges = append(edges, location.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, location.EdgeChildren)
	}
	if m.subnets != nil {
		edges = append(edges, location.EdgeSubnets)
	}
	if m.vlans != nil {
		edges = append(edges, location.EdgeVlans)
	}
	if m.devices != nil {
		edges = append(edges, location.EdgeDevices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeSubnets:
		ids := make([]ent.Value, 0, len(m.subnets))
		for id := range m.subnets {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeVlans:
		ids := make([]ent.Value, 0, len(m.vlans))
		for id := range m.vlans {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedchildren != nil {
		edges = append(edges, location.EdgeChildren)
	}
	if m.removedsubnets != nil {
		edges = append(edges, location.EdgeSubnets)
	}
	if m.removedvlans != nil {
		edges = append(edges, location.EdgeVlans)
	}
	if m.removeddevices != nil {
		edges = append(edges, location.EdgeDevices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeSubnets:
		ids := make([]ent.Value, 0, len(m.removedsubnets))
		for id := range m.removedsubnets {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeVlans:
		ids := make([]ent.Value, 0, len(m.removedvlans))
		for id := range m.removedvlans {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedparent {
		edges = append(edges, location.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, location.EdgeChildren)
	}
	if m.clearedsubnets {
		edges = append(edges, location.EdgeSubnets)
	}
	if m.clearedvlans {
		edges = append(edges, location.EdgeVlans)
	}
	if m.cleareddevices {
		edges = append(edges, location.EdgeDevices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeParent:
		return m.clearedparent
	case location.EdgeChildren:
		return m.clearedchildren
	case location.EdgeSubnets:
		return m.clearedsubnets
	case location.EdgeVlans:
		return m.clearedvlans
	case location.EdgeDevices:
		return m.cleareddevices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	case location.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeParent:
		m.ResetParent()
		return nil
	case location.EdgeChildren:
		m.ResetChildren()
		return nil
	case location.EdgeSubnets:
		m.ResetSubnets()
		return nil
	case location.EdgeVlans:
		m.ResetVlans()
		return nil
	case location.EdgeDevices:
		m.ResetDevices()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// SubnetMutation represents an operation that mutates the Subnet nodes in the graph.
type SubnetMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	create_by          *uint32
	addcreate_by       *int32
	update_by          *uint32
	addupdate_by       *int32
	create_time        *time.Time
	update_time        *time.Time
	delete_time        *time.Time
	tenant_id          *uint32
	addtenant_id       *int32
	name               *string
	cidr               *string
	description        *string
	gateway            *string
	dns_servers        *string
	status             *int32
	addstatus          *int32
	ip_version         *int32
	addip_version      *int32
	network_address    *string
	broadcast_address  *string
	mask               *string
	prefix_length      *int32
	addprefix_length   *int32
	total_addresses    *int64
	addtotal_addresses *int64
	tags               *string
	metadata           *string
	clearedFields      map[string]struct{}
	addresses          map[string]struct{}
	removedaddresses   map[string]struct{}
	clearedaddresses   bool
	parent             *string
	clearedparent      bool
	children           map[string]struct{}
	removedchildren    map[string]struct{}
	clearedchildren    bool
	vlan               *string
	clearedvlan        bool
	location           *string
	clearedlocation    bool
	scan_jobs          map[string]struct{}
	removedscan_jobs   map[string]struct{}
	clearedscan_jobs   bool
	done               bool
	oldValue           func(context.Context) (*Subnet, error)
	predicates         []predicate.Subnet
}

var _ ent.Mutation = (*SubnetMutation)(nil)

// subnetOption allows management of the mutation configuration using functional options.
type subnetOption func(*SubnetMutation)

// newSubnetMutation creates new mutation for the Subnet entity.
func newSubnetMutation(c config, op Op, opts ...subnetOption) *SubnetMutation {
	m := &SubnetMutation{
		config:        c,
		op:            op,
		typ:           TypeSubnet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubnetID sets the ID field of the mutation.
func withSubnetID(id string) subnetOption {
	return func(m *SubnetMutation) {
		var (
			err   error
			once  sync.Once
			value *Subnet
		)
		m.oldValue = func(ctx context.Context) (*Subnet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subnet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubnet sets the old Subnet of the mutation.
func withSubnet(node *Subnet) subnetOption {
	return func(m *SubnetMutation) {
		m.oldValue = func(context.Context) (*Subnet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubnetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubnetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subnet entities.
func (m *SubnetMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubnetMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubnetMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subnet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *SubnetMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *SubnetMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *SubnetMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *SubnetMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *SubnetMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[subnet.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *SubnetMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[subnet.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *SubnetMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, subnet.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *SubnetMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *SubnetMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *SubnetMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *SubnetMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *SubnetMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[subnet.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *SubnetMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[subnet.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *SubnetMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, subnet.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *SubnetMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SubnetMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *SubnetMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[subnet.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *SubnetMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[subnet.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SubnetMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, subnet.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *SubnetMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SubnetMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *SubnetMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[subnet.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *SubnetMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[subnet.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SubnetMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, subnet.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *SubnetMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SubnetMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SubnetMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[subnet.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SubnetMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[subnet.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SubnetMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, subnet.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *SubnetMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SubnetMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *SubnetMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *SubnetMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *SubnetMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[subnet.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *SubnetMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[subnet.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SubnetMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, subnet.FieldTenantID)
}

// SetName sets the "name" field.
func (m *SubnetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubnetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubnetMutation) ResetName() {
	m.name = nil
}

// SetCidr sets the "cidr" field.
func (m *SubnetMutation) SetCidr(s string) {
	m.cidr = &s
}

// Cidr returns the value of the "cidr" field in the mutation.
func (m *SubnetMutation) Cidr() (r string, exists bool) {
	v := m.cidr
	if v == nil {
		return
	}
	return *v, true
}

// OldCidr returns the old "cidr" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldCidr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCidr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCidr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCidr: %w", err)
	}
	return oldValue.Cidr, nil
}

// ResetCidr resets all changes to the "cidr" field.
func (m *SubnetMutation) ResetCidr() {
	m.cidr = nil
}

// SetDescription sets the "description" field.
func (m *SubnetMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SubnetMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SubnetMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[subnet.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SubnetMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[subnet.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SubnetMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, subnet.FieldDescription)
}

// SetGateway sets the "gateway" field.
func (m *SubnetMutation) SetGateway(s string) {
	m.gateway = &s
}

// Gateway returns the value of the "gateway" field in the mutation.
func (m *SubnetMutation) Gateway() (r string, exists bool) {
	v := m.gateway
	if v == nil {
		return
	}
	return *v, true
}

// OldGateway returns the old "gateway" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldGateway(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGateway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGateway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGateway: %w", err)
	}
	return oldValue.Gateway, nil
}

// ClearGateway clears the value of the "gateway" field.
func (m *SubnetMutation) ClearGateway() {
	m.gateway = nil
	m.clearedFields[subnet.FieldGateway] = struct{}{}
}

// GatewayCleared returns if the "gateway" field was cleared in this mutation.
func (m *SubnetMutation) GatewayCleared() bool {
	_, ok := m.clearedFields[subnet.FieldGateway]
	return ok
}

// ResetGateway resets all changes to the "gateway" field.
func (m *SubnetMutation) ResetGateway() {
	m.gateway = nil
	delete(m.clearedFields, subnet.FieldGateway)
}

// SetDNSServers sets the "dns_servers" field.
func (m *SubnetMutation) SetDNSServers(s string) {
	m.dns_servers = &s
}

// DNSServers returns the value of the "dns_servers" field in the mutation.
func (m *SubnetMutation) DNSServers() (r string, exists bool) {
	v := m.dns_servers
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSServers returns the old "dns_servers" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldDNSServers(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSServers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSServers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSServers: %w", err)
	}
	return oldValue.DNSServers, nil
}

// ClearDNSServers clears the value of the "dns_servers" field.
func (m *SubnetMutation) ClearDNSServers() {
	m.dns_servers = nil
	m.clearedFields[subnet.FieldDNSServers] = struct{}{}
}

// DNSServersCleared returns if the "dns_servers" field was cleared in this mutation.
func (m *SubnetMutation) DNSServersCleared() bool {
	_, ok := m.clearedFields[subnet.FieldDNSServers]
	return ok
}

// ResetDNSServers resets all changes to the "dns_servers" field.
func (m *SubnetMutation) ResetDNSServers() {
	m.dns_servers = nil
	delete(m.clearedFields, subnet.FieldDNSServers)
}

// SetVlanID sets the "vlan_id" field.
func (m *SubnetMutation) SetVlanID(s string) {
	m.vlan = &s
}

// VlanID returns the value of the "vlan_id" field in the mutation.
func (m *SubnetMutation) VlanID() (r string, exists bool) {
	v := m.vlan
	if v == nil {
		return
	}
	return *v, true
}

// OldVlanID returns the old "vlan_id" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldVlanID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVlanID: %w", err)
	}
	return oldValue.VlanID, nil
}

// ClearVlanID clears the value of the "vlan_id" field.
func (m *SubnetMutation) ClearVlanID() {
	m.vlan = nil
	m.clearedFields[subnet.FieldVlanID] = struct{}{}
}

// VlanIDCleared returns if the "vlan_id" field was cleared in this mutation.
func (m *SubnetMutation) VlanIDCleared() bool {
	_, ok := m.clearedFields[subnet.FieldVlanID]
	return ok
}

// ResetVlanID resets all changes to the "vlan_id" field.
func (m *SubnetMutation) ResetVlanID() {
	m.vlan = nil
	delete(m.clearedFields, subnet.FieldVlanID)
}

// SetParentID sets the "parent_id" field.
func (m *SubnetMutation) SetParentID(s string) {
	m.parent = &s
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *SubnetMutation) ParentID() (r string, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldParentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *SubnetMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[subnet.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *SubnetMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[subnet.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *SubnetMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, subnet.FieldParentID)
}

// SetLocationID sets the "location_id" field.
func (m *SubnetMutation) SetLocationID(s string) {
	m.location = &s
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *SubnetMutation) LocationID() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldLocationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ClearLocationID clears the value of the "location_id" field.
func (m *SubnetMutation) ClearLocationID() {
	m.location = nil
	m.clearedFields[subnet.FieldLocationID] = struct{}{}
}

// LocationIDCleared returns if the "location_id" field was cleared in this mutation.
func (m *SubnetMutation) LocationIDCleared() bool {
	_, ok := m.clearedFields[subnet.FieldLocationID]
	return ok
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *SubnetMutation) ResetLocationID() {
	m.location = nil
	delete(m.clearedFields, subnet.FieldLocationID)
}

// SetStatus sets the "status" field.
func (m *SubnetMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SubnetMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SubnetMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SubnetMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *SubnetMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetIPVersion sets the "ip_version" field.
func (m *SubnetMutation) SetIPVersion(i int32) {
	m.ip_version = &i
	m.addip_version = nil
}

// IPVersion returns the value of the "ip_version" field in the mutation.
func (m *SubnetMutation) IPVersion() (r int32, exists bool) {
	v := m.ip_version
	if v == nil {
		return
	}
	return *v, true
}

// OldIPVersion returns the old "ip_version" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldIPVersion(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPVersion: %w", err)
	}
	return oldValue.IPVersion, nil
}

// AddIPVersion adds i to the "ip_version" field.
func (m *SubnetMutation) AddIPVersion(i int32) {
	if m.addip_version != nil {
		*m.addip_version += i
	} else {
		m.addip_version = &i
	}
}

// AddedIPVersion returns the value that was added to the "ip_version" field in this mutation.
func (m *SubnetMutation) AddedIPVersion() (r int32, exists bool) {
	v := m.addip_version
	if v == nil {
		return
	}
	return *v, true
}

// ResetIPVersion resets all changes to the "ip_version" field.
func (m *SubnetMutation) ResetIPVersion() {
	m.ip_version = nil
	m.addip_version = nil
}

// SetNetworkAddress sets the "network_address" field.
func (m *SubnetMutation) SetNetworkAddress(s string) {
	m.network_address = &s
}

// NetworkAddress returns the value of the "network_address" field in the mutation.
func (m *SubnetMutation) NetworkAddress() (r string, exists bool) {
	v := m.network_address
	if v == nil {
		return
	}
	return *v, true
}

// OldNetworkAddress returns the old "network_address" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldNetworkAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetworkAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetworkAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetworkAddress: %w", err)
	}
	return oldValue.NetworkAddress, nil
}

// ClearNetworkAddress clears the value of the "network_address" field.
func (m *SubnetMutation) ClearNetworkAddress() {
	m.network_address = nil
	m.clearedFields[subnet.FieldNetworkAddress] = struct{}{}
}

// NetworkAddressCleared returns if the "network_address" field was cleared in this mutation.
func (m *SubnetMutation) NetworkAddressCleared() bool {
	_, ok := m.clearedFields[subnet.FieldNetworkAddress]
	return ok
}

// ResetNetworkAddress resets all changes to the "network_address" field.
func (m *SubnetMutation) ResetNetworkAddress() {
	m.network_address = nil
	delete(m.clearedFields, subnet.FieldNetworkAddress)
}

// SetBroadcastAddress sets the "broadcast_address" field.
func (m *SubnetMutation) SetBroadcastAddress(s string) {
	m.broadcast_address = &s
}

// BroadcastAddress returns the value of the "broadcast_address" field in the mutation.
func (m *SubnetMutation) BroadcastAddress() (r string, exists bool) {
	v := m.broadcast_address
	if v == nil {
		return
	}
	return *v, true
}

// OldBroadcastAddress returns the old "broadcast_address" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldBroadcastAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBroadcastAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBroadcastAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBroadcastAddress: %w", err)
	}
	return oldValue.BroadcastAddress, nil
}

// ClearBroadcastAddress clears the value of the "broadcast_address" field.
func (m *SubnetMutation) ClearBroadcastAddress() {
	m.broadcast_address = nil
	m.clearedFields[subnet.FieldBroadcastAddress] = struct{}{}
}

// BroadcastAddressCleared returns if the "broadcast_address" field was cleared in this mutation.
func (m *SubnetMutation) BroadcastAddressCleared() bool {
	_, ok := m.clearedFields[subnet.FieldBroadcastAddress]
	return ok
}

// ResetBroadcastAddress resets all changes to the "broadcast_address" field.
func (m *SubnetMutation) ResetBroadcastAddress() {
	m.broadcast_address = nil
	delete(m.clearedFields, subnet.FieldBroadcastAddress)
}

// SetMask sets the "mask" field.
func (m *SubnetMutation) SetMask(s string) {
	m.mask = &s
}

// Mask returns the value of the "mask" field in the mutation.
func (m *SubnetMutation) Mask() (r string, exists bool) {
	v := m.mask
	if v == nil {
		return
	}
	return *v, true
}

// OldMask returns the old "mask" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldMask(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMask: %w", err)
	}
	return oldValue.Mask, nil
}

// ClearMask clears the value of the "mask" field.
func (m *SubnetMutation) ClearMask() {
	m.mask = nil
	m.clearedFields[subnet.FieldMask] = struct{}{}
}

// MaskCleared returns if the "mask" field was cleared in this mutation.
func (m *SubnetMutation) MaskCleared() bool {
	_, ok := m.clearedFields[subnet.FieldMask]
	return ok
}

// ResetMask resets all changes to the "mask" field.
func (m *SubnetMutation) ResetMask() {
	m.mask = nil
	delete(m.clearedFields, subnet.FieldMask)
}

// SetPrefixLength sets the "prefix_length" field.
func (m *SubnetMutation) SetPrefixLength(i int32) {
	m.prefix_length = &i
	m.addprefix_length = nil
}

// PrefixLength returns the value of the "prefix_length" field in the mutation.
func (m *SubnetMutation) PrefixLength() (r int32, exists bool) {
	v := m.prefix_length
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefixLength returns the old "prefix_length" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldPrefixLength(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefixLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefixLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefixLength: %w", err)
	}
	return oldValue.PrefixLength, nil
}

// AddPrefixLength adds i to the "prefix_length" field.
func (m *SubnetMutation) AddPrefixLength(i int32) {
	if m.addprefix_length != nil {
		*m.addprefix_length += i
	} else {
		m.addprefix_length = &i
	}
}

// AddedPrefixLength returns the value that was added to the "prefix_length" field in this mutation.
func (m *SubnetMutation) AddedPrefixLength() (r int32, exists bool) {
	v := m.addprefix_length
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrefixLength clears the value of the "prefix_length" field.
func (m *SubnetMutation) ClearPrefixLength() {
	m.prefix_length = nil
	m.addprefix_length = nil
	m.clearedFields[subnet.FieldPrefixLength] = struct{}{}
}

// PrefixLengthCleared returns if the "prefix_length" field was cleared in this mutation.
func (m *SubnetMutation) PrefixLengthCleared() bool {
	_, ok := m.clearedFields[subnet.FieldPrefixLength]
	return ok
}

// ResetPrefixLength resets all changes to the "prefix_length" field.
func (m *SubnetMutation) ResetPrefixLength() {
	m.prefix_length = nil
	m.addprefix_length = nil
	delete(m.clearedFields, subnet.FieldPrefixLength)
}

// SetTotalAddresses sets the "total_addresses" field.
func (m *SubnetMutation) SetTotalAddresses(i int64) {
	m.total_addresses = &i
	m.addtotal_addresses = nil
}

// TotalAddresses returns the value of the "total_addresses" field in the mutation.
func (m *SubnetMutation) TotalAddresses() (r int64, exists bool) {
	v := m.total_addresses
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAddresses returns the old "total_addresses" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldTotalAddresses(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAddresses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAddresses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAddresses: %w", err)
	}
	return oldValue.TotalAddresses, nil
}

// AddTotalAddresses adds i to the "total_addresses" field.
func (m *SubnetMutation) AddTotalAddresses(i int64) {
	if m.addtotal_addresses != nil {
		*m.addtotal_addresses += i
	} else {
		m.addtotal_addresses = &i
	}
}

// AddedTotalAddresses returns the value that was added to the "total_addresses" field in this mutation.
func (m *SubnetMutation) AddedTotalAddresses() (r int64, exists bool) {
	v := m.addtotal_addresses
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAddresses resets all changes to the "total_addresses" field.
func (m *SubnetMutation) ResetTotalAddresses() {
	m.total_addresses = nil
	m.addtotal_addresses = nil
}

// SetTags sets the "tags" field.
func (m *SubnetMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *SubnetMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *SubnetMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[subnet.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *SubnetMutation) TagsCleared() bool {
	_, ok := m.clearedFields[subnet.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *SubnetMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, subnet.FieldTags)
}

// SetMetadata sets the "metadata" field.
func (m *SubnetMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SubnetMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SubnetMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[subnet.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SubnetMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[subnet.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SubnetMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, subnet.FieldMetadata)
}

// AddAddressIDs adds the "addresses" edge to the IpAddress entity by ids.
func (m *SubnetMutation) AddAddressIDs(ids ...string) {
	if m.addresses == nil {
		m.addresses = make(map[string]struct{})
	}
	for i := range ids {
		m.addresses[ids[i]] = struct{}{}
	}
}

// ClearAddresses clears the "addresses" edge to the IpAddress entity.
func (m *SubnetMutation) ClearAddresses() {
	m.clearedaddresses = true
}

// AddressesCleared reports if the "addresses" edge to the IpAddress entity was cleared.
func (m *SubnetMutation) AddressesCleared() bool {
	return m.clearedaddresses
}

// RemoveAddressIDs removes the "addresses" edge to the IpAddress entity by IDs.
func (m *SubnetMutation) RemoveAddressIDs(ids ...string) {
	if m.removedaddresses == nil {
		m.removedaddresses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.addresses, ids[i])
		m.removedaddresses[ids[i]] = struct{}{}
	}
}

// RemovedAddresses returns the removed IDs of the "addresses" edge to the IpAddress entity.
func (m *SubnetMutation) RemovedAddressesIDs() (ids []string) {
	for id := range m.removedaddresses {
		ids = append(ids, id)
	}
	return
}

// AddressesIDs returns the "addresses" edge IDs in the mutation.
func (m *SubnetMutation) AddressesIDs() (ids []string) {
	for id := range m.addresses {
		ids = append(ids, id)
	}
	return
}

// ResetAddresses resets all changes to the "addresses" edge.
func (m *SubnetMutation) ResetAddresses() {
	m.addresses = nil
	m.clearedaddresses = false
	m.removedaddresses = nil
}

// ClearParent clears the "parent" edge to the Subnet entity.
func (m *SubnetMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[subnet.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Subnet entity was cleared.
func (m *SubnetMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *SubnetMutation) ParentIDs() (ids []string) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *SubnetMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Subnet entity by ids.
func (m *SubnetMutation) AddChildIDs(ids ...string) {
	if m.children == nil {
		m.children = make(map[string]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Subnet entity.
func (m *SubnetMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Subnet entity was cleared.
func (m *SubnetMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Subnet entity by IDs.
func (m *SubnetMutation) RemoveChildIDs(ids ...string) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Subnet entity.
func (m *SubnetMutation) RemovedChildrenIDs() (ids []string) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *SubnetMutation) ChildrenIDs() (ids []string) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *SubnetMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearVlan clears the "vlan" edge to the Vlan entity.
func (m *SubnetMutation) ClearVlan() {
	m.clearedvlan = true
	m.clearedFields[subnet.FieldVlanID] = struct{}{}
}

// VlanCleared reports if the "vlan" edge to the Vlan entity was cleared.
func (m *SubnetMutation) VlanCleared() bool {
	return m.VlanIDCleared() || m.clearedvlan
}

// VlanIDs returns the "vlan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VlanID instead. It exists only for internal usage by the builders.
func (m *SubnetMutation) VlanIDs() (ids []string) {
	if id := m.vlan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVlan resets all changes to the "vlan" edge.
func (m *SubnetMutation) ResetVlan() {
	m.vlan = nil
	m.clearedvlan = false
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *SubnetMutation) ClearLocation() {
	m.clearedlocation = true
	m.clearedFields[subnet.FieldLocationID] = struct{}{}
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *SubnetMutation) LocationCleared() bool {
	return m.LocationIDCleared() || m.clearedlocation
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *SubnetMutation) LocationIDs() (ids []string) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *SubnetMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// AddScanJobIDs adds the "scan_jobs" edge to the IpScanJob entity by ids.
func (m *SubnetMutation) AddScanJobIDs(ids ...string) {
	if m.scan_jobs == nil {
		m.scan_jobs = make(map[string]struct{})
	}
	for i := range ids {
		m.scan_jobs[ids[i]] = struct{}{}
	}
}

// ClearScanJobs clears the "scan_jobs" edge to the IpScanJob entity.
func (m *SubnetMutation) ClearScanJobs() {
	m.clearedscan_jobs = true
}

// ScanJobsCleared reports if the "scan_jobs" edge to the IpScanJob entity was cleared.
func (m *SubnetMutation) ScanJobsCleared() bool {
	return m.clearedscan_jobs
}

// RemoveScanJobIDs removes the "scan_jobs" edge to the IpScanJob entity by IDs.
func (m *SubnetMutation) RemoveScanJobIDs(ids ...string) {
	if m.removedscan_jobs == nil {
		m.removedscan_jobs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.scan_jobs, ids[i])
		m.removedscan_jobs[ids[i]] = struct{}{}
	}
}

// RemovedScanJobs returns the removed IDs of the "scan_jobs" edge to the IpScanJob entity.
func (m *SubnetMutation) RemovedScanJobsIDs() (ids []string) {
	for id := range m.removedscan_jobs {
		ids = append(ids, id)
	}
	return
}

// ScanJobsIDs returns the "scan_jobs" edge IDs in the mutation.
func (m *SubnetMutation) ScanJobsIDs() (ids []string) {
	for id := range m.scan_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetScanJobs resets all changes to the "scan_jobs" edge.
func (m *SubnetMutation) ResetScanJobs() {
	m.scan_jobs = nil
	m.clearedscan_jobs = false
	m.removedscan_jobs = nil
}

// Where appends a list predicates to the SubnetMutation builder.
func (m *SubnetMutation) Where(ps ...predicate.Subnet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubnetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubnetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subnet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubnetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubnetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subnet).
func (m *SubnetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubnetMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.create_by != nil {
		fields = append(fields, subnet.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, subnet.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, subnet.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, subnet.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, subnet.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, subnet.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, subnet.FieldName)
	}
	if m.cidr != nil {
		fields = append(fields, subnet.FieldCidr)
	}
	if m.description != nil {
		fields = append(fields, subnet.FieldDescription)
	}
	if m.gateway != nil {
		fields = append(fields, subnet.FieldGateway)
	}
	if m.dns_servers != nil {
		fields = append(fields, subnet.FieldDNSServers)
	}
	if m.vlan != nil {
		fields = append(fields, subnet.FieldVlanID)
	}
	if m.parent != nil {
		fields = append(fields, subnet.FieldParentID)
	}
	if m.location != nil {
		fields = append(fields, subnet.FieldLocationID)
	}
	if m.status != nil {
		fields = append(fields, subnet.FieldStatus)
	}
	if m.ip_version != nil {
		fields = append(fields, subnet.FieldIPVersion)
	}
	if m.network_address != nil {
		fields = append(fields, subnet.FieldNetworkAddress)
	}
	if m.broadcast_address != nil {
		fields = append(fields, subnet.FieldBroadcastAddress)
	}
	if m.mask != nil {
		fields = append(fields, subnet.FieldMask)
	}
	if m.prefix_length != nil {
		fields = append(fields, subnet.FieldPrefixLength)
	}
	if m.total_addresses != nil {
		fields = append(fields, subnet.FieldTotalAddresses)
	}
	if m.tags != nil {
		fields = append(fields, subnet.FieldTags)
	}
	if m.metadata != nil {
		fields = append(fields, subnet.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubnetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subnet.FieldCreateBy:
		return m.CreateBy()
	case subnet.FieldUpdateBy:
		return m.UpdateBy()
	case subnet.FieldCreateTime:
		return m.CreateTime()
	case subnet.FieldUpdateTime:
		return m.UpdateTime()
	case subnet.FieldDeleteTime:
		return m.DeleteTime()
	case subnet.FieldTenantID:
		return m.TenantID()
	case subnet.FieldName:
		return m.Name()
	case subnet.FieldCidr:
		return m.Cidr()
	case subnet.FieldDescription:
		return m.Description()
	case subnet.FieldGateway:
		return m.Gateway()
	case subnet.FieldDNSServers:
		return m.DNSServers()
	case subnet.FieldVlanID:
		return m.VlanID()
	case subnet.FieldParentID:
		return m.ParentID()
	case subnet.FieldLocationID:
		return m.LocationID()
	case subnet.FieldStatus:
		return m.Status()
	case subnet.FieldIPVersion:
		return m.IPVersion()
	case subnet.FieldNetworkAddress:
		return m.NetworkAddress()
	case subnet.FieldBroadcastAddress:
		return m.BroadcastAddress()
	case subnet.FieldMask:
		return m.Mask()
	case subnet.FieldPrefixLength:
		return m.PrefixLength()
	case subnet.FieldTotalAddresses:
		return m.TotalAddresses()
	case subnet.FieldTags:
		return m.Tags()
	case subnet.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubnetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subnet.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case subnet.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case subnet.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case subnet.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case subnet.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case subnet.FieldTenantID:
		return m.OldTenantID(ctx)
	case subnet.FieldName:
		return m.OldName(ctx)
	case subnet.FieldCidr:
		return m.OldCidr(ctx)
	case subnet.FieldDescription:
		return m.OldDescription(ctx)
	case subnet.FieldGateway:
		return m.OldGateway(ctx)
	case subnet.FieldDNSServers:
		return m.OldDNSServers(ctx)
	case subnet.FieldVlanID:
		return m.OldVlanID(ctx)
	case subnet.FieldParentID:
		return m.OldParentID(ctx)
	case subnet.FieldLocationID:
		return m.OldLocationID(ctx)
	case subnet.FieldStatus:
		return m.OldStatus(ctx)
	case subnet.FieldIPVersion:
		return m.OldIPVersion(ctx)
	case subnet.FieldNetworkAddress:
		return m.OldNetworkAddress(ctx)
	case subnet.FieldBroadcastAddress:
		return m.OldBroadcastAddress(ctx)
	case subnet.FieldMask:
		return m.OldMask(ctx)
	case subnet.FieldPrefixLength:
		return m.OldPrefixLength(ctx)
	case subnet.FieldTotalAddresses:
		return m.OldTotalAddresses(ctx)
	case subnet.FieldTags:
		return m.OldTags(ctx)
	case subnet.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Subnet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubnetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subnet.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case subnet.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case subnet.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case subnet.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case subnet.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case subnet.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case subnet.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subnet.FieldCidr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCidr(v)
		return nil
	case subnet.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case subnet.FieldGateway:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGateway(v)
		return nil
	case subnet.FieldDNSServers:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSServers(v)
		return nil
	case subnet.FieldVlanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVlanID(v)
		return nil
	case subnet.FieldParentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case subnet.FieldLocationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case subnet.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case subnet.FieldIPVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPVersion(v)
		return nil
	case subnet.FieldNetworkAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetworkAddress(v)
		return nil
	case subnet.FieldBroadcastAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBroadcastAddress(v)
		return nil
	case subnet.FieldMask:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMask(v)
		return nil
	case subnet.FieldPrefixLength:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefixLength(v)
		return nil
	case subnet.FieldTotalAddresses:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAddresses(v)
		return nil
	case subnet.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case subnet.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Subnet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubnetMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, subnet.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, subnet.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, subnet.FieldTenantID)
	}
	if m.addstatus != nil {
		fields = append(fields, subnet.FieldStatus)
	}
	if m.addip_version != nil {
		fields = append(fields, subnet.FieldIPVersion)
	}
	if m.addprefix_length != nil {
		fields = append(fields, subnet.FieldPrefixLength)
	}
	if m.addtotal_addresses != nil {
		fields = append(fields, subnet.FieldTotalAddresses)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubnetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subnet.FieldCreateBy:
		return m.AddedCreateBy()
	case subnet.FieldUpdateBy:
		return m.AddedUpdateBy()
	case subnet.FieldTenantID:
		return m.AddedTenantID()
	case subnet.FieldStatus:
		return m.AddedStatus()
	case subnet.FieldIPVersion:
		return m.AddedIPVersion()
	case subnet.FieldPrefixLength:
		return m.AddedPrefixLength()
	case subnet.FieldTotalAddresses:
		return m.AddedTotalAddresses()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubnetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subnet.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case subnet.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case subnet.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case subnet.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case subnet.FieldIPVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIPVersion(v)
		return nil
	case subnet.FieldPrefixLength:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrefixLength(v)
		return nil
	case subnet.FieldTotalAddresses:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAddresses(v)
		return nil
	}
	return fmt.Errorf("unknown Subnet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubnetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subnet.FieldCreateBy) {
		fields = append(fields, subnet.FieldCreateBy)
	}
	if m.FieldCleared(subnet.FieldUpdateBy) {
		fields = append(fields, subnet.FieldUpdateBy)
	}
	if m.FieldCleared(subnet.FieldCreateTime) {
		fields = append(fields, subnet.FieldCreateTime)
	}
	if m.FieldCleared(subnet.FieldUpdateTime) {
		fields = append(fields, subnet.FieldUpdateTime)
	}
	if m.FieldCleared(subnet.FieldDeleteTime) {
		fields = append(fields, subnet.FieldDeleteTime)
	}
	if m.FieldCleared(subnet.FieldTenantID) {
		fields = append(fields, subnet.FieldTenantID)
	}
	if m.FieldCleared(subnet.FieldDescription) {
		fields = append(fields, subnet.FieldDescription)
	}
	if m.FieldCleared(subnet.FieldGateway) {
		fields = append(fields, subnet.FieldGateway)
	}
	if m.FieldCleared(subnet.FieldDNSServers) {
		fields = append(fields, subnet.FieldDNSServers)
	}
	if m.FieldCleared(subnet.FieldVlanID) {
		fields = append(fields, subnet.FieldVlanID)
	}
	if m.FieldCleared(subnet.FieldParentID) {
		fields = append(fields, subnet.FieldParentID)
	}
	if m.FieldCleared(subnet.FieldLocationID) {
		fields = append(fields, subnet.FieldLocationID)
	}
	if m.FieldCleared(subnet.FieldNetworkAddress) {
		fields = append(fields, subnet.FieldNetworkAddress)
	}
	if m.FieldCleared(subnet.FieldBroadcastAddress) {
		fields = append(fields, subnet.FieldBroadcastAddress)
	}
	if m.FieldCleared(subnet.FieldMask) {
		fields = append(fields, subnet.FieldMask)
	}
	if m.FieldCleared(subnet.FieldPrefixLength) {
		fields = append(fields, subnet.FieldPrefixLength)
	}
	if m.FieldCleared(subnet.FieldTags) {
		fields = append(fields, subnet.FieldTags)
	}
	if m.FieldCleared(subnet.FieldMetadata) {
		fields = append(fields, subnet.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubnetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubnetMutation) ClearField(name string) error {
	switch name {
	case subnet.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case subnet.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case subnet.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case subnet.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case subnet.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case subnet.FieldTenantID:
		m.ClearTenantID()
		return nil
	case subnet.FieldDescription:
		m.ClearDescription()
		return nil
	case subnet.FieldGateway:
		m.ClearGateway()
		return nil
	case subnet.FieldDNSServers:
		m.ClearDNSServers()
		return nil
	case subnet.FieldVlanID:
		m.ClearVlanID()
		return nil
	case subnet.FieldParentID:
		m.ClearParentID()
		return nil
	case subnet.FieldLocationID:
		m.ClearLocationID()
		return nil
	case subnet.FieldNetworkAddress:
		m.ClearNetworkAddress()
		return nil
	case subnet.FieldBroadcastAddress:
		m.ClearBroadcastAddress()
		return nil
	case subnet.FieldMask:
		m.ClearMask()
		return nil
	case subnet.FieldPrefixLength:
		m.ClearPrefixLength()
		return nil
	case subnet.FieldTags:
		m.ClearTags()
		return nil
	case subnet.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Subnet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubnetMutation) ResetField(name string) error {
	switch name {
	case subnet.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case subnet.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case subnet.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case subnet.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case subnet.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case subnet.FieldTenantID:
		m.ResetTenantID()
		return nil
	case subnet.FieldName:
		m.ResetName()
		return nil
	case subnet.FieldCidr:
		m.ResetCidr()
		return nil
	case subnet.FieldDescription:
		m.ResetDescription()
		return nil
	case subnet.FieldGateway:
		m.ResetGateway()
		return nil
	case subnet.FieldDNSServers:
		m.ResetDNSServers()
		return nil
	case subnet.FieldVlanID:
		m.ResetVlanID()
		return nil
	case subnet.FieldParentID:
		m.ResetParentID()
		return nil
	case subnet.FieldLocationID:
		m.ResetLocationID()
		return nil
	case subnet.FieldStatus:
		m.ResetStatus()
		return nil
	case subnet.FieldIPVersion:
		m.ResetIPVersion()
		return nil
	case subnet.FieldNetworkAddress:
		m.ResetNetworkAddress()
		return nil
	case subnet.FieldBroadcastAddress:
		m.ResetBroadcastAddress()
		return nil
	case subnet.FieldMask:
		m.ResetMask()
		return nil
	case subnet.FieldPrefixLength:
		m.ResetPrefixLength()
		return nil
	case subnet.FieldTotalAddresses:
		m.ResetTotalAddresses()
		return nil
	case subnet.FieldTags:
		m.ResetTags()
		return nil
	case subnet.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Subnet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubnetMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.addresses != nil {
		edges = append(edges, subnet.EdgeAddresses)
	}
	if m.parent != nil {
		edges = append(edges, subnet.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, subnet.EdgeChildren)
	}
	if m.vlan != nil {
		edges = append(edges, subnet.EdgeVlan)
	}
	if m.location != nil {
		edges = append(edges, subnet.EdgeLocation)
	}
	if m.scan_jobs != nil {
		edges = append(edges, subnet.EdgeScanJobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubnetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subnet.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.addresses))
		for id := range m.addresses {
			ids = append(ids, id)
		}
		return ids
	case subnet.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case subnet.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case subnet.EdgeVlan:
		if id := m.vlan; id != nil {
			return []ent.Value{*id}
		}
	case subnet.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case subnet.EdgeScanJobs:
		ids := make([]ent.Value, 0, len(m.scan_jobs))
		for id := range m.scan_jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubnetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedaddresses != nil {
		edges = append(edges, subnet.EdgeAddresses)
	}
	if m.removedchildren != nil {
		edges = append(edges, subnet.EdgeChildren)
	}
	if m.removedscan_jobs != nil {
		edges = append(edges, subnet.EdgeScanJobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubnetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subnet.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.removedaddresses))
		for id := range m.removedaddresses {
			ids = append(ids, id)
		}
		return ids
	case subnet.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case subnet.EdgeScanJobs:
		ids := make([]ent.Value, 0, len(m.removedscan_jobs))
		for id := range m.removedscan_jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubnetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedaddresses {
		edges = append(edges, subnet.EdgeAddresses)
	}
	if m.clearedparent {
		edges = append(edges, subnet.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, subnet.EdgeChildren)
	}
	if m.clearedvlan {
		edges = append(edges, subnet.EdgeVlan)
	}
	if m.clearedlocation {
		edges = append(edges, subnet.EdgeLocation)
	}
	if m.clearedscan_jobs {
		edges = append(edges, subnet.EdgeScanJobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubnetMutation) EdgeCleared(name string) bool {
	switch name {
	case subnet.EdgeAddresses:
		return m.clearedaddresses
	case subnet.EdgeParent:
		return m.clearedparent
	case subnet.EdgeChildren:
		return m.clearedchildren
	case subnet.EdgeVlan:
		return m.clearedvlan
	case subnet.EdgeLocation:
		return m.clearedlocation
	case subnet.EdgeScanJobs:
		return m.clearedscan_jobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubnetMutation) ClearEdge(name string) error {
	switch name {
	case subnet.EdgeParent:
		m.ClearParent()
		return nil
	case subnet.EdgeVlan:
		m.ClearVlan()
		return nil
	case subnet.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown Subnet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubnetMutation) ResetEdge(name string) error {
	switch name {
	case subnet.EdgeAddresses:
		m.ResetAddresses()
		return nil
	case subnet.EdgeParent:
		m.ResetParent()
		return nil
	case subnet.EdgeChildren:
		m.ResetChildren()
		return nil
	case subnet.EdgeVlan:
		m.ResetVlan()
		return nil
	case subnet.EdgeLocation:
		m.ResetLocation()
		return nil
	case subnet.EdgeScanJobs:
		m.ResetScanJobs()
		return nil
	}
	return fmt.Errorf("unknown Subnet edge %s", name)
}

// VlanMutation represents an operation that mutates the Vlan nodes in the graph.
type VlanMutation struct {
	config
	op              Op
	typ             string
	id              *string
	create_by       *uint32
	addcreate_by    *int32
	update_by       *uint32
	addupdate_by    *int32
	create_time     *time.Time
	update_time     *time.Time
	delete_time     *time.Time
	tenant_id       *uint32
	addtenant_id    *int32
	vlan_id         *int32
	addvlan_id      *int32
	name            *string
	description     *string
	domain          *string
	status          *int32
	addstatus       *int32
	tags            *string
	metadata        *string
	clearedFields   map[string]struct{}
	subnets         map[string]struct{}
	removedsubnets  map[string]struct{}
	clearedsubnets  bool
	location        *string
	clearedlocation bool
	done            bool
	oldValue        func(context.Context) (*Vlan, error)
	predicates      []predicate.Vlan
}

var _ ent.Mutation = (*VlanMutation)(nil)

// vlanOption allows management of the mutation configuration using functional options.
type vlanOption func(*VlanMutation)

// newVlanMutation creates new mutation for the Vlan entity.
func newVlanMutation(c config, op Op, opts ...vlanOption) *VlanMutation {
	m := &VlanMutation{
		config:        c,
		op:            op,
		typ:           TypeVlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVlanID sets the ID field of the mutation.
func withVlanID(id string) vlanOption {
	return func(m *VlanMutation) {
		var (
			err   error
			once  sync.Once
			value *Vlan
		)
		m.oldValue = func(ctx context.Context) (*Vlan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVlan sets the old Vlan of the mutation.
func withVlan(node *Vlan) vlanOption {
	return func(m *VlanMutation) {
		m.oldValue = func(context.Context) (*Vlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Vlan entities.
func (m *VlanMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VlanMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VlanMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vlan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *VlanMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *VlanMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *VlanMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *VlanMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *VlanMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[vlan.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *VlanMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[vlan.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *VlanMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, vlan.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *VlanMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *VlanMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *VlanMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *VlanMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *VlanMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[vlan.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *VlanMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[vlan.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *VlanMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, vlan.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *VlanMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *VlanMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *VlanMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[vlan.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *VlanMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[vlan.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *VlanMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, vlan.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *VlanMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *VlanMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *VlanMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[vlan.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *VlanMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[vlan.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *VlanMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, vlan.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *VlanMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *VlanMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *VlanMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[vlan.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *VlanMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[vlan.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *VlanMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, vlan.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *VlanMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *VlanMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *VlanMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *VlanMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *VlanMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[vlan.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *VlanMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[vlan.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *VlanMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, vlan.FieldTenantID)
}

// SetVlanID sets the "vlan_id" field.
func (m *VlanMutation) SetVlanID(i int32) {
	m.vlan_id = &i
	m.addvlan_id = nil
}

// VlanID returns the value of the "vlan_id" field in the mutation.
func (m *VlanMutation) VlanID() (r int32, exists bool) {
	v := m.vlan_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVlanID returns the old "vlan_id" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldVlanID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVlanID: %w", err)
	}
	return oldValue.VlanID, nil
}

// AddVlanID adds i to the "vlan_id" field.
func (m *VlanMutation) AddVlanID(i int32) {
	if m.addvlan_id != nil {
		*m.addvlan_id += i
	} else {
		m.addvlan_id = &i
	}
}

// AddedVlanID returns the value that was added to the "vlan_id" field in this mutation.
func (m *VlanMutation) AddedVlanID() (r int32, exists bool) {
	v := m.addvlan_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetVlanID resets all changes to the "vlan_id" field.
func (m *VlanMutation) ResetVlanID() {
	m.vlan_id = nil
	m.addvlan_id = nil
}

// SetName sets the "name" field.
func (m *VlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VlanMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *VlanMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VlanMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VlanMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[vlan.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VlanMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[vlan.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VlanMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, vlan.FieldDescription)
}

// SetDomain sets the "domain" field.
func (m *VlanMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *VlanMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *VlanMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[vlan.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *VlanMutation) DomainCleared() bool {
	_, ok := m.clearedFields[vlan.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *VlanMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, vlan.FieldDomain)
}

// SetLocationID sets the "location_id" field.
func (m *VlanMutation) SetLocationID(s string) {
	m.location = &s
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *VlanMutation) LocationID() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldLocationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ClearLocationID clears the value of the "location_id" field.
func (m *VlanMutation) ClearLocationID() {
	m.location = nil
	m.clearedFields[vlan.FieldLocationID] = struct{}{}
}

// LocationIDCleared returns if the "location_id" field was cleared in this mutation.
func (m *VlanMutation) LocationIDCleared() bool {
	_, ok := m.clearedFields[vlan.FieldLocationID]
	return ok
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *VlanMutation) ResetLocationID() {
	m.location = nil
	delete(m.clearedFields, vlan.FieldLocationID)
}

// SetStatus sets the "status" field.
func (m *VlanMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VlanMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VlanMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VlanMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *VlanMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetTags sets the "tags" field.
func (m *VlanMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *VlanMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *VlanMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[vlan.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *VlanMutation) TagsCleared() bool {
	_, ok := m.clearedFields[vlan.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *VlanMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, vlan.FieldTags)
}

// SetMetadata sets the "metadata" field.
func (m *VlanMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *VlanMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *VlanMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[vlan.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *VlanMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[vlan.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *VlanMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, vlan.FieldMetadata)
}

// AddSubnetIDs adds the "subnets" edge to the Subnet entity by ids.
func (m *VlanMutation) AddSubnetIDs(ids ...string) {
	if m.subnets == nil {
		m.subnets = make(map[string]struct{})
	}
	for i := range ids {
		m.subnets[ids[i]] = struct{}{}
	}
}

// ClearSubnets clears the "subnets" edge to the Subnet entity.
func (m *VlanMutation) ClearSubnets() {
	m.clearedsubnets = true
}

// SubnetsCleared reports if the "subnets" edge to the Subnet entity was cleared.
func (m *VlanMutation) SubnetsCleared() bool {
	return m.clearedsubnets
}

// RemoveSubnetIDs removes the "subnets" edge to the Subnet entity by IDs.
func (m *VlanMutation) RemoveSubnetIDs(ids ...string) {
	if m.removedsubnets == nil {
		m.removedsubnets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subnets, ids[i])
		m.removedsubnets[ids[i]] = struct{}{}
	}
}

// RemovedSubnets returns the removed IDs of the "subnets" edge to the Subnet entity.
func (m *VlanMutation) RemovedSubnetsIDs() (ids []string) {
	for id := range m.removedsubnets {
		ids = append(ids, id)
	}
	return
}

// SubnetsIDs returns the "subnets" edge IDs in the mutation.
func (m *VlanMutation) SubnetsIDs() (ids []string) {
	for id := range m.subnets {
		ids = append(ids, id)
	}
	return
}

// ResetSubnets resets all changes to the "subnets" edge.
func (m *VlanMutation) ResetSubnets() {
	m.subnets = nil
	m.clearedsubnets = false
	m.removedsubnets = nil
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *VlanMutation) ClearLocation() {
	m.clearedlocation = true
	m.clearedFields[vlan.FieldLocationID] = struct{}{}
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *VlanMutation) LocationCleared() bool {
	return m.LocationIDCleared() || m.clearedlocation
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *VlanMutation) LocationIDs() (ids []string) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *VlanMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// Where appends a list predicates to the VlanMutation builder.
func (m *VlanMutation) Where(ps ...predicate.Vlan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Vlan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Vlan).
func (m *VlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VlanMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_by != nil {
		fields = append(fields, vlan.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, vlan.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, vlan.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, vlan.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, vlan.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, vlan.FieldTenantID)
	}
	if m.vlan_id != nil {
		fields = append(fields, vlan.FieldVlanID)
	}
	if m.name != nil {
		fields = append(fields, vlan.FieldName)
	}
	if m.description != nil {
		fields = append(fields, vlan.FieldDescription)
	}
	if m.domain != nil {
		fields = append(fields, vlan.FieldDomain)
	}
	if m.location != nil {
		fields = append(fields, vlan.FieldLocationID)
	}
	if m.status != nil {
		fields = append(fields, vlan.FieldStatus)
	}
	if m.tags != nil {
		fields = append(fields, vlan.FieldTags)
	}
	if m.metadata != nil {
		fields = append(fields, vlan.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vlan.FieldCreateBy:
		return m.CreateBy()
	case vlan.FieldUpdateBy:
		return m.UpdateBy()
	case vlan.FieldCreateTime:
		return m.CreateTime()
	case vlan.FieldUpdateTime:
		return m.UpdateTime()
	case vlan.FieldDeleteTime:
		return m.DeleteTime()
	case vlan.FieldTenantID:
		return m.TenantID()
	case vlan.FieldVlanID:
		return m.VlanID()
	case vlan.FieldName:
		return m.Name()
	case vlan.FieldDescription:
		return m.Description()
	case vlan.FieldDomain:
		return m.Domain()
	case vlan.FieldLocationID:
		return m.LocationID()
	case vlan.FieldStatus:
		return m.Status()
	case vlan.FieldTags:
		return m.Tags()
	case vlan.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vlan.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case vlan.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case vlan.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case vlan.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case vlan.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case vlan.FieldTenantID:
		return m.OldTenantID(ctx)
	case vlan.FieldVlanID:
		return m.OldVlanID(ctx)
	case vlan.FieldName:
		return m.OldName(ctx)
	case vlan.FieldDescription:
		return m.OldDescription(ctx)
	case vlan.FieldDomain:
		return m.OldDomain(ctx)
	case vlan.FieldLocationID:
		return m.OldLocationID(ctx)
	case vlan.FieldStatus:
		return m.OldStatus(ctx)
	case vlan.FieldTags:
		return m.OldTags(ctx)
	case vlan.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Vlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vlan.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case vlan.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case vlan.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case vlan.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case vlan.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case vlan.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case vlan.FieldVlanID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVlanID(v)
		return nil
	case vlan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vlan.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case vlan.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case vlan.FieldLocationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case vlan.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case vlan.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case vlan.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Vlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VlanMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, vlan.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, vlan.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, vlan.FieldTenantID)
	}
	if m.addvlan_id != nil {
		fields = append(fields, vlan.FieldVlanID)
	}
	if m.addstatus != nil {
		fields = append(fields, vlan.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vlan.FieldCreateBy:
		return m.AddedCreateBy()
	case vlan.FieldUpdateBy:
		return m.AddedUpdateBy()
	case vlan.FieldTenantID:
		return m.AddedTenantID()
	case vlan.FieldVlanID:
		return m.AddedVlanID()
	case vlan.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vlan.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case vlan.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case vlan.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case vlan.FieldVlanID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVlanID(v)
		return nil
	case vlan.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Vlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vlan.FieldCreateBy) {
		fields = append(fields, vlan.FieldCreateBy)
	}
	if m.FieldCleared(vlan.FieldUpdateBy) {
		fields = append(fields, vlan.FieldUpdateBy)
	}
	if m.FieldCleared(vlan.FieldCreateTime) {
		fields = append(fields, vlan.FieldCreateTime)
	}
	if m.FieldCleared(vlan.FieldUpdateTime) {
		fields = append(fields, vlan.FieldUpdateTime)
	}
	if m.FieldCleared(vlan.FieldDeleteTime) {
		fields = append(fields, vlan.FieldDeleteTime)
	}
	if m.FieldCleared(vlan.FieldTenantID) {
		fields = append(fields, vlan.FieldTenantID)
	}
	if m.FieldCleared(vlan.FieldDescription) {
		fields = append(fields, vlan.FieldDescription)
	}
	if m.FieldCleared(vlan.FieldDomain) {
		fields = append(fields, vlan.FieldDomain)
	}
	if m.FieldCleared(vlan.FieldLocationID) {
		fields = append(fields, vlan.FieldLocationID)
	}
	if m.FieldCleared(vlan.FieldTags) {
		fields = append(fields, vlan.FieldTags)
	}
	if m.FieldCleared(vlan.FieldMetadata) {
		fields = append(fields, vlan.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VlanMutation) ClearField(name string) error {
	switch name {
	case vlan.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case vlan.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case vlan.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case vlan.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case vlan.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case vlan.FieldTenantID:
		m.ClearTenantID()
		return nil
	case vlan.FieldDescription:
		m.ClearDescription()
		return nil
	case vlan.FieldDomain:
		m.ClearDomain()
		return nil
	case vlan.FieldLocationID:
		m.ClearLocationID()
		return nil
	case vlan.FieldTags:
		m.ClearTags()
		return nil
	case vlan.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Vlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VlanMutation) ResetField(name string) error {
	switch name {
	case vlan.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case vlan.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case vlan.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case vlan.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case vlan.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case vlan.FieldTenantID:
		m.ResetTenantID()
		return nil
	case vlan.FieldVlanID:
		m.ResetVlanID()
		return nil
	case vlan.FieldName:
		m.ResetName()
		return nil
	case vlan.FieldDescription:
		m.ResetDescription()
		return nil
	case vlan.FieldDomain:
		m.ResetDomain()
		return nil
	case vlan.FieldLocationID:
		m.ResetLocationID()
		return nil
	case vlan.FieldStatus:
		m.ResetStatus()
		return nil
	case vlan.FieldTags:
		m.ResetTags()
		return nil
	case vlan.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Vlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.subnets != nil {
		edges = append(edges, vlan.EdgeSubnets)
	}
	if m.location != nil {
		edges = append(edges, vlan.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vlan.EdgeSubnets:
		ids := make([]ent.Value, 0, len(m.subnets))
		for id := range m.subnets {
			ids = append(ids, id)
		}
		return ids
	case vlan.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsubnets != nil {
		edges = append(edges, vlan.EdgeSubnets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vlan.EdgeSubnets:
		ids := make([]ent.Value, 0, len(m.removedsubnets))
		for id := range m.removedsubnets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsubnets {
		edges = append(edges, vlan.EdgeSubnets)
	}
	if m.clearedlocation {
		edges = append(edges, vlan.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VlanMutation) EdgeCleared(name string) bool {
	switch name {
	case vlan.EdgeSubnets:
		return m.clearedsubnets
	case vlan.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VlanMutation) ClearEdge(name string) error {
	switch name {
	case vlan.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown Vlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VlanMutation) ResetEdge(name string) error {
	switch name {
	case vlan.EdgeSubnets:
		m.ResetSubnets()
		return nil
	case vlan.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown Vlan edge %s", name)
}
