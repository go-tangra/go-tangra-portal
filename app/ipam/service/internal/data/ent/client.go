// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/migrate"

	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/auditlog"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/device"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/deviceinterface"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/dnsconfig"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/hostgroup"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/hostgroupmember"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/ipaddress"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/ipgroup"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/ipgroupmember"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/ipscanjob"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/location"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/subnet"
	"github.com/go-tangra/go-tangra-portal/app/ipam/service/internal/data/ent/vlan"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AuditLog is the client for interacting with the AuditLog builders.
	AuditLog *AuditLogClient
	// Device is the client for interacting with the Device builders.
	Device *DeviceClient
	// DeviceInterface is the client for interacting with the DeviceInterface builders.
	DeviceInterface *DeviceInterfaceClient
	// DnsConfig is the client for interacting with the DnsConfig builders.
	DnsConfig *DnsConfigClient
	// HostGroup is the client for interacting with the HostGroup builders.
	HostGroup *HostGroupClient
	// HostGroupMember is the client for interacting with the HostGroupMember builders.
	HostGroupMember *HostGroupMemberClient
	// IpAddress is the client for interacting with the IpAddress builders.
	IpAddress *IpAddressClient
	// IpGroup is the client for interacting with the IpGroup builders.
	IpGroup *IpGroupClient
	// IpGroupMember is the client for interacting with the IpGroupMember builders.
	IpGroupMember *IpGroupMemberClient
	// IpScanJob is the client for interacting with the IpScanJob builders.
	IpScanJob *IpScanJobClient
	// Location is the client for interacting with the Location builders.
	Location *LocationClient
	// Subnet is the client for interacting with the Subnet builders.
	Subnet *SubnetClient
	// Vlan is the client for interacting with the Vlan builders.
	Vlan *VlanClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AuditLog = NewAuditLogClient(c.config)
	c.Device = NewDeviceClient(c.config)
	c.DeviceInterface = NewDeviceInterfaceClient(c.config)
	c.DnsConfig = NewDnsConfigClient(c.config)
	c.HostGroup = NewHostGroupClient(c.config)
	c.HostGroupMember = NewHostGroupMemberClient(c.config)
	c.IpAddress = NewIpAddressClient(c.config)
	c.IpGroup = NewIpGroupClient(c.config)
	c.IpGroupMember = NewIpGroupMemberClient(c.config)
	c.IpScanJob = NewIpScanJobClient(c.config)
	c.Location = NewLocationClient(c.config)
	c.Subnet = NewSubnetClient(c.config)
	c.Vlan = NewVlanClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		AuditLog:        NewAuditLogClient(cfg),
		Device:          NewDeviceClient(cfg),
		DeviceInterface: NewDeviceInterfaceClient(cfg),
		DnsConfig:       NewDnsConfigClient(cfg),
		HostGroup:       NewHostGroupClient(cfg),
		HostGroupMember: NewHostGroupMemberClient(cfg),
		IpAddress:       NewIpAddressClient(cfg),
		IpGroup:         NewIpGroupClient(cfg),
		IpGroupMember:   NewIpGroupMemberClient(cfg),
		IpScanJob:       NewIpScanJobClient(cfg),
		Location:        NewLocationClient(cfg),
		Subnet:          NewSubnetClient(cfg),
		Vlan:            NewVlanClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		AuditLog:        NewAuditLogClient(cfg),
		Device:          NewDeviceClient(cfg),
		DeviceInterface: NewDeviceInterfaceClient(cfg),
		DnsConfig:       NewDnsConfigClient(cfg),
		HostGroup:       NewHostGroupClient(cfg),
		HostGroupMember: NewHostGroupMemberClient(cfg),
		IpAddress:       NewIpAddressClient(cfg),
		IpGroup:         NewIpGroupClient(cfg),
		IpGroupMember:   NewIpGroupMemberClient(cfg),
		IpScanJob:       NewIpScanJobClient(cfg),
		Location:        NewLocationClient(cfg),
		Subnet:          NewSubnetClient(cfg),
		Vlan:            NewVlanClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AuditLog.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AuditLog, c.Device, c.DeviceInterface, c.DnsConfig, c.HostGroup,
		c.HostGroupMember, c.IpAddress, c.IpGroup, c.IpGroupMember, c.IpScanJob,
		c.Location, c.Subnet, c.Vlan,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AuditLog, c.Device, c.DeviceInterface, c.DnsConfig, c.HostGroup,
		c.HostGroupMember, c.IpAddress, c.IpGroup, c.IpGroupMember, c.IpScanJob,
		c.Location, c.Subnet, c.Vlan,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AuditLogMutation:
		return c.AuditLog.mutate(ctx, m)
	case *DeviceMutation:
		return c.Device.mutate(ctx, m)
	case *DeviceInterfaceMutation:
		return c.DeviceInterface.mutate(ctx, m)
	case *DnsConfigMutation:
		return c.DnsConfig.mutate(ctx, m)
	case *HostGroupMutation:
		return c.HostGroup.mutate(ctx, m)
	case *HostGroupMemberMutation:
		return c.HostGroupMember.mutate(ctx, m)
	case *IpAddressMutation:
		return c.IpAddress.mutate(ctx, m)
	case *IpGroupMutation:
		return c.IpGroup.mutate(ctx, m)
	case *IpGroupMemberMutation:
		return c.IpGroupMember.mutate(ctx, m)
	case *IpScanJobMutation:
		return c.IpScanJob.mutate(ctx, m)
	case *LocationMutation:
		return c.Location.mutate(ctx, m)
	case *SubnetMutation:
		return c.Subnet.mutate(ctx, m)
	case *VlanMutation:
		return c.Vlan.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AuditLogClient is a client for the AuditLog schema.
type AuditLogClient struct {
	config
}

// NewAuditLogClient returns a client for the AuditLog from the given config.
func NewAuditLogClient(c config) *AuditLogClient {
	return &AuditLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `auditlog.Hooks(f(g(h())))`.
func (c *AuditLogClient) Use(hooks ...Hook) {
	c.hooks.AuditLog = append(c.hooks.AuditLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `auditlog.Intercept(f(g(h())))`.
func (c *AuditLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuditLog = append(c.inters.AuditLog, interceptors...)
}

// Create returns a builder for creating a AuditLog entity.
func (c *AuditLogClient) Create() *AuditLogCreate {
	mutation := newAuditLogMutation(c.config, OpCreate)
	return &AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuditLog entities.
func (c *AuditLogClient) CreateBulk(builders ...*AuditLogCreate) *AuditLogCreateBulk {
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuditLogClient) MapCreateBulk(slice any, setFunc func(*AuditLogCreate, int)) *AuditLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuditLogCreateBulk{err: fmt.Errorf("calling to AuditLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuditLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuditLog.
func (c *AuditLogClient) Update() *AuditLogUpdate {
	mutation := newAuditLogMutation(c.config, OpUpdate)
	return &AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuditLogClient) UpdateOne(_m *AuditLog) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLog(_m))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuditLogClient) UpdateOneID(id uint32) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLogID(id))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuditLog.
func (c *AuditLogClient) Delete() *AuditLogDelete {
	mutation := newAuditLogMutation(c.config, OpDelete)
	return &AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuditLogClient) DeleteOne(_m *AuditLog) *AuditLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuditLogClient) DeleteOneID(id uint32) *AuditLogDeleteOne {
	builder := c.Delete().Where(auditlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuditLogDeleteOne{builder}
}

// Query returns a query builder for AuditLog.
func (c *AuditLogClient) Query() *AuditLogQuery {
	return &AuditLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuditLog},
		inters: c.Interceptors(),
	}
}

// Get returns a AuditLog entity by its id.
func (c *AuditLogClient) Get(ctx context.Context, id uint32) (*AuditLog, error) {
	return c.Query().Where(auditlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuditLogClient) GetX(ctx context.Context, id uint32) *AuditLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuditLogClient) Hooks() []Hook {
	hooks := c.hooks.AuditLog
	return append(hooks[:len(hooks):len(hooks)], auditlog.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AuditLogClient) Interceptors() []Interceptor {
	return c.inters.AuditLog
}

func (c *AuditLogClient) mutate(ctx context.Context, m *AuditLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuditLog mutation op: %q", m.Op())
	}
}

// DeviceClient is a client for the Device schema.
type DeviceClient struct {
	config
}

// NewDeviceClient returns a client for the Device from the given config.
func NewDeviceClient(c config) *DeviceClient {
	return &DeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `device.Hooks(f(g(h())))`.
func (c *DeviceClient) Use(hooks ...Hook) {
	c.hooks.Device = append(c.hooks.Device, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `device.Intercept(f(g(h())))`.
func (c *DeviceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Device = append(c.inters.Device, interceptors...)
}

// Create returns a builder for creating a Device entity.
func (c *DeviceClient) Create() *DeviceCreate {
	mutation := newDeviceMutation(c.config, OpCreate)
	return &DeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Device entities.
func (c *DeviceClient) CreateBulk(builders ...*DeviceCreate) *DeviceCreateBulk {
	return &DeviceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceClient) MapCreateBulk(slice any, setFunc func(*DeviceCreate, int)) *DeviceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceCreateBulk{err: fmt.Errorf("calling to DeviceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Device.
func (c *DeviceClient) Update() *DeviceUpdate {
	mutation := newDeviceMutation(c.config, OpUpdate)
	return &DeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceClient) UpdateOne(_m *Device) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDevice(_m))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceClient) UpdateOneID(id string) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDeviceID(id))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Device.
func (c *DeviceClient) Delete() *DeviceDelete {
	mutation := newDeviceMutation(c.config, OpDelete)
	return &DeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceClient) DeleteOne(_m *Device) *DeviceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceClient) DeleteOneID(id string) *DeviceDeleteOne {
	builder := c.Delete().Where(device.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceDeleteOne{builder}
}

// Query returns a query builder for Device.
func (c *DeviceClient) Query() *DeviceQuery {
	return &DeviceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDevice},
		inters: c.Interceptors(),
	}
}

// Get returns a Device entity by its id.
func (c *DeviceClient) Get(ctx context.Context, id string) (*Device, error) {
	return c.Query().Where(device.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceClient) GetX(ctx context.Context, id string) *Device {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAddresses queries the addresses edge of a Device.
func (c *DeviceClient) QueryAddresses(_m *Device) *IpAddressQuery {
	query := (&IpAddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(ipaddress.Table, ipaddress.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.AddressesTable, device.AddressesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInterfaces queries the interfaces edge of a Device.
func (c *DeviceClient) QueryInterfaces(_m *Device) *DeviceInterfaceQuery {
	query := (&DeviceInterfaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(deviceinterface.Table, deviceinterface.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.InterfacesTable, device.InterfacesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLocation queries the location edge of a Device.
func (c *DeviceClient) QueryLocation(_m *Device) *LocationQuery {
	query := (&LocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, device.LocationTable, device.LocationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeviceClient) Hooks() []Hook {
	hooks := c.hooks.Device
	return append(hooks[:len(hooks):len(hooks)], device.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DeviceClient) Interceptors() []Interceptor {
	return c.inters.Device
}

func (c *DeviceClient) mutate(ctx context.Context, m *DeviceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Device mutation op: %q", m.Op())
	}
}

// DeviceInterfaceClient is a client for the DeviceInterface schema.
type DeviceInterfaceClient struct {
	config
}

// NewDeviceInterfaceClient returns a client for the DeviceInterface from the given config.
func NewDeviceInterfaceClient(c config) *DeviceInterfaceClient {
	return &DeviceInterfaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `deviceinterface.Hooks(f(g(h())))`.
func (c *DeviceInterfaceClient) Use(hooks ...Hook) {
	c.hooks.DeviceInterface = append(c.hooks.DeviceInterface, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `deviceinterface.Intercept(f(g(h())))`.
func (c *DeviceInterfaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeviceInterface = append(c.inters.DeviceInterface, interceptors...)
}

// Create returns a builder for creating a DeviceInterface entity.
func (c *DeviceInterfaceClient) Create() *DeviceInterfaceCreate {
	mutation := newDeviceInterfaceMutation(c.config, OpCreate)
	return &DeviceInterfaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeviceInterface entities.
func (c *DeviceInterfaceClient) CreateBulk(builders ...*DeviceInterfaceCreate) *DeviceInterfaceCreateBulk {
	return &DeviceInterfaceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceInterfaceClient) MapCreateBulk(slice any, setFunc func(*DeviceInterfaceCreate, int)) *DeviceInterfaceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceInterfaceCreateBulk{err: fmt.Errorf("calling to DeviceInterfaceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceInterfaceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceInterfaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeviceInterface.
func (c *DeviceInterfaceClient) Update() *DeviceInterfaceUpdate {
	mutation := newDeviceInterfaceMutation(c.config, OpUpdate)
	return &DeviceInterfaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceInterfaceClient) UpdateOne(_m *DeviceInterface) *DeviceInterfaceUpdateOne {
	mutation := newDeviceInterfaceMutation(c.config, OpUpdateOne, withDeviceInterface(_m))
	return &DeviceInterfaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceInterfaceClient) UpdateOneID(id string) *DeviceInterfaceUpdateOne {
	mutation := newDeviceInterfaceMutation(c.config, OpUpdateOne, withDeviceInterfaceID(id))
	return &DeviceInterfaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeviceInterface.
func (c *DeviceInterfaceClient) Delete() *DeviceInterfaceDelete {
	mutation := newDeviceInterfaceMutation(c.config, OpDelete)
	return &DeviceInterfaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceInterfaceClient) DeleteOne(_m *DeviceInterface) *DeviceInterfaceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceInterfaceClient) DeleteOneID(id string) *DeviceInterfaceDeleteOne {
	builder := c.Delete().Where(deviceinterface.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceInterfaceDeleteOne{builder}
}

// Query returns a query builder for DeviceInterface.
func (c *DeviceInterfaceClient) Query() *DeviceInterfaceQuery {
	return &DeviceInterfaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeviceInterface},
		inters: c.Interceptors(),
	}
}

// Get returns a DeviceInterface entity by its id.
func (c *DeviceInterfaceClient) Get(ctx context.Context, id string) (*DeviceInterface, error) {
	return c.Query().Where(deviceinterface.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceInterfaceClient) GetX(ctx context.Context, id string) *DeviceInterface {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDevice queries the device edge of a DeviceInterface.
func (c *DeviceInterfaceClient) QueryDevice(_m *DeviceInterface) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deviceinterface.Table, deviceinterface.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, deviceinterface.DeviceTable, deviceinterface.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeviceInterfaceClient) Hooks() []Hook {
	return c.hooks.DeviceInterface
}

// Interceptors returns the client interceptors.
func (c *DeviceInterfaceClient) Interceptors() []Interceptor {
	return c.inters.DeviceInterface
}

func (c *DeviceInterfaceClient) mutate(ctx context.Context, m *DeviceInterfaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceInterfaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceInterfaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceInterfaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceInterfaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DeviceInterface mutation op: %q", m.Op())
	}
}

// DnsConfigClient is a client for the DnsConfig schema.
type DnsConfigClient struct {
	config
}

// NewDnsConfigClient returns a client for the DnsConfig from the given config.
func NewDnsConfigClient(c config) *DnsConfigClient {
	return &DnsConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dnsconfig.Hooks(f(g(h())))`.
func (c *DnsConfigClient) Use(hooks ...Hook) {
	c.hooks.DnsConfig = append(c.hooks.DnsConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dnsconfig.Intercept(f(g(h())))`.
func (c *DnsConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.DnsConfig = append(c.inters.DnsConfig, interceptors...)
}

// Create returns a builder for creating a DnsConfig entity.
func (c *DnsConfigClient) Create() *DnsConfigCreate {
	mutation := newDnsConfigMutation(c.config, OpCreate)
	return &DnsConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DnsConfig entities.
func (c *DnsConfigClient) CreateBulk(builders ...*DnsConfigCreate) *DnsConfigCreateBulk {
	return &DnsConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DnsConfigClient) MapCreateBulk(slice any, setFunc func(*DnsConfigCreate, int)) *DnsConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DnsConfigCreateBulk{err: fmt.Errorf("calling to DnsConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DnsConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DnsConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DnsConfig.
func (c *DnsConfigClient) Update() *DnsConfigUpdate {
	mutation := newDnsConfigMutation(c.config, OpUpdate)
	return &DnsConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DnsConfigClient) UpdateOne(_m *DnsConfig) *DnsConfigUpdateOne {
	mutation := newDnsConfigMutation(c.config, OpUpdateOne, withDnsConfig(_m))
	return &DnsConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DnsConfigClient) UpdateOneID(id string) *DnsConfigUpdateOne {
	mutation := newDnsConfigMutation(c.config, OpUpdateOne, withDnsConfigID(id))
	return &DnsConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DnsConfig.
func (c *DnsConfigClient) Delete() *DnsConfigDelete {
	mutation := newDnsConfigMutation(c.config, OpDelete)
	return &DnsConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DnsConfigClient) DeleteOne(_m *DnsConfig) *DnsConfigDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DnsConfigClient) DeleteOneID(id string) *DnsConfigDeleteOne {
	builder := c.Delete().Where(dnsconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DnsConfigDeleteOne{builder}
}

// Query returns a query builder for DnsConfig.
func (c *DnsConfigClient) Query() *DnsConfigQuery {
	return &DnsConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDnsConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a DnsConfig entity by its id.
func (c *DnsConfigClient) Get(ctx context.Context, id string) (*DnsConfig, error) {
	return c.Query().Where(dnsconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DnsConfigClient) GetX(ctx context.Context, id string) *DnsConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DnsConfigClient) Hooks() []Hook {
	hooks := c.hooks.DnsConfig
	return append(hooks[:len(hooks):len(hooks)], dnsconfig.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DnsConfigClient) Interceptors() []Interceptor {
	return c.inters.DnsConfig
}

func (c *DnsConfigClient) mutate(ctx context.Context, m *DnsConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DnsConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DnsConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DnsConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DnsConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DnsConfig mutation op: %q", m.Op())
	}
}

// HostGroupClient is a client for the HostGroup schema.
type HostGroupClient struct {
	config
}

// NewHostGroupClient returns a client for the HostGroup from the given config.
func NewHostGroupClient(c config) *HostGroupClient {
	return &HostGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hostgroup.Hooks(f(g(h())))`.
func (c *HostGroupClient) Use(hooks ...Hook) {
	c.hooks.HostGroup = append(c.hooks.HostGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hostgroup.Intercept(f(g(h())))`.
func (c *HostGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.HostGroup = append(c.inters.HostGroup, interceptors...)
}

// Create returns a builder for creating a HostGroup entity.
func (c *HostGroupClient) Create() *HostGroupCreate {
	mutation := newHostGroupMutation(c.config, OpCreate)
	return &HostGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HostGroup entities.
func (c *HostGroupClient) CreateBulk(builders ...*HostGroupCreate) *HostGroupCreateBulk {
	return &HostGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HostGroupClient) MapCreateBulk(slice any, setFunc func(*HostGroupCreate, int)) *HostGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HostGroupCreateBulk{err: fmt.Errorf("calling to HostGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HostGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HostGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HostGroup.
func (c *HostGroupClient) Update() *HostGroupUpdate {
	mutation := newHostGroupMutation(c.config, OpUpdate)
	return &HostGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HostGroupClient) UpdateOne(_m *HostGroup) *HostGroupUpdateOne {
	mutation := newHostGroupMutation(c.config, OpUpdateOne, withHostGroup(_m))
	return &HostGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HostGroupClient) UpdateOneID(id string) *HostGroupUpdateOne {
	mutation := newHostGroupMutation(c.config, OpUpdateOne, withHostGroupID(id))
	return &HostGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HostGroup.
func (c *HostGroupClient) Delete() *HostGroupDelete {
	mutation := newHostGroupMutation(c.config, OpDelete)
	return &HostGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HostGroupClient) DeleteOne(_m *HostGroup) *HostGroupDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HostGroupClient) DeleteOneID(id string) *HostGroupDeleteOne {
	builder := c.Delete().Where(hostgroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HostGroupDeleteOne{builder}
}

// Query returns a query builder for HostGroup.
func (c *HostGroupClient) Query() *HostGroupQuery {
	return &HostGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHostGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a HostGroup entity by its id.
func (c *HostGroupClient) Get(ctx context.Context, id string) (*HostGroup, error) {
	return c.Query().Where(hostgroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HostGroupClient) GetX(ctx context.Context, id string) *HostGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMembers queries the members edge of a HostGroup.
func (c *HostGroupClient) QueryMembers(_m *HostGroup) *HostGroupMemberQuery {
	query := (&HostGroupMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hostgroup.Table, hostgroup.FieldID, id),
			sqlgraph.To(hostgroupmember.Table, hostgroupmember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, hostgroup.MembersTable, hostgroup.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HostGroupClient) Hooks() []Hook {
	hooks := c.hooks.HostGroup
	return append(hooks[:len(hooks):len(hooks)], hostgroup.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *HostGroupClient) Interceptors() []Interceptor {
	return c.inters.HostGroup
}

func (c *HostGroupClient) mutate(ctx context.Context, m *HostGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HostGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HostGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HostGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HostGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown HostGroup mutation op: %q", m.Op())
	}
}

// HostGroupMemberClient is a client for the HostGroupMember schema.
type HostGroupMemberClient struct {
	config
}

// NewHostGroupMemberClient returns a client for the HostGroupMember from the given config.
func NewHostGroupMemberClient(c config) *HostGroupMemberClient {
	return &HostGroupMemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hostgroupmember.Hooks(f(g(h())))`.
func (c *HostGroupMemberClient) Use(hooks ...Hook) {
	c.hooks.HostGroupMember = append(c.hooks.HostGroupMember, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hostgroupmember.Intercept(f(g(h())))`.
func (c *HostGroupMemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.HostGroupMember = append(c.inters.HostGroupMember, interceptors...)
}

// Create returns a builder for creating a HostGroupMember entity.
func (c *HostGroupMemberClient) Create() *HostGroupMemberCreate {
	mutation := newHostGroupMemberMutation(c.config, OpCreate)
	return &HostGroupMemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HostGroupMember entities.
func (c *HostGroupMemberClient) CreateBulk(builders ...*HostGroupMemberCreate) *HostGroupMemberCreateBulk {
	return &HostGroupMemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HostGroupMemberClient) MapCreateBulk(slice any, setFunc func(*HostGroupMemberCreate, int)) *HostGroupMemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HostGroupMemberCreateBulk{err: fmt.Errorf("calling to HostGroupMemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HostGroupMemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HostGroupMemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HostGroupMember.
func (c *HostGroupMemberClient) Update() *HostGroupMemberUpdate {
	mutation := newHostGroupMemberMutation(c.config, OpUpdate)
	return &HostGroupMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HostGroupMemberClient) UpdateOne(_m *HostGroupMember) *HostGroupMemberUpdateOne {
	mutation := newHostGroupMemberMutation(c.config, OpUpdateOne, withHostGroupMember(_m))
	return &HostGroupMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HostGroupMemberClient) UpdateOneID(id string) *HostGroupMemberUpdateOne {
	mutation := newHostGroupMemberMutation(c.config, OpUpdateOne, withHostGroupMemberID(id))
	return &HostGroupMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HostGroupMember.
func (c *HostGroupMemberClient) Delete() *HostGroupMemberDelete {
	mutation := newHostGroupMemberMutation(c.config, OpDelete)
	return &HostGroupMemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HostGroupMemberClient) DeleteOne(_m *HostGroupMember) *HostGroupMemberDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HostGroupMemberClient) DeleteOneID(id string) *HostGroupMemberDeleteOne {
	builder := c.Delete().Where(hostgroupmember.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HostGroupMemberDeleteOne{builder}
}

// Query returns a query builder for HostGroupMember.
func (c *HostGroupMemberClient) Query() *HostGroupMemberQuery {
	return &HostGroupMemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHostGroupMember},
		inters: c.Interceptors(),
	}
}

// Get returns a HostGroupMember entity by its id.
func (c *HostGroupMemberClient) Get(ctx context.Context, id string) (*HostGroupMember, error) {
	return c.Query().Where(hostgroupmember.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HostGroupMemberClient) GetX(ctx context.Context, id string) *HostGroupMember {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGroup queries the group edge of a HostGroupMember.
func (c *HostGroupMemberClient) QueryGroup(_m *HostGroupMember) *HostGroupQuery {
	query := (&HostGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hostgroupmember.Table, hostgroupmember.FieldID, id),
			sqlgraph.To(hostgroup.Table, hostgroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, hostgroupmember.GroupTable, hostgroupmember.GroupColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a HostGroupMember.
func (c *HostGroupMemberClient) QueryDevice(_m *HostGroupMember) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hostgroupmember.Table, hostgroupmember.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hostgroupmember.DeviceTable, hostgroupmember.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HostGroupMemberClient) Hooks() []Hook {
	return c.hooks.HostGroupMember
}

// Interceptors returns the client interceptors.
func (c *HostGroupMemberClient) Interceptors() []Interceptor {
	return c.inters.HostGroupMember
}

func (c *HostGroupMemberClient) mutate(ctx context.Context, m *HostGroupMemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HostGroupMemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HostGroupMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HostGroupMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HostGroupMemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown HostGroupMember mutation op: %q", m.Op())
	}
}

// IpAddressClient is a client for the IpAddress schema.
type IpAddressClient struct {
	config
}

// NewIpAddressClient returns a client for the IpAddress from the given config.
func NewIpAddressClient(c config) *IpAddressClient {
	return &IpAddressClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ipaddress.Hooks(f(g(h())))`.
func (c *IpAddressClient) Use(hooks ...Hook) {
	c.hooks.IpAddress = append(c.hooks.IpAddress, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ipaddress.Intercept(f(g(h())))`.
func (c *IpAddressClient) Intercept(interceptors ...Interceptor) {
	c.inters.IpAddress = append(c.inters.IpAddress, interceptors...)
}

// Create returns a builder for creating a IpAddress entity.
func (c *IpAddressClient) Create() *IpAddressCreate {
	mutation := newIpAddressMutation(c.config, OpCreate)
	return &IpAddressCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IpAddress entities.
func (c *IpAddressClient) CreateBulk(builders ...*IpAddressCreate) *IpAddressCreateBulk {
	return &IpAddressCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IpAddressClient) MapCreateBulk(slice any, setFunc func(*IpAddressCreate, int)) *IpAddressCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IpAddressCreateBulk{err: fmt.Errorf("calling to IpAddressClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IpAddressCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IpAddressCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IpAddress.
func (c *IpAddressClient) Update() *IpAddressUpdate {
	mutation := newIpAddressMutation(c.config, OpUpdate)
	return &IpAddressUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IpAddressClient) UpdateOne(_m *IpAddress) *IpAddressUpdateOne {
	mutation := newIpAddressMutation(c.config, OpUpdateOne, withIpAddress(_m))
	return &IpAddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IpAddressClient) UpdateOneID(id string) *IpAddressUpdateOne {
	mutation := newIpAddressMutation(c.config, OpUpdateOne, withIpAddressID(id))
	return &IpAddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IpAddress.
func (c *IpAddressClient) Delete() *IpAddressDelete {
	mutation := newIpAddressMutation(c.config, OpDelete)
	return &IpAddressDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IpAddressClient) DeleteOne(_m *IpAddress) *IpAddressDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IpAddressClient) DeleteOneID(id string) *IpAddressDeleteOne {
	builder := c.Delete().Where(ipaddress.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IpAddressDeleteOne{builder}
}

// Query returns a query builder for IpAddress.
func (c *IpAddressClient) Query() *IpAddressQuery {
	return &IpAddressQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIpAddress},
		inters: c.Interceptors(),
	}
}

// Get returns a IpAddress entity by its id.
func (c *IpAddressClient) Get(ctx context.Context, id string) (*IpAddress, error) {
	return c.Query().Where(ipaddress.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IpAddressClient) GetX(ctx context.Context, id string) *IpAddress {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubnet queries the subnet edge of a IpAddress.
func (c *IpAddressClient) QuerySubnet(_m *IpAddress) *SubnetQuery {
	query := (&SubnetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ipaddress.Table, ipaddress.FieldID, id),
			sqlgraph.To(subnet.Table, subnet.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ipaddress.SubnetTable, ipaddress.SubnetColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a IpAddress.
func (c *IpAddressClient) QueryDevice(_m *IpAddress) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ipaddress.Table, ipaddress.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ipaddress.DeviceTable, ipaddress.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IpAddressClient) Hooks() []Hook {
	hooks := c.hooks.IpAddress
	return append(hooks[:len(hooks):len(hooks)], ipaddress.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IpAddressClient) Interceptors() []Interceptor {
	return c.inters.IpAddress
}

func (c *IpAddressClient) mutate(ctx context.Context, m *IpAddressMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IpAddressCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IpAddressUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IpAddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IpAddressDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IpAddress mutation op: %q", m.Op())
	}
}

// IpGroupClient is a client for the IpGroup schema.
type IpGroupClient struct {
	config
}

// NewIpGroupClient returns a client for the IpGroup from the given config.
func NewIpGroupClient(c config) *IpGroupClient {
	return &IpGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ipgroup.Hooks(f(g(h())))`.
func (c *IpGroupClient) Use(hooks ...Hook) {
	c.hooks.IpGroup = append(c.hooks.IpGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ipgroup.Intercept(f(g(h())))`.
func (c *IpGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.IpGroup = append(c.inters.IpGroup, interceptors...)
}

// Create returns a builder for creating a IpGroup entity.
func (c *IpGroupClient) Create() *IpGroupCreate {
	mutation := newIpGroupMutation(c.config, OpCreate)
	return &IpGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IpGroup entities.
func (c *IpGroupClient) CreateBulk(builders ...*IpGroupCreate) *IpGroupCreateBulk {
	return &IpGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IpGroupClient) MapCreateBulk(slice any, setFunc func(*IpGroupCreate, int)) *IpGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IpGroupCreateBulk{err: fmt.Errorf("calling to IpGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IpGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IpGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IpGroup.
func (c *IpGroupClient) Update() *IpGroupUpdate {
	mutation := newIpGroupMutation(c.config, OpUpdate)
	return &IpGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IpGroupClient) UpdateOne(_m *IpGroup) *IpGroupUpdateOne {
	mutation := newIpGroupMutation(c.config, OpUpdateOne, withIpGroup(_m))
	return &IpGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IpGroupClient) UpdateOneID(id string) *IpGroupUpdateOne {
	mutation := newIpGroupMutation(c.config, OpUpdateOne, withIpGroupID(id))
	return &IpGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IpGroup.
func (c *IpGroupClient) Delete() *IpGroupDelete {
	mutation := newIpGroupMutation(c.config, OpDelete)
	return &IpGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IpGroupClient) DeleteOne(_m *IpGroup) *IpGroupDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IpGroupClient) DeleteOneID(id string) *IpGroupDeleteOne {
	builder := c.Delete().Where(ipgroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IpGroupDeleteOne{builder}
}

// Query returns a query builder for IpGroup.
func (c *IpGroupClient) Query() *IpGroupQuery {
	return &IpGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIpGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a IpGroup entity by its id.
func (c *IpGroupClient) Get(ctx context.Context, id string) (*IpGroup, error) {
	return c.Query().Where(ipgroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IpGroupClient) GetX(ctx context.Context, id string) *IpGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMembers queries the members edge of a IpGroup.
func (c *IpGroupClient) QueryMembers(_m *IpGroup) *IpGroupMemberQuery {
	query := (&IpGroupMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ipgroup.Table, ipgroup.FieldID, id),
			sqlgraph.To(ipgroupmember.Table, ipgroupmember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ipgroup.MembersTable, ipgroup.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IpGroupClient) Hooks() []Hook {
	hooks := c.hooks.IpGroup
	return append(hooks[:len(hooks):len(hooks)], ipgroup.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IpGroupClient) Interceptors() []Interceptor {
	return c.inters.IpGroup
}

func (c *IpGroupClient) mutate(ctx context.Context, m *IpGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IpGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IpGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IpGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IpGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IpGroup mutation op: %q", m.Op())
	}
}

// IpGroupMemberClient is a client for the IpGroupMember schema.
type IpGroupMemberClient struct {
	config
}

// NewIpGroupMemberClient returns a client for the IpGroupMember from the given config.
func NewIpGroupMemberClient(c config) *IpGroupMemberClient {
	return &IpGroupMemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ipgroupmember.Hooks(f(g(h())))`.
func (c *IpGroupMemberClient) Use(hooks ...Hook) {
	c.hooks.IpGroupMember = append(c.hooks.IpGroupMember, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ipgroupmember.Intercept(f(g(h())))`.
func (c *IpGroupMemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.IpGroupMember = append(c.inters.IpGroupMember, interceptors...)
}

// Create returns a builder for creating a IpGroupMember entity.
func (c *IpGroupMemberClient) Create() *IpGroupMemberCreate {
	mutation := newIpGroupMemberMutation(c.config, OpCreate)
	return &IpGroupMemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IpGroupMember entities.
func (c *IpGroupMemberClient) CreateBulk(builders ...*IpGroupMemberCreate) *IpGroupMemberCreateBulk {
	return &IpGroupMemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IpGroupMemberClient) MapCreateBulk(slice any, setFunc func(*IpGroupMemberCreate, int)) *IpGroupMemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IpGroupMemberCreateBulk{err: fmt.Errorf("calling to IpGroupMemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IpGroupMemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IpGroupMemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IpGroupMember.
func (c *IpGroupMemberClient) Update() *IpGroupMemberUpdate {
	mutation := newIpGroupMemberMutation(c.config, OpUpdate)
	return &IpGroupMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IpGroupMemberClient) UpdateOne(_m *IpGroupMember) *IpGroupMemberUpdateOne {
	mutation := newIpGroupMemberMutation(c.config, OpUpdateOne, withIpGroupMember(_m))
	return &IpGroupMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IpGroupMemberClient) UpdateOneID(id string) *IpGroupMemberUpdateOne {
	mutation := newIpGroupMemberMutation(c.config, OpUpdateOne, withIpGroupMemberID(id))
	return &IpGroupMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IpGroupMember.
func (c *IpGroupMemberClient) Delete() *IpGroupMemberDelete {
	mutation := newIpGroupMemberMutation(c.config, OpDelete)
	return &IpGroupMemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IpGroupMemberClient) DeleteOne(_m *IpGroupMember) *IpGroupMemberDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IpGroupMemberClient) DeleteOneID(id string) *IpGroupMemberDeleteOne {
	builder := c.Delete().Where(ipgroupmember.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IpGroupMemberDeleteOne{builder}
}

// Query returns a query builder for IpGroupMember.
func (c *IpGroupMemberClient) Query() *IpGroupMemberQuery {
	return &IpGroupMemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIpGroupMember},
		inters: c.Interceptors(),
	}
}

// Get returns a IpGroupMember entity by its id.
func (c *IpGroupMemberClient) Get(ctx context.Context, id string) (*IpGroupMember, error) {
	return c.Query().Where(ipgroupmember.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IpGroupMemberClient) GetX(ctx context.Context, id string) *IpGroupMember {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGroup queries the group edge of a IpGroupMember.
func (c *IpGroupMemberClient) QueryGroup(_m *IpGroupMember) *IpGroupQuery {
	query := (&IpGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ipgroupmember.Table, ipgroupmember.FieldID, id),
			sqlgraph.To(ipgroup.Table, ipgroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ipgroupmember.GroupTable, ipgroupmember.GroupColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IpGroupMemberClient) Hooks() []Hook {
	return c.hooks.IpGroupMember
}

// Interceptors returns the client interceptors.
func (c *IpGroupMemberClient) Interceptors() []Interceptor {
	return c.inters.IpGroupMember
}

func (c *IpGroupMemberClient) mutate(ctx context.Context, m *IpGroupMemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IpGroupMemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IpGroupMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IpGroupMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IpGroupMemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IpGroupMember mutation op: %q", m.Op())
	}
}

// IpScanJobClient is a client for the IpScanJob schema.
type IpScanJobClient struct {
	config
}

// NewIpScanJobClient returns a client for the IpScanJob from the given config.
func NewIpScanJobClient(c config) *IpScanJobClient {
	return &IpScanJobClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ipscanjob.Hooks(f(g(h())))`.
func (c *IpScanJobClient) Use(hooks ...Hook) {
	c.hooks.IpScanJob = append(c.hooks.IpScanJob, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ipscanjob.Intercept(f(g(h())))`.
func (c *IpScanJobClient) Intercept(interceptors ...Interceptor) {
	c.inters.IpScanJob = append(c.inters.IpScanJob, interceptors...)
}

// Create returns a builder for creating a IpScanJob entity.
func (c *IpScanJobClient) Create() *IpScanJobCreate {
	mutation := newIpScanJobMutation(c.config, OpCreate)
	return &IpScanJobCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IpScanJob entities.
func (c *IpScanJobClient) CreateBulk(builders ...*IpScanJobCreate) *IpScanJobCreateBulk {
	return &IpScanJobCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IpScanJobClient) MapCreateBulk(slice any, setFunc func(*IpScanJobCreate, int)) *IpScanJobCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IpScanJobCreateBulk{err: fmt.Errorf("calling to IpScanJobClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IpScanJobCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IpScanJobCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IpScanJob.
func (c *IpScanJobClient) Update() *IpScanJobUpdate {
	mutation := newIpScanJobMutation(c.config, OpUpdate)
	return &IpScanJobUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IpScanJobClient) UpdateOne(_m *IpScanJob) *IpScanJobUpdateOne {
	mutation := newIpScanJobMutation(c.config, OpUpdateOne, withIpScanJob(_m))
	return &IpScanJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IpScanJobClient) UpdateOneID(id string) *IpScanJobUpdateOne {
	mutation := newIpScanJobMutation(c.config, OpUpdateOne, withIpScanJobID(id))
	return &IpScanJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IpScanJob.
func (c *IpScanJobClient) Delete() *IpScanJobDelete {
	mutation := newIpScanJobMutation(c.config, OpDelete)
	return &IpScanJobDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IpScanJobClient) DeleteOne(_m *IpScanJob) *IpScanJobDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IpScanJobClient) DeleteOneID(id string) *IpScanJobDeleteOne {
	builder := c.Delete().Where(ipscanjob.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IpScanJobDeleteOne{builder}
}

// Query returns a query builder for IpScanJob.
func (c *IpScanJobClient) Query() *IpScanJobQuery {
	return &IpScanJobQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIpScanJob},
		inters: c.Interceptors(),
	}
}

// Get returns a IpScanJob entity by its id.
func (c *IpScanJobClient) Get(ctx context.Context, id string) (*IpScanJob, error) {
	return c.Query().Where(ipscanjob.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IpScanJobClient) GetX(ctx context.Context, id string) *IpScanJob {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubnet queries the subnet edge of a IpScanJob.
func (c *IpScanJobClient) QuerySubnet(_m *IpScanJob) *SubnetQuery {
	query := (&SubnetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ipscanjob.Table, ipscanjob.FieldID, id),
			sqlgraph.To(subnet.Table, subnet.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ipscanjob.SubnetTable, ipscanjob.SubnetColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IpScanJobClient) Hooks() []Hook {
	hooks := c.hooks.IpScanJob
	return append(hooks[:len(hooks):len(hooks)], ipscanjob.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IpScanJobClient) Interceptors() []Interceptor {
	return c.inters.IpScanJob
}

func (c *IpScanJobClient) mutate(ctx context.Context, m *IpScanJobMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IpScanJobCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IpScanJobUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IpScanJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IpScanJobDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IpScanJob mutation op: %q", m.Op())
	}
}

// LocationClient is a client for the Location schema.
type LocationClient struct {
	config
}

// NewLocationClient returns a client for the Location from the given config.
func NewLocationClient(c config) *LocationClient {
	return &LocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `location.Hooks(f(g(h())))`.
func (c *LocationClient) Use(hooks ...Hook) {
	c.hooks.Location = append(c.hooks.Location, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `location.Intercept(f(g(h())))`.
func (c *LocationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Location = append(c.inters.Location, interceptors...)
}

// Create returns a builder for creating a Location entity.
func (c *LocationClient) Create() *LocationCreate {
	mutation := newLocationMutation(c.config, OpCreate)
	return &LocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Location entities.
func (c *LocationClient) CreateBulk(builders ...*LocationCreate) *LocationCreateBulk {
	return &LocationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LocationClient) MapCreateBulk(slice any, setFunc func(*LocationCreate, int)) *LocationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LocationCreateBulk{err: fmt.Errorf("calling to LocationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LocationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Location.
func (c *LocationClient) Update() *LocationUpdate {
	mutation := newLocationMutation(c.config, OpUpdate)
	return &LocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LocationClient) UpdateOne(_m *Location) *LocationUpdateOne {
	mutation := newLocationMutation(c.config, OpUpdateOne, withLocation(_m))
	return &LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LocationClient) UpdateOneID(id string) *LocationUpdateOne {
	mutation := newLocationMutation(c.config, OpUpdateOne, withLocationID(id))
	return &LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Location.
func (c *LocationClient) Delete() *LocationDelete {
	mutation := newLocationMutation(c.config, OpDelete)
	return &LocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LocationClient) DeleteOne(_m *Location) *LocationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LocationClient) DeleteOneID(id string) *LocationDeleteOne {
	builder := c.Delete().Where(location.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LocationDeleteOne{builder}
}

// Query returns a query builder for Location.
func (c *LocationClient) Query() *LocationQuery {
	return &LocationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLocation},
		inters: c.Interceptors(),
	}
}

// Get returns a Location entity by its id.
func (c *LocationClient) Get(ctx context.Context, id string) (*Location, error) {
	return c.Query().Where(location.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LocationClient) GetX(ctx context.Context, id string) *Location {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParent queries the parent edge of a Location.
func (c *LocationClient) QueryParent(_m *Location) *LocationQuery {
	query := (&LocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, location.ParentTable, location.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Location.
func (c *LocationClient) QueryChildren(_m *Location) *LocationQuery {
	query := (&LocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, location.ChildrenTable, location.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubnets queries the subnets edge of a Location.
func (c *LocationClient) QuerySubnets(_m *Location) *SubnetQuery {
	query := (&SubnetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(subnet.Table, subnet.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, location.SubnetsTable, location.SubnetsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVlans queries the vlans edge of a Location.
func (c *LocationClient) QueryVlans(_m *Location) *VlanQuery {
	query := (&VlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(vlan.Table, vlan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, location.VlansTable, location.VlansColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevices queries the devices edge of a Location.
func (c *LocationClient) QueryDevices(_m *Location) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, location.DevicesTable, location.DevicesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LocationClient) Hooks() []Hook {
	hooks := c.hooks.Location
	return append(hooks[:len(hooks):len(hooks)], location.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *LocationClient) Interceptors() []Interceptor {
	return c.inters.Location
}

func (c *LocationClient) mutate(ctx context.Context, m *LocationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LocationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LocationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LocationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Location mutation op: %q", m.Op())
	}
}

// SubnetClient is a client for the Subnet schema.
type SubnetClient struct {
	config
}

// NewSubnetClient returns a client for the Subnet from the given config.
func NewSubnetClient(c config) *SubnetClient {
	return &SubnetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subnet.Hooks(f(g(h())))`.
func (c *SubnetClient) Use(hooks ...Hook) {
	c.hooks.Subnet = append(c.hooks.Subnet, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subnet.Intercept(f(g(h())))`.
func (c *SubnetClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subnet = append(c.inters.Subnet, interceptors...)
}

// Create returns a builder for creating a Subnet entity.
func (c *SubnetClient) Create() *SubnetCreate {
	mutation := newSubnetMutation(c.config, OpCreate)
	return &SubnetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subnet entities.
func (c *SubnetClient) CreateBulk(builders ...*SubnetCreate) *SubnetCreateBulk {
	return &SubnetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubnetClient) MapCreateBulk(slice any, setFunc func(*SubnetCreate, int)) *SubnetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubnetCreateBulk{err: fmt.Errorf("calling to SubnetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubnetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubnetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subnet.
func (c *SubnetClient) Update() *SubnetUpdate {
	mutation := newSubnetMutation(c.config, OpUpdate)
	return &SubnetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubnetClient) UpdateOne(_m *Subnet) *SubnetUpdateOne {
	mutation := newSubnetMutation(c.config, OpUpdateOne, withSubnet(_m))
	return &SubnetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubnetClient) UpdateOneID(id string) *SubnetUpdateOne {
	mutation := newSubnetMutation(c.config, OpUpdateOne, withSubnetID(id))
	return &SubnetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subnet.
func (c *SubnetClient) Delete() *SubnetDelete {
	mutation := newSubnetMutation(c.config, OpDelete)
	return &SubnetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubnetClient) DeleteOne(_m *Subnet) *SubnetDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubnetClient) DeleteOneID(id string) *SubnetDeleteOne {
	builder := c.Delete().Where(subnet.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubnetDeleteOne{builder}
}

// Query returns a query builder for Subnet.
func (c *SubnetClient) Query() *SubnetQuery {
	return &SubnetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubnet},
		inters: c.Interceptors(),
	}
}

// Get returns a Subnet entity by its id.
func (c *SubnetClient) Get(ctx context.Context, id string) (*Subnet, error) {
	return c.Query().Where(subnet.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubnetClient) GetX(ctx context.Context, id string) *Subnet {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAddresses queries the addresses edge of a Subnet.
func (c *SubnetClient) QueryAddresses(_m *Subnet) *IpAddressQuery {
	query := (&IpAddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subnet.Table, subnet.FieldID, id),
			sqlgraph.To(ipaddress.Table, ipaddress.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, subnet.AddressesTable, subnet.AddressesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Subnet.
func (c *SubnetClient) QueryParent(_m *Subnet) *SubnetQuery {
	query := (&SubnetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subnet.Table, subnet.FieldID, id),
			sqlgraph.To(subnet.Table, subnet.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subnet.ParentTable, subnet.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Subnet.
func (c *SubnetClient) QueryChildren(_m *Subnet) *SubnetQuery {
	query := (&SubnetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subnet.Table, subnet.FieldID, id),
			sqlgraph.To(subnet.Table, subnet.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, subnet.ChildrenTable, subnet.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVlan queries the vlan edge of a Subnet.
func (c *SubnetClient) QueryVlan(_m *Subnet) *VlanQuery {
	query := (&VlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subnet.Table, subnet.FieldID, id),
			sqlgraph.To(vlan.Table, vlan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subnet.VlanTable, subnet.VlanColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLocation queries the location edge of a Subnet.
func (c *SubnetClient) QueryLocation(_m *Subnet) *LocationQuery {
	query := (&LocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subnet.Table, subnet.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subnet.LocationTable, subnet.LocationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScanJobs queries the scan_jobs edge of a Subnet.
func (c *SubnetClient) QueryScanJobs(_m *Subnet) *IpScanJobQuery {
	query := (&IpScanJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subnet.Table, subnet.FieldID, id),
			sqlgraph.To(ipscanjob.Table, ipscanjob.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, subnet.ScanJobsTable, subnet.ScanJobsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubnetClient) Hooks() []Hook {
	hooks := c.hooks.Subnet
	return append(hooks[:len(hooks):len(hooks)], subnet.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SubnetClient) Interceptors() []Interceptor {
	return c.inters.Subnet
}

func (c *SubnetClient) mutate(ctx context.Context, m *SubnetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubnetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubnetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubnetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubnetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Subnet mutation op: %q", m.Op())
	}
}

// VlanClient is a client for the Vlan schema.
type VlanClient struct {
	config
}

// NewVlanClient returns a client for the Vlan from the given config.
func NewVlanClient(c config) *VlanClient {
	return &VlanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vlan.Hooks(f(g(h())))`.
func (c *VlanClient) Use(hooks ...Hook) {
	c.hooks.Vlan = append(c.hooks.Vlan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vlan.Intercept(f(g(h())))`.
func (c *VlanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Vlan = append(c.inters.Vlan, interceptors...)
}

// Create returns a builder for creating a Vlan entity.
func (c *VlanClient) Create() *VlanCreate {
	mutation := newVlanMutation(c.config, OpCreate)
	return &VlanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Vlan entities.
func (c *VlanClient) CreateBulk(builders ...*VlanCreate) *VlanCreateBulk {
	return &VlanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VlanClient) MapCreateBulk(slice any, setFunc func(*VlanCreate, int)) *VlanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VlanCreateBulk{err: fmt.Errorf("calling to VlanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VlanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VlanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Vlan.
func (c *VlanClient) Update() *VlanUpdate {
	mutation := newVlanMutation(c.config, OpUpdate)
	return &VlanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VlanClient) UpdateOne(_m *Vlan) *VlanUpdateOne {
	mutation := newVlanMutation(c.config, OpUpdateOne, withVlan(_m))
	return &VlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VlanClient) UpdateOneID(id string) *VlanUpdateOne {
	mutation := newVlanMutation(c.config, OpUpdateOne, withVlanID(id))
	return &VlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Vlan.
func (c *VlanClient) Delete() *VlanDelete {
	mutation := newVlanMutation(c.config, OpDelete)
	return &VlanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VlanClient) DeleteOne(_m *Vlan) *VlanDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VlanClient) DeleteOneID(id string) *VlanDeleteOne {
	builder := c.Delete().Where(vlan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VlanDeleteOne{builder}
}

// Query returns a query builder for Vlan.
func (c *VlanClient) Query() *VlanQuery {
	return &VlanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVlan},
		inters: c.Interceptors(),
	}
}

// Get returns a Vlan entity by its id.
func (c *VlanClient) Get(ctx context.Context, id string) (*Vlan, error) {
	return c.Query().Where(vlan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VlanClient) GetX(ctx context.Context, id string) *Vlan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubnets queries the subnets edge of a Vlan.
func (c *VlanClient) QuerySubnets(_m *Vlan) *SubnetQuery {
	query := (&SubnetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vlan.Table, vlan.FieldID, id),
			sqlgraph.To(subnet.Table, subnet.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, vlan.SubnetsTable, vlan.SubnetsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLocation queries the location edge of a Vlan.
func (c *VlanClient) QueryLocation(_m *Vlan) *LocationQuery {
	query := (&LocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vlan.Table, vlan.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, vlan.LocationTable, vlan.LocationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VlanClient) Hooks() []Hook {
	hooks := c.hooks.Vlan
	return append(hooks[:len(hooks):len(hooks)], vlan.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *VlanClient) Interceptors() []Interceptor {
	return c.inters.Vlan
}

func (c *VlanClient) mutate(ctx context.Context, m *VlanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VlanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VlanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VlanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Vlan mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AuditLog, Device, DeviceInterface, DnsConfig, HostGroup, HostGroupMember,
		IpAddress, IpGroup, IpGroupMember, IpScanJob, Location, Subnet, Vlan []ent.Hook
	}
	inters struct {
		AuditLog, Device, DeviceInterface, DnsConfig, HostGroup, HostGroupMember,
		IpAddress, IpGroup, IpGroupMember, IpScanJob, Location, Subnet,
		Vlan []ent.Interceptor
	}
)
